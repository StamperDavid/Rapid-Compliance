[{"filePath":"C:\\Users\\David\\PycharmProjects\\AI Sales Platform\\src\\components\\PageRenderer.tsx","messages":[{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":27,"column":7,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":27,"endColumn":82}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"'use client';\r\n\r\nimport React from 'react';\r\nimport Link from 'next/link';\r\nimport { PageContent } from '@/hooks/usePageContent';\r\nimport { useWebsiteTheme } from '@/hooks/useWebsiteTheme';\r\n\r\ninterface WidgetElement {\r\n  id: string;\r\n  type: string;\r\n  content?: any;\r\n  children?: WidgetElement[];\r\n  styles?: {\r\n    desktop?: Record<string, string>;\r\n    tablet?: Record<string, string>;\r\n    mobile?: Record<string, string>;\r\n  };\r\n  settings?: Record<string, any>;\r\n}\r\n\r\nfunction ElementRenderer({ element }: { element: WidgetElement }) {\r\n  const { theme } = useWebsiteTheme();\r\n  const styles = element.styles?.desktop || {};\r\n\r\n  switch (element.type) {\r\n    case 'heading':\r\n      const Tag = (element.settings?.tag || 'h2') as keyof JSX.IntrinsicElements;\r\n      return <Tag style={styles}>{element.content}</Tag>;\r\n\r\n    case 'text':\r\n      return <p style={styles}>{element.content}</p>;\r\n\r\n    case 'button':\r\n      return (\r\n        <Link\r\n          href={element.settings?.href || '#'}\r\n          style={{\r\n            display: 'inline-block',\r\n            textDecoration: 'none',\r\n            ...styles,\r\n          }}\r\n        >\r\n          {element.content}\r\n        </Link>\r\n      );\r\n\r\n    case 'image':\r\n      return (\r\n        <img\r\n          src={typeof element.content === 'string' ? element.content : '/placeholder.jpg'}\r\n          alt={element.settings?.alt || ''}\r\n          style={{ maxWidth: '100%', ...styles }}\r\n        />\r\n      );\r\n\r\n    case 'icon':\r\n      return <span style={{ fontSize: '3rem', ...styles }}>{element.content}</span>;\r\n\r\n    case 'spacer':\r\n      return <div style={{ height: styles.height || '40px' }} />;\r\n\r\n    case 'divider':\r\n      return <hr style={{ border: 'none', borderTop: '1px solid rgba(255,255,255,0.1)', margin: '2rem 0', ...styles }} />;\r\n\r\n    case 'stats':\r\n      if (element.content?.items) {\r\n        return (\r\n          <div style={{ display: 'flex', justifyContent: 'center', gap: '4rem', flexWrap: 'wrap', ...styles }}>\r\n            {element.content.items.map((item: { value: string; label: string }, idx: number) => (\r\n              <div key={idx} style={{ textAlign: 'center' }}>\r\n                <div style={{ fontSize: '3rem', fontWeight: 'bold', color: theme.primaryColor }}>{item.value}</div>\r\n                <div style={{ fontSize: '1rem', color: 'rgba(255,255,255,0.7)' }}>{item.label}</div>\r\n              </div>\r\n            ))}\r\n          </div>\r\n        );\r\n      }\r\n      return null;\r\n\r\n    case 'feature-grid':\r\n      if (element.content?.items) {\r\n        return (\r\n          <div style={{ \r\n            display: 'grid', \r\n            gridTemplateColumns: 'repeat(auto-fit, minmax(280px, 1fr))', \r\n            gap: '24px',\r\n            ...styles \r\n          }}>\r\n            {element.content.items.map((item: { icon: string; title: string; desc: string }, idx: number) => (\r\n              <div \r\n                key={idx} \r\n                style={{ \r\n                  padding: '24px', \r\n                  backgroundColor: 'rgba(255,255,255,0.05)', \r\n                  borderRadius: '12px',\r\n                  border: '1px solid rgba(255,255,255,0.1)',\r\n                }}\r\n              >\r\n                <div style={{ fontSize: '2.5rem', marginBottom: '12px' }}>{item.icon}</div>\r\n                <h3 style={{ fontSize: '1.25rem', fontWeight: 'bold', color: '#fff', marginBottom: '8px' }}>{item.title}</h3>\r\n                <p style={{ fontSize: '0.9rem', color: 'rgba(255,255,255,0.7)', lineHeight: '1.6' }}>{item.desc}</p>\r\n              </div>\r\n            ))}\r\n          </div>\r\n        );\r\n      }\r\n      return null;\r\n\r\n    case 'faq':\r\n      if (element.content?.items) {\r\n        return (\r\n          <div style={{ display: 'flex', flexDirection: 'column', gap: '16px', ...styles }}>\r\n            {element.content.items.map((item: { q: string; a: string }, idx: number) => (\r\n              <div \r\n                key={idx} \r\n                style={{ \r\n                  padding: '24px', \r\n                  backgroundColor: 'rgba(255,255,255,0.05)', \r\n                  borderRadius: '12px',\r\n                  border: '1px solid rgba(255,255,255,0.1)',\r\n                }}\r\n              >\r\n                <h3 style={{ fontSize: '1.125rem', fontWeight: 'bold', color: '#fff', marginBottom: '12px' }}>{item.q}</h3>\r\n                <p style={{ fontSize: '1rem', color: 'rgba(255,255,255,0.7)', lineHeight: '1.6' }}>{item.a}</p>\r\n              </div>\r\n            ))}\r\n          </div>\r\n        );\r\n      }\r\n      return null;\r\n\r\n    case 'pricing-table':\r\n      if (element.content?.plans) {\r\n        return (\r\n          <div style={{ \r\n            display: 'grid', \r\n            gridTemplateColumns: 'repeat(auto-fit, minmax(280px, 1fr))', \r\n            gap: '24px',\r\n            ...styles \r\n          }}>\r\n            {element.content.plans.map((plan: { name: string; price: string; period: string; features: string[]; highlighted?: boolean }, idx: number) => (\r\n              <div \r\n                key={idx} \r\n                style={{ \r\n                  padding: '32px', \r\n                  backgroundColor: plan.highlighted ? theme.primaryColor : 'rgba(255,255,255,0.05)', \r\n                  borderRadius: '16px',\r\n                  border: plan.highlighted ? 'none' : '1px solid rgba(255,255,255,0.1)',\r\n                  position: 'relative',\r\n                  transform: plan.highlighted ? 'scale(1.05)' : 'none',\r\n                }}\r\n              >\r\n                {plan.highlighted && (\r\n                  <div style={{\r\n                    position: 'absolute',\r\n                    top: '-12px',\r\n                    left: '50%',\r\n                    transform: 'translateX(-50%)',\r\n                    padding: '4px 16px',\r\n                    backgroundColor: '#fbbf24',\r\n                    color: '#000',\r\n                    fontSize: '0.75rem',\r\n                    fontWeight: 'bold',\r\n                    borderRadius: '9999px',\r\n                  }}>\r\n                    MOST POPULAR\r\n                  </div>\r\n                )}\r\n                <h3 style={{ fontSize: '1.5rem', fontWeight: 'bold', color: '#fff', marginBottom: '8px' }}>{plan.name}</h3>\r\n                <div style={{ marginBottom: '24px' }}>\r\n                  <span style={{ fontSize: '3rem', fontWeight: 'bold', color: '#fff' }}>{plan.price}</span>\r\n                  <span style={{ color: 'rgba(255,255,255,0.7)' }}>{plan.period}</span>\r\n                </div>\r\n                <Link\r\n                  href=\"/signup\"\r\n                  style={{\r\n                    display: 'block',\r\n                    width: '100%',\r\n                    padding: '12px',\r\n                    textAlign: 'center',\r\n                    backgroundColor: plan.highlighted ? '#fff' : theme.primaryColor,\r\n                    color: plan.highlighted ? theme.primaryColor : '#fff',\r\n                    borderRadius: '8px',\r\n                    fontWeight: '600',\r\n                    textDecoration: 'none',\r\n                    marginBottom: '24px',\r\n                  }}\r\n                >\r\n                  Get Started\r\n                </Link>\r\n                <ul style={{ listStyle: 'none', padding: 0, margin: 0 }}>\r\n                  {plan.features.map((feature, fIdx) => (\r\n                    <li key={fIdx} style={{ display: 'flex', alignItems: 'flex-start', gap: '8px', marginBottom: '12px', color: 'rgba(255,255,255,0.9)' }}>\r\n                      <span style={{ color: plan.highlighted ? '#fff' : theme.primaryColor }}>Γ£ô</span>\r\n                      {feature}\r\n                    </li>\r\n                  ))}\r\n                </ul>\r\n              </div>\r\n            ))}\r\n          </div>\r\n        );\r\n      }\r\n      return null;\r\n\r\n    case 'testimonial':\r\n      if (typeof element.content === 'object') {\r\n        return (\r\n          <div style={{ \r\n            padding: '32px', \r\n            backgroundColor: 'rgba(255,255,255,0.05)', \r\n            borderRadius: '16px',\r\n            border: '1px solid rgba(255,255,255,0.1)',\r\n            ...styles \r\n          }}>\r\n            <p style={{ fontSize: '1.25rem', fontStyle: 'italic', color: '#fff', marginBottom: '16px', lineHeight: '1.6' }}>\r\n              \"{element.content.quote}\"\r\n            </p>\r\n            <div>\r\n              <div style={{ fontWeight: 'bold', color: '#fff' }}>{element.content.author}</div>\r\n              <div style={{ fontSize: '0.875rem', color: 'rgba(255,255,255,0.7)' }}>\r\n                {element.content.role}{element.content.company ? `, ${element.content.company}` : ''}\r\n              </div>\r\n            </div>\r\n          </div>\r\n        );\r\n      }\r\n      return null;\r\n\r\n    case 'icon-box':\r\n      if (typeof element.content === 'object') {\r\n        return (\r\n          <div style={{ \r\n            padding: '24px', \r\n            backgroundColor: 'rgba(255,255,255,0.05)', \r\n            borderRadius: '12px',\r\n            border: '1px solid rgba(255,255,255,0.1)',\r\n            ...styles \r\n          }}>\r\n            <div style={{ fontSize: '2.5rem', marginBottom: '12px' }}>{element.content.icon}</div>\r\n            <h3 style={{ fontSize: '1.25rem', fontWeight: 'bold', color: '#fff', marginBottom: '8px' }}>{element.content.title}</h3>\r\n            <p style={{ fontSize: '0.9rem', color: 'rgba(255,255,255,0.7)', lineHeight: '1.6' }}>{element.content.text}</p>\r\n          </div>\r\n        );\r\n      }\r\n      return null;\r\n\r\n    case 'counter':\r\n      if (typeof element.content === 'object') {\r\n        return (\r\n          <div style={{ textAlign: 'center', ...styles }}>\r\n            <div style={{ fontSize: '3rem', fontWeight: 'bold', color: theme.primaryColor }}>\r\n              {element.content.number}{element.content.suffix}\r\n            </div>\r\n            <div style={{ fontSize: '1rem', color: 'rgba(255,255,255,0.7)' }}>{element.content.label}</div>\r\n          </div>\r\n        );\r\n      }\r\n      return null;\r\n\r\n    case 'hero':\r\n    case 'cta':\r\n      if (typeof element.content === 'object') {\r\n        return (\r\n          <div style={{ textAlign: 'center', ...styles }}>\r\n            <h2 style={{ fontSize: '2.5rem', fontWeight: 'bold', color: '#fff', marginBottom: '16px' }}>{element.content.title}</h2>\r\n            {element.content.subtitle && (\r\n              <p style={{ fontSize: '1.25rem', color: 'rgba(255,255,255,0.8)', marginBottom: '24px', maxWidth: '600px', margin: '0 auto 24px' }}>\r\n                {element.content.subtitle}\r\n              </p>\r\n            )}\r\n            {element.content.buttonText && (\r\n              <Link\r\n                href={element.content.buttonLink || '/signup'}\r\n                style={{\r\n                  display: 'inline-block',\r\n                  padding: '16px 32px',\r\n                  backgroundColor: theme.primaryColor,\r\n                  color: '#fff',\r\n                  borderRadius: '8px',\r\n                  fontWeight: '600',\r\n                  textDecoration: 'none',\r\n                }}\r\n              >\r\n                {element.content.buttonText}\r\n              </Link>\r\n            )}\r\n          </div>\r\n        );\r\n      }\r\n      return null;\r\n\r\n    default:\r\n      // For unknown types, try to render content as text\r\n      if (typeof element.content === 'string') {\r\n        return <div style={styles}>{element.content}</div>;\r\n      }\r\n      return null;\r\n  }\r\n}\r\n\r\ninterface PageRendererProps {\r\n  page: PageContent;\r\n}\r\n\r\nexport default function PageRenderer({ page }: PageRendererProps) {\r\n  if (!page || !page.sections) {\r\n    return null;\r\n  }\r\n\r\n  return (\r\n    <>\r\n      {page.sections\r\n        .filter(section => section.visible !== false)\r\n        .map(section => (\r\n          <section\r\n            key={section.id}\r\n            style={{\r\n              ...section.styles?.desktop,\r\n            }}\r\n          >\r\n            <div style={{ maxWidth: '1280px', margin: '0 auto' }}>\r\n              {section.children?.map(element => (\r\n                <ElementRenderer key={element.id} element={element} />\r\n              ))}\r\n            </div>\r\n          </section>\r\n        ))}\r\n    </>\r\n  );\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\David\\PycharmProjects\\AI Sales Platform\\src\\components\\ui\\input.tsx","messages":[{"ruleId":"@typescript-eslint/no-empty-object-type","severity":2,"message":"An interface declaring no members is equivalent to its supertype.","line":4,"column":18,"nodeType":"Identifier","messageId":"noEmptyInterfaceWithSuper","endLine":4,"endColumn":28,"suggestions":[{"messageId":"replaceEmptyInterfaceWithSuper","fix":{"range":[75,153],"text":"type InputProps = React.InputHTMLAttributes<HTMLInputElement>"},"desc":"Replace empty interface with a type alias."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import * as React from \"react\"\r\nimport { cn } from \"@/lib/utils\"\r\n\r\nexport interface InputProps\r\n  extends React.InputHTMLAttributes<HTMLInputElement> {}\r\n\r\nconst Input = React.forwardRef<HTMLInputElement, InputProps>(\r\n  ({ className, type, ...props }, ref) => {\r\n    return (\r\n      <input\r\n        type={type}\r\n        className={cn(\r\n          \"flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50\",\r\n          className\r\n        )}\r\n        ref={ref}\r\n        {...props}\r\n      />\r\n    )\r\n  }\r\n)\r\nInput.displayName = \"Input\"\r\n\r\nexport { Input }\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\David\\PycharmProjects\\AI Sales Platform\\src\\components\\ui\\label.tsx","messages":[{"ruleId":"@typescript-eslint/no-empty-object-type","severity":2,"message":"An interface declaring no members is equivalent to its supertype.","line":4,"column":18,"nodeType":"Identifier","messageId":"noEmptyInterfaceWithSuper","endLine":4,"endColumn":28,"suggestions":[{"messageId":"replaceEmptyInterfaceWithSuper","fix":{"range":[75,153],"text":"type LabelProps = React.LabelHTMLAttributes<HTMLLabelElement>"},"desc":"Replace empty interface with a type alias."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import * as React from \"react\"\r\nimport { cn } from \"@/lib/utils\"\r\n\r\nexport interface LabelProps\r\n  extends React.LabelHTMLAttributes<HTMLLabelElement> {}\r\n\r\nconst Label = React.forwardRef<HTMLLabelElement, LabelProps>(\r\n  ({ className, ...props }, ref) => (\r\n    <label\r\n      ref={ref}\r\n      className={cn(\r\n        \"text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70\",\r\n        className\r\n      )}\r\n      {...props}\r\n    />\r\n  )\r\n)\r\nLabel.displayName = \"Label\"\r\n\r\nexport { Label }\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\David\\PycharmProjects\\AI Sales Platform\\src\\components\\ui\\textarea.tsx","messages":[{"ruleId":"@typescript-eslint/no-empty-object-type","severity":2,"message":"An interface declaring no members is equivalent to its supertype.","line":4,"column":18,"nodeType":"Identifier","messageId":"noEmptyInterfaceWithSuper","endLine":4,"endColumn":31,"suggestions":[{"messageId":"replaceEmptyInterfaceWithSuper","fix":{"range":[75,162],"text":"type TextareaProps = React.TextareaHTMLAttributes<HTMLTextAreaElement>"},"desc":"Replace empty interface with a type alias."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import * as React from \"react\"\r\nimport { cn } from \"@/lib/utils\"\r\n\r\nexport interface TextareaProps\r\n  extends React.TextareaHTMLAttributes<HTMLTextAreaElement> {}\r\n\r\nconst Textarea = React.forwardRef<HTMLTextAreaElement, TextareaProps>(\r\n  ({ className, ...props }, ref) => {\r\n    return (\r\n      <textarea\r\n        className={cn(\r\n          \"flex min-h-[80px] w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50\",\r\n          className\r\n        )}\r\n        ref={ref}\r\n        {...props}\r\n      />\r\n    )\r\n  }\r\n)\r\nTextarea.displayName = \"Textarea\"\r\n\r\nexport { Textarea }\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\David\\PycharmProjects\\AI Sales Platform\\src\\components\\website-builder\\ResponsiveRenderer.tsx","messages":[{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":234,"column":7,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":234,"endColumn":44},{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":235,"column":7,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":235,"endColumn":69},{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":352,"column":7,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":352,"endColumn":62},{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":382,"column":7,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":382,"endColumn":56},{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":497,"column":7,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":497,"endColumn":56}],"suppressedMessages":[],"errorCount":5,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Responsive Page Renderer\r\n * Automatically applies mobile-responsive styling to page content\r\n * Handles breakpoints: desktop (1200px+), tablet (768-1199px), mobile (<768px)\r\n */\r\n\r\n'use client';\r\n\r\nimport { PageSection, Widget } from '@/types/website';\r\nimport { OptimizedImage } from './OptimizedImage';\r\nimport { AccessibleWidget, SkipToMain } from './AccessibleWidget';\r\n\r\ninterface ResponsiveRendererProps {\r\n  content: PageSection[];\r\n  breakpoint?: 'desktop' | 'tablet' | 'mobile';\r\n}\r\n\r\nexport function ResponsiveRenderer({ content, breakpoint = 'desktop' }: ResponsiveRendererProps) {\r\n  return (\r\n    <div className=\"responsive-page\" role=\"main\" id=\"main-content\">\r\n      <SkipToMain />\r\n      {content.map((section, idx) => (\r\n        <Section key={section.id || idx} section={section} breakpoint={breakpoint} />\r\n      ))}\r\n\r\n      <style>{`\r\n        .responsive-page {\r\n          width: 100%;\r\n          min-height: 100vh;\r\n        }\r\n\r\n        /* Responsive typography */\r\n        @media (max-width: 767px) {\r\n          h1 { font-size: 28px !important; }\r\n          h2 { font-size: 24px !important; }\r\n          h3 { font-size: 20px !important; }\r\n          h4 { font-size: 18px !important; }\r\n          p { font-size: 16px; line-height: 1.6; }\r\n        }\r\n\r\n        /* Responsive spacing */\r\n        @media (max-width: 767px) {\r\n          .section { padding: 40px 20px !important; }\r\n          .widget { margin-bottom: 20px !important; }\r\n        }\r\n\r\n        /* Responsive images */\r\n        img {\r\n          max-width: 100%;\r\n          height: auto;\r\n        }\r\n\r\n        /* Responsive buttons */\r\n        button, .button {\r\n          min-width: fit-content;\r\n          padding: 12px 24px;\r\n        }\r\n\r\n        @media (max-width: 767px) {\r\n          button, .button {\r\n            width: 100%;\r\n            display: block;\r\n          }\r\n        }\r\n\r\n        /* Responsive grids */\r\n        .feature-grid,\r\n        .pricing-grid,\r\n        .logo-grid {\r\n          display: grid;\r\n          gap: 24px;\r\n        }\r\n\r\n        @media (min-width: 1200px) {\r\n          .feature-grid,\r\n          .pricing-grid {\r\n            grid-template-columns: repeat(3, 1fr);\r\n          }\r\n          .logo-grid {\r\n            grid-template-columns: repeat(4, 1fr);\r\n          }\r\n        }\r\n\r\n        @media (min-width: 768px) and (max-width: 1199px) {\r\n          .feature-grid,\r\n          .pricing-grid,\r\n          .logo-grid {\r\n            grid-template-columns: repeat(2, 1fr);\r\n          }\r\n        }\r\n\r\n        @media (max-width: 767px) {\r\n          .feature-grid,\r\n          .pricing-grid,\r\n          .logo-grid {\r\n            grid-template-columns: 1fr;\r\n          }\r\n        }\r\n\r\n        /* Responsive flexbox */\r\n        .flex-container {\r\n          display: flex;\r\n          gap: 24px;\r\n        }\r\n\r\n        @media (max-width: 767px) {\r\n          .flex-container {\r\n            flex-direction: column;\r\n          }\r\n        }\r\n\r\n        /* Responsive navigation */\r\n        @media (max-width: 767px) {\r\n          .nav-menu {\r\n            display: none;\r\n            position: fixed;\r\n            top: 60px;\r\n            left: 0;\r\n            right: 0;\r\n            background: white;\r\n            padding: 20px;\r\n            box-shadow: 0 4px 6px rgba(0,0,0,0.1);\r\n          }\r\n          \r\n          .nav-menu.open {\r\n            display: block;\r\n          }\r\n\r\n          .hamburger {\r\n            display: block !important;\r\n          }\r\n        }\r\n      `}</style>\r\n    </div>\r\n  );\r\n}\r\n\r\nfunction Section({ section, breakpoint }: { section: PageSection; breakpoint: string }) {\r\n  const getResponsivePadding = () => {\r\n    if (breakpoint === 'mobile') {\r\n      return '40px 20px';\r\n    }\r\n    if (breakpoint === 'tablet') {\r\n      return '60px 40px';\r\n    }\r\n    return section.padding\r\n      ? `${section.padding.top || '80px'} ${section.padding.right || '40px'} ${section.padding.bottom || '80px'} ${section.padding.left || '40px'}`\r\n      : '80px 40px';\r\n  };\r\n\r\n  const sectionStyle: React.CSSProperties = {\r\n    backgroundColor: section.backgroundColor || 'transparent',\r\n    backgroundImage: section.backgroundImage ? `url(${section.backgroundImage})` : undefined,\r\n    backgroundSize: 'cover',\r\n    backgroundPosition: 'center',\r\n    padding: getResponsivePadding(),\r\n    maxWidth: section.fullWidth ? '100%' : section.maxWidth || '1200px',\r\n    margin: '0 auto',\r\n    width: '100%',\r\n  };\r\n\r\n  return (\r\n    <section className=\"section\" style={sectionStyle}>\r\n      <div className={section.columns.length > 1 ? 'flex-container' : ''}>\r\n        {section.columns.map((column, idx) => (\r\n          <div\r\n            key={column.id || idx}\r\n            style={{\r\n              flex: section.columns.length > 1 ? `${column.width}` : undefined,\r\n              width: section.columns.length === 1 ? '100%' : undefined,\r\n            }}\r\n          >\r\n            {column.widgets.map((widget, widgetIdx) => (\r\n              <AccessibleWidget key={widget.id || widgetIdx} widget={widget}>\r\n                <div className=\"widget\">\r\n                  <WidgetRenderer widget={widget} breakpoint={breakpoint} />\r\n                </div>\r\n              </AccessibleWidget>\r\n            ))}\r\n          </div>\r\n        ))}\r\n      </div>\r\n    </section>\r\n  );\r\n}\r\n\r\nfunction WidgetRenderer({ widget, breakpoint }: { widget: Widget; breakpoint: string }) {\r\n  const convertSpacing = (spacing?: any): string => {\r\n    if (!spacing) return '0';\r\n    if (typeof spacing === 'string') return spacing;\r\n    return `${spacing.top || 0} ${spacing.right || 0} ${spacing.bottom || 0} ${spacing.left || 0}`;\r\n  };\r\n\r\n  const getResponsiveStyle = (): React.CSSProperties => {\r\n    const baseStyle: any = { ...(widget.style || {}) };\r\n    \r\n    // Convert Spacing objects to CSS strings\r\n    if (baseStyle.padding && typeof baseStyle.padding === 'object') {\r\n      baseStyle.padding = convertSpacing(baseStyle.padding);\r\n    }\r\n    if (baseStyle.margin && typeof baseStyle.margin === 'object') {\r\n      baseStyle.margin = convertSpacing(baseStyle.margin);\r\n    }\r\n    \r\n    // Apply responsive overrides\r\n    if (breakpoint === 'mobile' && widget.responsive?.mobile) {\r\n      const mobileStyle: any = { ...widget.responsive.mobile };\r\n      if (mobileStyle.padding && typeof mobileStyle.padding === 'object') {\r\n        mobileStyle.padding = convertSpacing(mobileStyle.padding);\r\n      }\r\n      if (mobileStyle.margin && typeof mobileStyle.margin === 'object') {\r\n        mobileStyle.margin = convertSpacing(mobileStyle.margin);\r\n      }\r\n      return { ...baseStyle, ...mobileStyle };\r\n    }\r\n    if (breakpoint === 'tablet' && widget.responsive?.tablet) {\r\n      const tabletStyle: any = { ...widget.responsive.tablet };\r\n      if (tabletStyle.padding && typeof tabletStyle.padding === 'object') {\r\n        tabletStyle.padding = convertSpacing(tabletStyle.padding);\r\n      }\r\n      if (tabletStyle.margin && typeof tabletStyle.margin === 'object') {\r\n        tabletStyle.margin = convertSpacing(tabletStyle.margin);\r\n      }\r\n      return { ...baseStyle, ...tabletStyle };\r\n    }\r\n    \r\n    return baseStyle;\r\n  };\r\n\r\n  const style = getResponsiveStyle();\r\n\r\n  switch (widget.type) {\r\n    case 'heading':\r\n      const level = widget.data.level || 1;\r\n      const HeadingTag = `h${level}` as keyof JSX.IntrinsicElements;\r\n      return (\r\n        <HeadingTag style={style}>\r\n          {String(widget.data.text || 'Heading')}\r\n        </HeadingTag>\r\n      );\r\n\r\n    case 'text':\r\n      return (\r\n        <p style={style}>\r\n          {String(widget.data.content || 'Text content')}\r\n        </p>\r\n      );\r\n\r\n    case 'button':\r\n      return (\r\n        <button\r\n          style={{\r\n            padding: '12px 24px',\r\n            backgroundColor: (widget.data.color as string) || '#3b82f6',\r\n            color: 'white',\r\n            border: 'none',\r\n            borderRadius: '6px',\r\n            fontSize: '16px',\r\n            fontWeight: '500',\r\n            cursor: 'pointer',\r\n            ...style,\r\n          }}\r\n          onClick={() => {\r\n            if (widget.data.url) {\r\n              window.location.href = widget.data.url as string;\r\n            }\r\n          }}\r\n        >\r\n          {String(widget.data.text || 'Button')}\r\n        </button>\r\n      );\r\n\r\n    case 'image':\r\n      return (\r\n        <OptimizedImage\r\n          src={(widget.data.src as string) || 'https://via.placeholder.com/800x400'}\r\n          alt={(widget.data.alt as string) || 'Image'}\r\n          style={{\r\n            width: '100%',\r\n            height: 'auto',\r\n            borderRadius: '8px',\r\n            ...style,\r\n          }}\r\n          sizes={{\r\n            mobile: '100vw',\r\n            tablet: '50vw',\r\n            desktop: '33vw',\r\n          }}\r\n        />\r\n      );\r\n\r\n    case 'hero':\r\n      return (\r\n        <div\r\n          style={{\r\n            textAlign: 'center',\r\n            padding: breakpoint === 'mobile' ? '40px 20px' : '80px 40px',\r\n            backgroundImage: widget.data.backgroundImage\r\n              ? `linear-gradient(rgba(0,0,0,0.4), rgba(0,0,0,0.4)), url(${widget.data.backgroundImage})`\r\n              : undefined,\r\n            backgroundSize: 'cover',\r\n            backgroundPosition: 'center',\r\n            color: 'white',\r\n            borderRadius: '8px',\r\n            ...style,\r\n          }}\r\n        >\r\n          <h1\r\n            style={{\r\n              fontSize: breakpoint === 'mobile' ? '32px' : '48px',\r\n              fontWeight: 'bold',\r\n              marginBottom: '16px',\r\n            }}\r\n          >\r\n            {String(widget.data.heading || 'Hero Heading')}\r\n          </h1>\r\n          <p\r\n            style={{\r\n              fontSize: breakpoint === 'mobile' ? '16px' : '20px',\r\n              marginBottom: '32px',\r\n              maxWidth: '600px',\r\n              margin: '0 auto 32px',\r\n            }}\r\n          >\r\n            {String(widget.data.subheading || 'Hero subheading')}\r\n          </p>\r\n          {(widget.data.buttonText as string) && (\r\n            <button\r\n              style={{\r\n                padding: '16px 32px',\r\n                backgroundColor: '#3b82f6',\r\n                color: 'white',\r\n                border: 'none',\r\n                borderRadius: '6px',\r\n                fontSize: '18px',\r\n                fontWeight: '600',\r\n                cursor: 'pointer',\r\n              }}\r\n              onClick={() => {\r\n                if (widget.data.buttonUrl) {\r\n                  window.location.href = String(widget.data.buttonUrl);\r\n                }\r\n              }}\r\n            >\r\n              {String(widget.data.buttonText)}\r\n            </button>\r\n          )}\r\n        </div>\r\n      );\r\n\r\n    case 'features':\r\n      const features = (widget.data.features as any[]) || [];\r\n      return (\r\n        <div className=\"feature-grid\">\r\n          {features.map((feature: any, idx: number) => (\r\n            <div\r\n              key={idx}\r\n              style={{\r\n                padding: '24px',\r\n                backgroundColor: '#f9fafb',\r\n                borderRadius: '8px',\r\n                textAlign: 'center',\r\n              }}\r\n            >\r\n              {feature.icon && (\r\n                <div style={{ fontSize: '48px', marginBottom: '16px' }}>\r\n                  {feature.icon}\r\n                </div>\r\n              )}\r\n              <h3 style={{ fontSize: '20px', fontWeight: '600', marginBottom: '12px' }}>\r\n                {feature.title}\r\n              </h3>\r\n              <p style={{ color: '#6b7280', fontSize: '14px' }}>\r\n                {feature.description}\r\n              </p>\r\n            </div>\r\n          ))}\r\n        </div>\r\n      );\r\n\r\n    case 'pricing':\r\n      const plans = (widget.data.plans as any[]) || [];\r\n      return (\r\n        <div className=\"pricing-grid\">\r\n          {plans.map((plan: any, idx: number) => (\r\n            <div\r\n              key={idx}\r\n              style={{\r\n                padding: '32px',\r\n                backgroundColor: 'white',\r\n                border: '2px solid #e5e7eb',\r\n                borderRadius: '8px',\r\n                textAlign: 'center',\r\n              }}\r\n            >\r\n              <h3 style={{ fontSize: '24px', fontWeight: '600', marginBottom: '16px' }}>\r\n                {plan.name}\r\n              </h3>\r\n              <div style={{ fontSize: '48px', fontWeight: 'bold', marginBottom: '24px' }}>\r\n                ${plan.price}\r\n                <span style={{ fontSize: '16px', fontWeight: 'normal', color: '#6b7280' }}>\r\n                  /month\r\n                </span>\r\n              </div>\r\n              <button\r\n                style={{\r\n                  width: '100%',\r\n                  padding: '12px',\r\n                  backgroundColor: plan.featured ? '#3b82f6' : 'white',\r\n                  color: plan.featured ? 'white' : '#374151',\r\n                  border: plan.featured ? 'none' : '1px solid #d1d5db',\r\n                  borderRadius: '6px',\r\n                  fontSize: '16px',\r\n                  fontWeight: '500',\r\n                  cursor: 'pointer',\r\n                }}\r\n              >\r\n                Choose Plan\r\n              </button>\r\n            </div>\r\n          ))}\r\n        </div>\r\n      );\r\n\r\n    case 'testimonial':\r\n      return (\r\n        <div\r\n          style={{\r\n            padding: '32px',\r\n            backgroundColor: '#f9fafb',\r\n            borderRadius: '8px',\r\n            textAlign: 'center',\r\n            ...style,\r\n          }}\r\n        >\r\n          <p\r\n            style={{\r\n              fontSize: '18px',\r\n              fontStyle: 'italic',\r\n              color: '#374151',\r\n              marginBottom: '16px',\r\n            }}\r\n          >\r\n            \"{String(widget.data.quote || 'Testimonial quote')}\"\r\n          </p>\r\n          <div style={{ fontWeight: '600', color: '#111827' }}>\r\n            {String(widget.data.author || 'Author Name')}\r\n          </div>\r\n          <div style={{ fontSize: '14px', color: '#6b7280' }}>\r\n            {String(widget.data.role || 'Role / Company')}\r\n          </div>\r\n        </div>\r\n      );\r\n\r\n    case 'cta':\r\n      return (\r\n        <div\r\n          style={{\r\n            textAlign: 'center',\r\n            padding: breakpoint === 'mobile' ? '40px 20px' : '60px 40px',\r\n            backgroundColor: '#3b82f6',\r\n            borderRadius: '8px',\r\n            color: 'white',\r\n            ...style,\r\n          }}\r\n        >\r\n          <h2\r\n            style={{\r\n              fontSize: breakpoint === 'mobile' ? '24px' : '32px',\r\n              fontWeight: 'bold',\r\n              marginBottom: '16px',\r\n            }}\r\n          >\r\n            {String(widget.data.heading || 'Ready to get started?')}\r\n          </h2>\r\n          <p style={{ fontSize: '18px', marginBottom: '24px' }}>\r\n            {String(widget.data.text || 'Join thousands of satisfied customers')}\r\n          </p>\r\n          <button\r\n            style={{\r\n              padding: '16px 32px',\r\n              backgroundColor: 'white',\r\n              color: '#3b82f6',\r\n              border: 'none',\r\n              borderRadius: '6px',\r\n              fontSize: '16px',\r\n              fontWeight: '600',\r\n              cursor: 'pointer',\r\n            }}\r\n          >\r\n            {String(widget.data.buttonText || 'Get Started')}\r\n          </button>\r\n        </div>\r\n      );\r\n\r\n    case 'logo-grid':\r\n      const logos = (widget.data.logos as any[]) || [];\r\n      return (\r\n        <div className=\"logo-grid\">\r\n          {logos.map((logo: any, idx: number) => (\r\n            <div\r\n              key={idx}\r\n              style={{\r\n                display: 'flex',\r\n                alignItems: 'center',\r\n                justifyContent: 'center',\r\n                padding: '20px',\r\n                backgroundColor: '#f9fafb',\r\n                borderRadius: '8px',\r\n              }}\r\n            >\r\n              <img\r\n                src={logo.src}\r\n                alt={logo.alt}\r\n                style={{\r\n                  maxWidth: '120px',\r\n                  maxHeight: '60px',\r\n                  opacity: 0.7,\r\n                }}\r\n              />\r\n            </div>\r\n          ))}\r\n        </div>\r\n      );\r\n\r\n    default:\r\n      return (\r\n        <div\r\n          style={{\r\n            padding: '16px',\r\n            backgroundColor: '#f3f4f6',\r\n            borderRadius: '6px',\r\n            color: '#6b7280',\r\n            ...style,\r\n          }}\r\n        >\r\n          {widget.type} widget\r\n        </div>\r\n      );\r\n  }\r\n}\r\n\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\David\\PycharmProjects\\AI Sales Platform\\src\\components\\website-builder\\WidgetRenderer.tsx","messages":[{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":20,"column":7,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":20,"endColumn":83},{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":445,"column":7,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":445,"endColumn":94},{"ruleId":"no-duplicate-case","severity":2,"message":"Duplicate case label.","line":473,"column":5,"nodeType":"SwitchCase","messageId":"unexpected","endLine":508,"endColumn":9},{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":474,"column":7,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":474,"endColumn":112}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Widget Renderer\r\n * Renders each widget type based on its data and style\r\n */\r\n\r\n'use client';\r\n\r\nimport { Widget, WidgetStyle, Spacing } from '@/types/website';\r\n\r\ninterface WidgetRendererProps {\r\n  widget: Widget;\r\n  isEditable?: boolean;\r\n}\r\n\r\nexport default function WidgetRenderer({ widget, isEditable = false }: WidgetRendererProps) {\r\n  const style = convertWidgetStyleToCSS(widget.style);\r\n\r\n  switch (widget.type) {\r\n    case 'heading':\r\n      const HeadingTag = (widget.data.tag || 'h2') as keyof JSX.IntrinsicElements;\r\n      return <HeadingTag style={style}>{String(widget.data.text || 'Heading')}</HeadingTag>;\r\n\r\n    case 'text':\r\n      return <p style={style}>{String(widget.data.content || 'Text content')}</p>;\r\n\r\n    case 'button':\r\n      return (\r\n        <a \r\n          href={(widget.data.url as string) || '#'} \r\n          target={widget.data.openInNewTab ? '_blank' : undefined}\r\n          rel={widget.data.openInNewTab ? 'noopener noreferrer' : undefined}\r\n          style={{ ...style, display: 'inline-block', textDecoration: 'none' }}\r\n        >\r\n          {String(widget.data.text || 'Button')}\r\n        </a>\r\n      );\r\n\r\n    case 'link':\r\n      return (\r\n        <a \r\n          href={(widget.data.url as string) || '#'}\r\n          target={widget.data.openInNewTab ? '_blank' : undefined}\r\n          rel={widget.data.openInNewTab ? 'noopener noreferrer' : undefined}\r\n          style={style}\r\n        >\r\n          {String(widget.data.text || 'Link')}\r\n        </a>\r\n      );\r\n\r\n    case 'image':\r\n      return (\r\n        <div style={style}>\r\n          <img \r\n            src={(widget.data.src as string) || 'https://via.placeholder.com/800x400'} \r\n            alt={(widget.data.alt as string) || ''}\r\n            style={{ width: '100%', height: 'auto', display: 'block' }}\r\n          />\r\n          {(widget.data.caption as string) && (\r\n            <p style={{ \r\n              fontSize: '0.875rem', \r\n              color: '#6c757d', \r\n              marginTop: '0.5rem',\r\n              textAlign: 'center',\r\n            }}>\r\n              {String(widget.data.caption)}\r\n            </p>\r\n          )}\r\n        </div>\r\n      );\r\n\r\n    case 'video':\r\n      return (\r\n        <div style={style}>\r\n          <div style={{ \r\n            position: 'relative', \r\n            paddingBottom: '56.25%', \r\n            height: 0,\r\n            overflow: 'hidden',\r\n          }}>\r\n            <iframe\r\n              src={getVideoEmbedUrl(widget.data.url as string, widget.data.provider as string)}\r\n              style={{\r\n                position: 'absolute',\r\n                top: 0,\r\n                left: 0,\r\n                width: '100%',\r\n                height: '100%',\r\n                border: 'none',\r\n              }}\r\n              allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\"\r\n              allowFullScreen\r\n            />\r\n          </div>\r\n        </div>\r\n      );\r\n\r\n    case 'spacer':\r\n      return <div style={{ height: (widget.data.height as string) || '2rem', ...style }} />;\r\n\r\n    case 'divider':\r\n      return (\r\n        <hr style={{\r\n          border: 'none',\r\n          height: (widget.data.thickness as string) || '1px',\r\n          backgroundColor: (widget.data.color as string) || '#dee2e6',\r\n          ...style,\r\n        }} />\r\n      );\r\n\r\n    case 'hero':\r\n      return (\r\n        <div style={{\r\n          ...style,\r\n          backgroundImage: widget.data.backgroundImage ? `url(${widget.data.backgroundImage})` : undefined,\r\n          backgroundSize: 'cover',\r\n          backgroundPosition: 'center',\r\n        }}>\r\n          <h1 style={{ fontSize: '3rem', fontWeight: '700', marginBottom: '1rem' }}>\r\n            {String(widget.data.heading || 'Welcome')}\r\n          </h1>\r\n          {(widget.data.subheading as string) && (\r\n            <p style={{ fontSize: '1.25rem', marginBottom: '2rem' }}>\r\n              {String(widget.data.subheading)}\r\n            </p>\r\n          )}\r\n          {(widget.data.buttonText as string) && (\r\n            <a \r\n              href={(widget.data.buttonUrl as string) || '#'}\r\n              style={{\r\n                display: 'inline-block',\r\n                padding: '1rem 2rem',\r\n                background: '#007bff',\r\n                color: 'white',\r\n                textDecoration: 'none',\r\n                borderRadius: '4px',\r\n                fontSize: '1.125rem',\r\n                fontWeight: '600',\r\n              }}\r\n            >\r\n              {String(widget.data.buttonText)}\r\n            </a>\r\n          )}\r\n        </div>\r\n      );\r\n\r\n    case 'features':\r\n      return (\r\n        <div style={{\r\n          ...style,\r\n          display: 'grid',\r\n          gridTemplateColumns: 'repeat(auto-fit, minmax(250px, 1fr))',\r\n          gap: '2rem',\r\n        }}>\r\n          {((widget.data.features as any[]) || []).map((feature: any, i: number) => (\r\n            <div key={i} style={{ textAlign: 'center' }}>\r\n              <div style={{ fontSize: '3rem', marginBottom: '1rem' }}>{feature.icon}</div>\r\n              <h3 style={{ fontSize: '1.25rem', marginBottom: '0.5rem' }}>{feature.title}</h3>\r\n              <p style={{ color: '#6c757d' }}>{feature.description}</p>\r\n            </div>\r\n          ))}\r\n        </div>\r\n      );\r\n\r\n    case 'pricing':\r\n      return (\r\n        <div style={{\r\n          ...style,\r\n          display: 'grid',\r\n          gridTemplateColumns: 'repeat(auto-fit, minmax(280px, 1fr))',\r\n          gap: '2rem',\r\n        }}>\r\n          {((widget.data.plans as any[]) || []).map((plan: any, i: number) => (\r\n            <div \r\n              key={i} \r\n              style={{\r\n                padding: '2rem',\r\n                background: plan.featured ? '#007bff' : 'white',\r\n                color: plan.featured ? 'white' : '#212529',\r\n                border: plan.featured ? 'none' : '1px solid #dee2e6',\r\n                borderRadius: '8px',\r\n                textAlign: 'center',\r\n              }}\r\n            >\r\n              <h3 style={{ fontSize: '1.5rem', marginBottom: '1rem' }}>{plan.name}</h3>\r\n              <div style={{ fontSize: '3rem', fontWeight: '700', marginBottom: '1rem' }}>\r\n                {plan.price}\r\n                <span style={{ fontSize: '1rem', fontWeight: '400' }}>/{plan.period}</span>\r\n              </div>\r\n              <ul style={{ \r\n                listStyle: 'none', \r\n                padding: 0, \r\n                marginBottom: '2rem',\r\n                textAlign: 'left',\r\n              }}>\r\n                {plan.features.map((feature: string, j: number) => (\r\n                  <li key={j} style={{ padding: '0.5rem 0' }}>Γ£ô {feature}</li>\r\n                ))}\r\n              </ul>\r\n              <a \r\n                href={plan.buttonUrl || '#'}\r\n                style={{\r\n                  display: 'inline-block',\r\n                  padding: '0.75rem 1.5rem',\r\n                  background: plan.featured ? 'white' : '#007bff',\r\n                  color: plan.featured ? '#007bff' : 'white',\r\n                  textDecoration: 'none',\r\n                  borderRadius: '4px',\r\n                  fontWeight: '600',\r\n                }}\r\n              >\r\n                {plan.buttonText}\r\n              </a>\r\n            </div>\r\n          ))}\r\n        </div>\r\n      );\r\n\r\n    case 'testimonial':\r\n      return (\r\n        <div style={style}>\r\n          <p style={{ \r\n            fontSize: '1.125rem', \r\n            fontStyle: 'italic', \r\n            marginBottom: '1.5rem',\r\n            lineHeight: '1.6',\r\n          }}>\r\n            \"{String(widget.data.quote)}\"\r\n          </p>\r\n          <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'center', gap: '1rem' }}>\r\n            {(widget.data.avatar as string) && (\r\n              <img \r\n                src={widget.data.avatar as string} \r\n                alt={(widget.data.author as string) || ''}\r\n                style={{ \r\n                  width: '60px', \r\n                  height: '60px', \r\n                  borderRadius: '50%',\r\n                  objectFit: 'cover',\r\n                }}\r\n              />\r\n            )}\r\n            <div>\r\n              <div style={{ fontWeight: '600' }}>{String(widget.data.author)}</div>\r\n              <div style={{ fontSize: '0.875rem', color: '#6c757d' }}>{String(widget.data.role)}</div>\r\n            </div>\r\n          </div>\r\n        </div>\r\n      );\r\n\r\n    case 'cta':\r\n      return (\r\n        <div style={style}>\r\n          <h2 style={{ fontSize: '2rem', marginBottom: '0.5rem' }}>{String(widget.data.heading)}</h2>\r\n          {(widget.data.subheading as string) && (\r\n            <p style={{ fontSize: '1.125rem', marginBottom: '1.5rem' }}>{String(widget.data.subheading)}</p>\r\n          )}\r\n          <a \r\n            href={(widget.data.buttonUrl as string) || '#'}\r\n            style={{\r\n              display: 'inline-block',\r\n              padding: '1rem 2rem',\r\n              background: 'white',\r\n              color: '#007bff',\r\n              textDecoration: 'none',\r\n              borderRadius: '4px',\r\n              fontSize: '1.125rem',\r\n              fontWeight: '600',\r\n            }}\r\n          >\r\n            {String(widget.data.buttonText)}\r\n          </a>\r\n        </div>\r\n      );\r\n\r\n    case 'stats':\r\n      return (\r\n        <div style={{\r\n          ...style,\r\n          display: 'grid',\r\n          gridTemplateColumns: 'repeat(auto-fit, minmax(200px, 1fr))',\r\n          gap: '2rem',\r\n        }}>\r\n          {((widget.data.stats as any[]) || []).map((stat: any, i: number) => (\r\n            <div key={i} style={{ textAlign: 'center' }}>\r\n              <div style={{ fontSize: '3rem', fontWeight: '700', color: '#007bff', marginBottom: '0.5rem' }}>\r\n                {stat.number}\r\n              </div>\r\n              <div style={{ fontSize: '1.125rem', color: '#6c757d' }}>{stat.label}</div>\r\n            </div>\r\n          ))}\r\n        </div>\r\n      );\r\n\r\n    case 'gallery':\r\n      return (\r\n        <div style={{\r\n          ...style,\r\n          display: 'grid',\r\n          gridTemplateColumns: `repeat(${(widget.data.columns as number) || 3}, 1fr)`,\r\n          gap: (widget.data.gap as string) || '1rem',\r\n        }}>\r\n          {((widget.data.images as any[]) || []).map((img: any, i: number) => (\r\n            <img \r\n              key={i}\r\n              src={img.src} \r\n              alt={img.alt}\r\n              style={{ \r\n                width: '100%', \r\n                height: '250px',\r\n                objectFit: 'cover',\r\n                borderRadius: '4px',\r\n              }}\r\n            />\r\n          ))}\r\n        </div>\r\n      );\r\n\r\n    case 'contact-form':\r\n      return (\r\n        <form style={style} onSubmit={(e) => e.preventDefault()}>\r\n          <div style={{ marginBottom: '1rem' }}>\r\n            <label style={{ display: 'block', marginBottom: '0.5rem', fontWeight: '500' }}>Name</label>\r\n            <input type=\"text\" style={inputStyle} placeholder=\"Your name\" />\r\n          </div>\r\n          <div style={{ marginBottom: '1rem' }}>\r\n            <label style={{ display: 'block', marginBottom: '0.5rem', fontWeight: '500' }}>Email</label>\r\n            <input type=\"email\" style={inputStyle} placeholder=\"your@email.com\" />\r\n          </div>\r\n          <div style={{ marginBottom: '1rem' }}>\r\n            <label style={{ display: 'block', marginBottom: '0.5rem', fontWeight: '500' }}>Message</label>\r\n            <textarea rows={4} style={{ ...inputStyle, resize: 'vertical' }} placeholder=\"Your message\" />\r\n          </div>\r\n          <button type=\"submit\" style={buttonStyle}>\r\n            {String(widget.data.submitText || 'Send Message')}\r\n          </button>\r\n        </form>\r\n      );\r\n\r\n    case 'newsletter':\r\n      return (\r\n        <div style={style}>\r\n          <h3 style={{ marginBottom: '1rem' }}>{String(widget.data.heading)}</h3>\r\n          <form style={{ display: 'flex', gap: '0.5rem' }} onSubmit={(e) => e.preventDefault()}>\r\n            <input \r\n              type=\"email\" \r\n              placeholder={(widget.data.placeholder as string) || 'Enter your email'}\r\n              style={{ ...inputStyle, flex: 1 }}\r\n            />\r\n            <button type=\"submit\" style={buttonStyle}>\r\n              {String(widget.data.buttonText || 'Subscribe')}\r\n            </button>\r\n          </form>\r\n        </div>\r\n      );\r\n\r\n    case 'social-icons':\r\n      return (\r\n        <div style={{ ...style, display: 'flex', gap: '1rem' }}>\r\n          {((widget.data.icons as any[]) || []).map((icon: any, i: number) => (\r\n            <a \r\n              key={i}\r\n              href={icon.url}\r\n              target=\"_blank\"\r\n              rel=\"noopener noreferrer\"\r\n              style={{\r\n                width: '40px',\r\n                height: '40px',\r\n                display: 'flex',\r\n                alignItems: 'center',\r\n                justifyContent: 'center',\r\n                background: '#007bff',\r\n                color: 'white',\r\n                borderRadius: '50%',\r\n                textDecoration: 'none',\r\n                fontSize: '1.25rem',\r\n              }}\r\n            >\r\n              {getSocialIcon(icon.platform)}\r\n            </a>\r\n          ))}\r\n        </div>\r\n      );\r\n\r\n    case 'accordion':\r\n      return (\r\n        <div style={style}>\r\n          {((widget.data.items as any[]) || []).map((item: any, i: number) => (\r\n            <details key={i} style={{ \r\n              marginBottom: '0.5rem',\r\n              border: '1px solid #dee2e6',\r\n              borderRadius: '4px',\r\n              padding: '1rem',\r\n            }}>\r\n              <summary style={{ fontWeight: '600', cursor: 'pointer' }}>\r\n                {item.title}\r\n              </summary>\r\n              <p style={{ marginTop: '0.75rem', color: '#6c757d' }}>\r\n                {item.content}\r\n              </p>\r\n            </details>\r\n          ))}\r\n        </div>\r\n      );\r\n\r\n    case 'icon-box':\r\n      return (\r\n        <div style={style}>\r\n          <div style={{ fontSize: '3rem', marginBottom: '1rem' }}>{String(widget.data.icon)}</div>\r\n          <h3 style={{ fontSize: '1.25rem', marginBottom: '0.5rem' }}>{String(widget.data.title)}</h3>\r\n          <p style={{ color: '#6c757d' }}>{String(widget.data.description)}</p>\r\n        </div>\r\n      );\r\n\r\n    case 'html':\r\n      return <div style={style} dangerouslySetInnerHTML={{ __html: widget.data.html || '' }} />;\r\n\r\n    case 'code':\r\n      return (\r\n        <pre style={style}>\r\n          <code>{String(widget.data.code || '')}</code>\r\n        </pre>\r\n      );\r\n\r\n    case 'modal':\r\n      return (\r\n        <div style={style}>\r\n          <button\r\n            style={{\r\n              padding: '12px 24px',\r\n              background: (widget.data.buttonColor as string) || '#007bff',\r\n              color: 'white',\r\n              border: 'none',\r\n              borderRadius: '6px',\r\n              cursor: 'pointer',\r\n              fontSize: '16px',\r\n              fontWeight: '500',\r\n            }}\r\n          >\r\n            {String(widget.data.buttonText || 'Open Modal')}\r\n          </button>\r\n        </div>\r\n      );\r\n\r\n    case 'tabs':\r\n      const tabs = (widget.data.tabs as any[]) || [{ title: 'Tab 1', content: 'Content 1' }];\r\n      return (\r\n        <div style={style}>\r\n          <div style={{ borderBottom: '2px solid #dee2e6', display: 'flex' }}>\r\n            {tabs.map((tab: any, index: number) => (\r\n              <button\r\n                key={index}\r\n                style={{\r\n                  padding: '12px 24px',\r\n                  background: index === 0 ? '#007bff' : 'transparent',\r\n                  color: index === 0 ? 'white' : '#495057',\r\n                  border: 'none',\r\n                  cursor: 'pointer',\r\n                  fontSize: '14px',\r\n                  fontWeight: '500',\r\n                  borderBottom: index === 0 ? '2px solid #007bff' : 'none',\r\n                }}\r\n              >\r\n                {tab.title}\r\n              </button>\r\n            ))}\r\n          </div>\r\n          <div style={{ padding: '20px', background: 'white' }}>\r\n            {tabs[0]?.content || 'Tab content'}\r\n          </div>\r\n        </div>\r\n      );\r\n\r\n    case 'accordion':\r\n      const accordionItems = (widget.data.items as any[]) || [{ title: 'Accordion Item', content: 'Content' }];\r\n      return (\r\n        <div style={style}>\r\n          {accordionItems.map((item: any, index: number) => (\r\n            <div\r\n              key={index}\r\n              style={{\r\n                border: '1px solid #dee2e6',\r\n                borderRadius: '6px',\r\n                marginBottom: '8px',\r\n                overflow: 'hidden',\r\n              }}\r\n            >\r\n              <div\r\n                style={{\r\n                  padding: '16px',\r\n                  background: '#f8f9fa',\r\n                  fontSize: '16px',\r\n                  fontWeight: '500',\r\n                  cursor: 'pointer',\r\n                  display: 'flex',\r\n                  justifyContent: 'space-between',\r\n                  alignItems: 'center',\r\n                }}\r\n              >\r\n                {item.title}\r\n                <span style={{ fontSize: '12px' }}>Γû╝</span>\r\n              </div>\r\n              <div style={{ padding: '16px', background: 'white', borderTop: '1px solid #dee2e6' }}>\r\n                {item.content}\r\n              </div>\r\n            </div>\r\n          ))}\r\n        </div>\r\n      );\r\n\r\n    default:\r\n      return (\r\n        <div style={{\r\n          ...style,\r\n          padding: '1rem',\r\n          background: '#f8f9fa',\r\n          border: '1px dashed #dee2e6',\r\n          borderRadius: '4px',\r\n          textAlign: 'center',\r\n          color: '#6c757d',\r\n        }}>\r\n          {widget.type} widget\r\n        </div>\r\n      );\r\n  }\r\n}\r\n\r\n// Helper functions\r\nfunction convertWidgetStyleToCSS(widgetStyle?: WidgetStyle): React.CSSProperties {\r\n  if (!widgetStyle) return {};\r\n\r\n  return {\r\n    padding: widgetStyle.padding ? convertSpacingToCSS(widgetStyle.padding) : undefined,\r\n    margin: widgetStyle.margin ? convertSpacingToCSS(widgetStyle.margin) : undefined,\r\n    width: widgetStyle.width,\r\n    height: widgetStyle.height,\r\n    display: widgetStyle.display,\r\n    flexDirection: widgetStyle.flexDirection,\r\n    alignItems: widgetStyle.alignItems,\r\n    justifyContent: widgetStyle.justifyContent,\r\n    fontFamily: widgetStyle.fontFamily,\r\n    fontSize: widgetStyle.fontSize,\r\n    fontWeight: widgetStyle.fontWeight,\r\n    lineHeight: widgetStyle.lineHeight,\r\n    letterSpacing: widgetStyle.letterSpacing,\r\n    textAlign: widgetStyle.textAlign,\r\n    textTransform: widgetStyle.textTransform,\r\n    color: widgetStyle.color,\r\n    backgroundColor: widgetStyle.backgroundColor,\r\n    border: widgetStyle.border,\r\n    borderRadius: widgetStyle.borderRadius,\r\n    borderWidth: widgetStyle.borderWidth,\r\n    borderColor: widgetStyle.borderColor,\r\n    borderStyle: widgetStyle.borderStyle,\r\n    boxShadow: widgetStyle.boxShadow,\r\n    opacity: widgetStyle.opacity,\r\n    transform: widgetStyle.transform,\r\n    transition: widgetStyle.transition,\r\n    backgroundImage: widgetStyle.backgroundImage,\r\n    backgroundSize: widgetStyle.backgroundSize,\r\n    backgroundPosition: widgetStyle.backgroundPosition,\r\n    backgroundRepeat: widgetStyle.backgroundRepeat,\r\n  };\r\n}\r\n\r\nfunction convertSpacingToCSS(spacing: Spacing): string {\r\n  const top = spacing.top || '0';\r\n  const right = spacing.right || spacing.top || '0';\r\n  const bottom = spacing.bottom || spacing.top || '0';\r\n  const left = spacing.left || spacing.right || spacing.top || '0';\r\n  return `${top} ${right} ${bottom} ${left}`;\r\n}\r\n\r\nfunction getVideoEmbedUrl(url: string, provider: string): string {\r\n  if (!url) return '';\r\n  \r\n  if (provider === 'youtube') {\r\n    const videoId = url.match(/(?:youtube\\.com\\/watch\\?v=|youtu\\.be\\/)([^&]+)/)?.[1];\r\n    return videoId ? `https://www.youtube.com/embed/${videoId}` : '';\r\n  } else if (provider === 'vimeo') {\r\n    const videoId = url.match(/vimeo\\.com\\/(\\d+)/)?.[1];\r\n    return videoId ? `https://player.vimeo.com/video/${videoId}` : '';\r\n  }\r\n  \r\n  return url;\r\n}\r\n\r\nfunction getSocialIcon(platform: string): string {\r\n  const icons: Record<string, string> = {\r\n    facebook: 'f',\r\n    twitter: '≡¥òÅ',\r\n    instagram: '≡ƒô╖',\r\n    linkedin: 'in',\r\n    youtube: 'Γû╢∩╕Å',\r\n    github: '≡ƒÉÖ',\r\n  };\r\n  return icons[platform] || 'ΓÇó';\r\n}\r\n\r\n// Common styles\r\nconst inputStyle: React.CSSProperties = {\r\n  width: '100%',\r\n  padding: '0.75rem',\r\n  border: '1px solid #ced4da',\r\n  borderRadius: '4px',\r\n  fontSize: '1rem',\r\n};\r\n\r\nconst buttonStyle: React.CSSProperties = {\r\n  padding: '0.75rem 1.5rem',\r\n  background: '#007bff',\r\n  color: 'white',\r\n  border: 'none',\r\n  borderRadius: '4px',\r\n  cursor: 'pointer',\r\n  fontSize: '1rem',\r\n  fontWeight: '500',\r\n};\r\n\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\David\\PycharmProjects\\AI Sales Platform\\src\\lib\\analytics\\dashboard\\analytics-engine.ts","messages":[{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":906,"column":7,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":906,"endColumn":54}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Advanced Analytics Engine\r\n * \r\n * SOVEREIGN CORPORATE BRAIN - ANALYTICS MODULE\r\n * \r\n * This service aggregates data from all platform features to provide\r\n * comprehensive analytics and insights.\r\n * \r\n * FEATURES:\r\n * - Multi-source data aggregation (workflows, emails, deals, revenue)\r\n * - Intelligent caching (5-minute TTL for performance)\r\n * - Trend calculations (period-over-period comparisons)\r\n * - Time series generation\r\n * - Performance optimization\r\n * \r\n * INTEGRATION:\r\n * - Workflow Engine for automation analytics\r\n * - Email Writer for email analytics\r\n * - Deal Scoring for pipeline insights\r\n * - Revenue Forecasting for revenue predictions\r\n * - DAL for environment-aware data access\r\n */\r\n\r\nimport type {\r\n  DashboardOverview,\r\n  TimePeriod,\r\n  WorkflowOverviewMetrics,\r\n  EmailOverviewMetrics,\r\n  DealOverviewMetrics,\r\n  RevenueOverviewMetrics,\r\n  TeamOverviewMetrics,\r\n  TimeSeriesDataPoint,\r\n  WorkflowPerformanceSummary,\r\n  ActionTypeMetrics,\r\n  EmailTypeMetrics,\r\n  TierDistribution,\r\n  StageMetrics,\r\n  TierMetrics,\r\n  RepPerformanceSummary,\r\n} from './types';\r\n\r\nimport { adminDal } from '@/lib/firebase/admin-dal';\r\nimport type { Workflow, WorkflowExecution } from '@/lib/workflow/types';\r\nimport { emitDashboardGenerated } from './events';\r\n\r\n// ============================================================================\r\n// CACHE CONFIGURATION\r\n// ============================================================================\r\n\r\n/** Cache TTL in seconds (5 minutes) */\r\nconst CACHE_TTL = 300;\r\n\r\n/** In-memory cache */\r\nconst analyticsCache = new Map<string, { data: DashboardOverview; timestamp: Date }>();\r\n\r\n// ============================================================================\r\n// UTILITY FUNCTIONS\r\n// ============================================================================\r\n\r\n/**\r\n * Convert Firestore Timestamp or Date-like object to Date\r\n */\r\nfunction toDate(value: any): Date {\r\n  if (value instanceof Date) {\r\n    return value;\r\n  }\r\n  if (value && typeof value.toDate === 'function') {\r\n    return value.toDate();\r\n  }\r\n  return new Date(value);\r\n}\r\n\r\n// ============================================================================\r\n// MAIN ANALYTICS ENGINE\r\n// ============================================================================\r\n\r\n/**\r\n * Get comprehensive dashboard analytics\r\n * \r\n * @param organizationId - Organization ID\r\n * @param workspaceId - Workspace ID\r\n * @param period - Time period for analytics\r\n * @param startDate - Custom start date (for custom period)\r\n * @param endDate - Custom end date (for custom period)\r\n * @returns Dashboard overview with all metrics\r\n */\r\nexport async function getDashboardAnalytics(\r\n  organizationId: string,\r\n  workspaceId: string,\r\n  period: TimePeriod,\r\n  startDate?: Date,\r\n  endDate?: Date\r\n): Promise<DashboardOverview> {\r\n  const startTime = Date.now();\r\n  \r\n  // Check cache\r\n  const cacheKey = `${organizationId}:${workspaceId}:${period}:${startDate?.toISOString()}:${endDate?.toISOString()}`;\r\n  const cached = analyticsCache.get(cacheKey);\r\n  \r\n  if (cached) {\r\n    const age = Date.now() - cached.timestamp.getTime();\r\n    if (age < CACHE_TTL * 1000) {\r\n      // Emit event for cached response\r\n      const generationTime = Date.now() - startTime;\r\n      await emitDashboardGenerated(\r\n        organizationId,\r\n        workspaceId,\r\n        period,\r\n        generationTime,\r\n        true,\r\n        cached.data\r\n      );\r\n      return cached.data;\r\n    }\r\n  }\r\n  \r\n  // Calculate date range\r\n  const dateRange = calculateDateRange(period, startDate, endDate);\r\n  const previousDateRange = calculatePreviousDateRange(dateRange.start, dateRange.end);\r\n  \r\n  // Aggregate data from all sources in parallel\r\n  const [workflows, emails, deals, revenue, team] = await Promise.all([\r\n    getWorkflowMetrics(organizationId, workspaceId, dateRange.start, dateRange.end, previousDateRange),\r\n    getEmailMetrics(organizationId, workspaceId, dateRange.start, dateRange.end, previousDateRange),\r\n    getDealMetrics(organizationId, workspaceId, dateRange.start, dateRange.end, previousDateRange),\r\n    getRevenueMetrics(organizationId, workspaceId, dateRange.start, dateRange.end, previousDateRange),\r\n    getTeamMetrics(organizationId, workspaceId, dateRange.start, dateRange.end),\r\n  ]);\r\n  \r\n  const dashboard: DashboardOverview = {\r\n    period,\r\n    startDate: dateRange.start,\r\n    endDate: dateRange.end,\r\n    workflows,\r\n    emails,\r\n    deals,\r\n    revenue,\r\n    team,\r\n  };\r\n  \r\n  // Cache result\r\n  analyticsCache.set(cacheKey, {\r\n    data: dashboard,\r\n    timestamp: new Date(),\r\n  });\r\n  \r\n  // Emit event for new generation\r\n  const generationTime = Date.now() - startTime;\r\n  await emitDashboardGenerated(\r\n    organizationId,\r\n    workspaceId,\r\n    period,\r\n    generationTime,\r\n    false,\r\n    dashboard\r\n  );\r\n  \r\n  return dashboard;\r\n}\r\n\r\n// ============================================================================\r\n// WORKFLOW ANALYTICS\r\n// ============================================================================\r\n\r\n/**\r\n * Get workflow analytics metrics\r\n */\r\nasync function getWorkflowMetrics(\r\n  organizationId: string,\r\n  workspaceId: string,\r\n  startDate: Date,\r\n  endDate: Date,\r\n  previousDateRange: { start: Date; end: Date }\r\n): Promise<WorkflowOverviewMetrics> {\r\n  if (!adminDal) {\r\n    return {\r\n      totalActiveWorkflows: 0,\r\n      totalExecutions: 0,\r\n      successfulExecutions: 0,\r\n      failedExecutions: 0,\r\n      successRate: 0,\r\n      averageExecutionTime: 0,\r\n      totalActionsExecuted: 0,\r\n      executionsTrend: 0,\r\n      topWorkflows: [],\r\n      executionsByDay: [],\r\n      actionBreakdown: [],\r\n    };\r\n  }\r\n\r\n  // Get all workflows\r\n  const workflows = await adminDal.getAllWorkflows(organizationId, workspaceId);\r\n  const activeWorkflows = workflows.filter((w: Workflow) => w.status === 'active');\r\n  \r\n  // Get executions in current period\r\n  const executions = await adminDal.getWorkflowExecutions(\r\n    organizationId,\r\n    workspaceId,\r\n    startDate,\r\n    endDate\r\n  );\r\n  \r\n  // Get executions in previous period (for trend)\r\n  const previousExecutions = await adminDal.getWorkflowExecutions(\r\n    organizationId,\r\n    workspaceId,\r\n    previousDateRange.start,\r\n    previousDateRange.end\r\n  );\r\n  \r\n  // Calculate basic metrics\r\n  const totalExecutions = executions.length;\r\n  const successfulExecutions = executions.filter((e: WorkflowExecution) => e.status === 'completed').length;\r\n  const failedExecutions = executions.filter((e: WorkflowExecution) => e.status === 'failed').length;\r\n  const successRate = totalExecutions > 0 ? (successfulExecutions / totalExecutions) * 100 : 0;\r\n  \r\n  // Calculate average execution time\r\n  const executionTimes = executions\r\n    .filter((e: WorkflowExecution) => e.completedAt && e.startedAt)\r\n    .map((e: WorkflowExecution) => {\r\n      const start = toDate(e.startedAt);\r\n      const end = toDate(e.completedAt);\r\n      return end.getTime() - start.getTime();\r\n    });\r\n  \r\n  const averageExecutionTime = executionTimes.length > 0\r\n    ? executionTimes.reduce((sum, t) => sum + t, 0) / executionTimes.length\r\n    : 0;\r\n  \r\n  // Calculate total actions\r\n  const totalActionsExecuted = executions.reduce((sum, e: WorkflowExecution) => {\r\n    return sum + (e.actionsExecuted?.length || 0);\r\n  }, 0);\r\n  \r\n  // Calculate trend\r\n  const executionsTrend = previousExecutions.length > 0\r\n    ? ((totalExecutions - previousExecutions.length) / previousExecutions.length) * 100\r\n    : 0;\r\n  \r\n  // Get top workflows\r\n  const topWorkflows = calculateTopWorkflows(workflows, executions);\r\n  \r\n  // Get executions by day\r\n  const executionsByDay = generateTimeSeries(executions, startDate, endDate, (e: WorkflowExecution) => 1);\r\n  \r\n  // Get action breakdown\r\n  const actionBreakdown = calculateActionBreakdown(executions, totalActionsExecuted);\r\n  \r\n  return {\r\n    totalActiveWorkflows: activeWorkflows.length,\r\n    totalExecutions,\r\n    successfulExecutions,\r\n    failedExecutions,\r\n    successRate,\r\n    averageExecutionTime,\r\n    totalActionsExecuted,\r\n    executionsTrend,\r\n    topWorkflows,\r\n    executionsByDay,\r\n    actionBreakdown,\r\n  };\r\n}\r\n\r\n/**\r\n * Calculate top performing workflows\r\n */\r\nfunction calculateTopWorkflows(\r\n  workflows: Workflow[],\r\n  executions: WorkflowExecution[]\r\n): WorkflowPerformanceSummary[] {\r\n  const workflowMap = new Map<string, {\r\n    workflow: Workflow;\r\n    executions: WorkflowExecution[];\r\n  }>();\r\n  \r\n  // Group executions by workflow\r\n  executions.forEach((execution: WorkflowExecution) => {\r\n    const existing = workflowMap.get(execution.workflowId) || {\r\n      workflow: workflows.find((w: Workflow) => w.id === execution.workflowId)!,\r\n      executions: [],\r\n    };\r\n    \r\n    if (existing.workflow) {\r\n      existing.executions.push(execution);\r\n      workflowMap.set(execution.workflowId, existing);\r\n    }\r\n  });\r\n  \r\n  // Calculate metrics for each workflow\r\n  const summaries: WorkflowPerformanceSummary[] = Array.from(workflowMap.entries())\r\n    .map(([workflowId, data]) => {\r\n      const successCount = data.executions.filter(e => e.status === 'completed').length;\r\n      const successRate = data.executions.length > 0\r\n        ? (successCount / data.executions.length) * 100\r\n        : 0;\r\n      \r\n      const executionTimes = data.executions\r\n        .filter(e => e.completedAt && e.startedAt)\r\n        .map(e => {\r\n          const start = toDate(e.startedAt);\r\n          const end = toDate(e.completedAt);\r\n          return end.getTime() - start.getTime();\r\n        });\r\n      \r\n      const averageTime = executionTimes.length > 0\r\n        ? executionTimes.reduce((sum, t) => sum + t, 0) / executionTimes.length\r\n        : 0;\r\n      \r\n      // Estimate time saved (assume each execution saves 10 minutes)\r\n      const timeSaved = (data.executions.length * 10) / 60; // hours\r\n      \r\n      return {\r\n        workflowId,\r\n        name: data.workflow.name,\r\n        executions: data.executions.length,\r\n        successRate,\r\n        averageTime,\r\n        timeSaved,\r\n      };\r\n    })\r\n    .sort((a, b) => b.executions - a.executions)\r\n    .slice(0, 5);\r\n  \r\n  return summaries;\r\n}\r\n\r\n/**\r\n * Calculate action type breakdown\r\n */\r\nfunction calculateActionBreakdown(\r\n  executions: WorkflowExecution[],\r\n  totalActions: number\r\n): ActionTypeMetrics[] {\r\n  const actionMap = new Map<string, {\r\n    count: number;\r\n    success: number;\r\n    times: number[];\r\n  }>();\r\n  \r\n  executions.forEach((execution: WorkflowExecution) => {\r\n    const results = execution.actionsExecuted || [];\r\n    results.forEach((result: any) => {\r\n      const actionType = result.actionType || 'unknown';\r\n      const existing = actionMap.get(actionType) || {\r\n        count: 0,\r\n        success: 0,\r\n        times: [],\r\n      };\r\n      \r\n      actionMap.set(actionType, {\r\n        count: existing.count + 1,\r\n        success: existing.success + (result.status === 'success' ? 1 : 0),\r\n        times: [...existing.times, result.duration || 0],\r\n      });\r\n    });\r\n  });\r\n  \r\n  return Array.from(actionMap.entries())\r\n    .map(([actionType, data]) => ({\r\n      actionType,\r\n      count: data.count,\r\n      successRate: data.count > 0 ? (data.success / data.count) * 100 : 0,\r\n      averageTime: data.times.length > 0\r\n        ? data.times.reduce((sum, t) => sum + t, 0) / data.times.length\r\n        : 0,\r\n      percentage: totalActions > 0 ? (data.count / totalActions) * 100 : 0,\r\n    }))\r\n    .sort((a, b) => b.count - a.count);\r\n}\r\n\r\n// ============================================================================\r\n// EMAIL ANALYTICS\r\n// ============================================================================\r\n\r\n/**\r\n * Get email analytics metrics\r\n */\r\nasync function getEmailMetrics(\r\n  organizationId: string,\r\n  workspaceId: string,\r\n  startDate: Date,\r\n  endDate: Date,\r\n  previousDateRange: { start: Date; end: Date }\r\n): Promise<EmailOverviewMetrics> {\r\n  if (!adminDal) {\r\n    return {\r\n      totalGenerated: 0,\r\n      totalSent: 0,\r\n      averageGenerationTime: 0,\r\n      mostUsedType: 'sales',\r\n      generationTrend: 0,\r\n      byType: [],\r\n      emailsByDay: [],\r\n      byTier: [],\r\n    };\r\n  }\r\n\r\n  // Get email generation events from Signal Bus or email writer logs\r\n  const emails = await adminDal.getEmailGenerations(\r\n    organizationId,\r\n    workspaceId,\r\n    startDate,\r\n    endDate\r\n  );\r\n  \r\n  const previousEmails = await adminDal.getEmailGenerations(\r\n    organizationId,\r\n    workspaceId,\r\n    previousDateRange.start,\r\n    previousDateRange.end\r\n  );\r\n  \r\n  const totalGenerated = emails.length;\r\n  const totalSent = emails.filter((e: any) => e.sent).length;\r\n  \r\n  // Calculate average generation time\r\n  const generationTimes = emails\r\n    .filter((e: any) => e.generationTime)\r\n    .map((e: any) => e.generationTime);\r\n  \r\n  const averageGenerationTime = generationTimes.length > 0\r\n    ? generationTimes.reduce((sum: number, t: number) => sum + t, 0) / generationTimes.length\r\n    : 0;\r\n  \r\n  // Get most used type\r\n  const typeCount = new Map<string, number>();\r\n  emails.forEach((e: any) => {\r\n    const type = e.type || 'unknown';\r\n    typeCount.set(type, (typeCount.get(type) || 0) + 1);\r\n  });\r\n  \r\n  const mostUsedType = Array.from(typeCount.entries())\r\n    .sort((a, b) => b[1] - a[1])[0]?.[0] || 'intro';\r\n  \r\n  // Calculate trend\r\n  const generationTrend = previousEmails.length > 0\r\n    ? ((totalGenerated - previousEmails.length) / previousEmails.length) * 100\r\n    : 0;\r\n  \r\n  // Get emails by type\r\n  const byType = calculateEmailsByType(emails, totalGenerated);\r\n  \r\n  // Get emails by day\r\n  const emailsByDay = generateTimeSeries(emails, startDate, endDate, () => 1);\r\n  \r\n  // Get emails by tier\r\n  const byTier = calculateEmailsByTier(emails, totalGenerated);\r\n  \r\n  return {\r\n    totalGenerated,\r\n    totalSent,\r\n    averageGenerationTime,\r\n    mostUsedType,\r\n    generationTrend,\r\n    byType,\r\n    emailsByDay,\r\n    byTier,\r\n  };\r\n}\r\n\r\n/**\r\n * Calculate emails by type\r\n */\r\nfunction calculateEmailsByType(emails: any[], total: number): EmailTypeMetrics[] {\r\n  const typeMap = new Map<string, { count: number; times: number[] }>();\r\n  \r\n  emails.forEach((email: any) => {\r\n    const type = email.type || 'unknown';\r\n    const existing = typeMap.get(type) || { count: 0, times: [] };\r\n    \r\n    typeMap.set(type, {\r\n      count: existing.count + 1,\r\n      times: [...existing.times, email.generationTime || 0],\r\n    });\r\n  });\r\n  \r\n  return Array.from(typeMap.entries())\r\n    .map(([type, data]) => ({\r\n      type,\r\n      count: data.count,\r\n      percentage: total > 0 ? (data.count / total) * 100 : 0,\r\n      averageTime: data.times.length > 0\r\n        ? data.times.reduce((sum, t) => sum + t, 0) / data.times.length\r\n        : 0,\r\n    }))\r\n    .sort((a, b) => b.count - a.count);\r\n}\r\n\r\n/**\r\n * Calculate emails by tier\r\n */\r\nfunction calculateEmailsByTier(emails: any[], total: number): TierDistribution[] {\r\n  const tierMap = new Map<string, number>();\r\n  \r\n  emails.forEach((email: any) => {\r\n    const tier = email.dealTier || 'unknown';\r\n    tierMap.set(tier, (tierMap.get(tier) || 0) + 1);\r\n  });\r\n  \r\n  return Array.from(tierMap.entries())\r\n    .map(([tier, count]) => ({\r\n      tier,\r\n      count,\r\n      percentage: total > 0 ? (count / total) * 100 : 0,\r\n    }))\r\n    .sort((a, b) => b.count - a.count);\r\n}\r\n\r\n// ============================================================================\r\n// DEAL ANALYTICS\r\n// ============================================================================\r\n\r\n/**\r\n * Get deal analytics metrics\r\n */\r\nasync function getDealMetrics(\r\n  organizationId: string,\r\n  workspaceId: string,\r\n  startDate: Date,\r\n  endDate: Date,\r\n  previousDateRange: { start: Date; end: Date }\r\n): Promise<DealOverviewMetrics> {\r\n  if (!adminDal) {\r\n    return {\r\n      totalActiveDeals: 0,\r\n      totalValue: 0,\r\n      averageValue: 0,\r\n      hotDeals: 0,\r\n      atRiskDeals: 0,\r\n      dealsTrend: 0,\r\n      byStage: [],\r\n      byTier: [],\r\n      averageVelocity: 0,\r\n      pipelineByDay: [],\r\n    };\r\n  }\r\n\r\n  // Get all active deals\r\n  const deals = await adminDal.getActiveDeals(organizationId, workspaceId);\r\n  const previousDeals = await adminDal.getDealsSnapshot(\r\n    organizationId,\r\n    workspaceId,\r\n    previousDateRange.end\r\n  );\r\n  \r\n  const totalActiveDeals = deals.length;\r\n  const totalValue = deals.reduce((sum: number, d: any) => sum + (d.value || 0), 0);\r\n  const averageValue = totalActiveDeals > 0 ? totalValue / totalActiveDeals : 0;\r\n  \r\n  // Count hot and at-risk deals\r\n  const hotDeals = deals.filter((d: any) => d.tier === 'hot').length;\r\n  const atRiskDeals = deals.filter((d: any) => d.tier === 'at-risk').length;\r\n  \r\n  // Calculate trend\r\n  const dealsTrend = previousDeals.length > 0\r\n    ? ((totalActiveDeals - previousDeals.length) / previousDeals.length) * 100\r\n    : 0;\r\n  \r\n  // Get deals by stage\r\n  const byStage = calculateDealsByStage(deals);\r\n  \r\n  // Get deals by tier\r\n  const byTier = calculateDealsByTier(deals);\r\n  \r\n  // Calculate average velocity\r\n  const closedDeals = await adminDal.getClosedDeals(\r\n    organizationId,\r\n    workspaceId,\r\n    startDate,\r\n    endDate\r\n  );\r\n  const averageVelocity = calculateAverageVelocity(closedDeals);\r\n  \r\n  // Get pipeline by day\r\n  const pipelineByDay = await generateDealPipelineTimeSeries(\r\n    organizationId,\r\n    workspaceId,\r\n    startDate,\r\n    endDate\r\n  );\r\n  \r\n  return {\r\n    totalActiveDeals,\r\n    totalValue,\r\n    averageValue,\r\n    hotDeals,\r\n    atRiskDeals,\r\n    dealsTrend,\r\n    byStage,\r\n    byTier,\r\n    averageVelocity,\r\n    pipelineByDay,\r\n  };\r\n}\r\n\r\n/**\r\n * Calculate deals by stage\r\n */\r\nfunction calculateDealsByStage(deals: any[]): StageMetrics[] {\r\n  const stageMap = new Map<string, {\r\n    count: number;\r\n    value: number;\r\n    times: number[];\r\n  }>();\r\n  \r\n  deals.forEach((deal: any) => {\r\n    const stage = deal.stage || 'unknown';\r\n    const existing = stageMap.get(stage) || { count: 0, value: 0, times: [] };\r\n    \r\n    stageMap.set(stage, {\r\n      count: existing.count + 1,\r\n      value: existing.value + (deal.value || 0),\r\n      times: [...existing.times, deal.timeInStage || 0],\r\n    });\r\n  });\r\n  \r\n  const total = deals.length;\r\n  \r\n  return Array.from(stageMap.entries())\r\n    .map(([stage, data]) => ({\r\n      stage,\r\n      count: data.count,\r\n      value: data.value,\r\n      percentage: total > 0 ? (data.count / total) * 100 : 0,\r\n      averageTimeInStage: data.times.length > 0\r\n        ? data.times.reduce((sum, t) => sum + t, 0) / data.times.length\r\n        : 0,\r\n    }))\r\n    .sort((a, b) => b.count - a.count);\r\n}\r\n\r\n/**\r\n * Calculate deals by tier\r\n */\r\nfunction calculateDealsByTier(deals: any[]): TierMetrics[] {\r\n  const tierMap = new Map<string, {\r\n    count: number;\r\n    value: number;\r\n    scores: number[];\r\n  }>();\r\n  \r\n  deals.forEach((deal: any) => {\r\n    const tier = deal.tier || 'unknown';\r\n    const existing = tierMap.get(tier) || { count: 0, value: 0, scores: [] };\r\n    \r\n    tierMap.set(tier, {\r\n      count: existing.count + 1,\r\n      value: existing.value + (deal.value || 0),\r\n      scores: [...existing.scores, deal.score || 0],\r\n    });\r\n  });\r\n  \r\n  const total = deals.length;\r\n  \r\n  return Array.from(tierMap.entries())\r\n    .map(([tier, data]) => ({\r\n      tier,\r\n      count: data.count,\r\n      value: data.value,\r\n      percentage: total > 0 ? (data.count / total) * 100 : 0,\r\n      averageScore: data.scores.length > 0\r\n        ? data.scores.reduce((sum, s) => sum + s, 0) / data.scores.length\r\n        : 0,\r\n    }))\r\n    .sort((a, b) => {\r\n      const tierOrder: Record<string, number> = { hot: 0, warm: 1, cold: 2, 'at-risk': 3 };\r\n      return (tierOrder[a.tier] || 99) - (tierOrder[b.tier] || 99);\r\n    });\r\n}\r\n\r\n/**\r\n * Calculate average deal velocity (days to close)\r\n */\r\nfunction calculateAverageVelocity(closedDeals: any[]): number {\r\n  const velocities = closedDeals\r\n    .filter((d: any) => d.createdAt && d.closedAt)\r\n    .map((d: any) => {\r\n      const created = toDate(d.createdAt);\r\n      const closed = toDate(d.closedAt);\r\n      const days = (closed.getTime() - created.getTime()) / (1000 * 60 * 60 * 24);\r\n      return days;\r\n    });\r\n  \r\n  return velocities.length > 0\r\n    ? velocities.reduce((sum, v) => sum + v, 0) / velocities.length\r\n    : 0;\r\n}\r\n\r\n/**\r\n * Generate deal pipeline time series\r\n */\r\nasync function generateDealPipelineTimeSeries(\r\n  organizationId: string,\r\n  workspaceId: string,\r\n  startDate: Date,\r\n  endDate: Date\r\n): Promise<TimeSeriesDataPoint[]> {\r\n  // For now, return empty array - would need historical snapshots\r\n  // This could be enhanced with deal history tracking\r\n  return [];\r\n}\r\n\r\n// ============================================================================\r\n// REVENUE ANALYTICS\r\n// ============================================================================\r\n\r\n/**\r\n * Get revenue analytics metrics\r\n */\r\nasync function getRevenueMetrics(\r\n  organizationId: string,\r\n  workspaceId: string,\r\n  startDate: Date,\r\n  endDate: Date,\r\n  previousDateRange: { start: Date; end: Date }\r\n): Promise<RevenueOverviewMetrics> {\r\n  if (!adminDal) {\r\n    return {\r\n      totalRevenue: 0,\r\n      quota: 0,\r\n      quotaAttainment: 0,\r\n      forecastOptimistic: 0,\r\n      forecastRealistic: 0,\r\n      forecastPessimistic: 0,\r\n      revenueTrend: 0,\r\n      revenueByDay: [],\r\n      winRate: 0,\r\n      averageDealSize: 0,\r\n    };\r\n  }\r\n\r\n  // Get closed/won deals in period\r\n  const wonDeals = await adminDal.getWonDeals(\r\n    organizationId,\r\n    workspaceId,\r\n    startDate,\r\n    endDate\r\n  );\r\n  \r\n  const previousWonDeals = await adminDal.getWonDeals(\r\n    organizationId,\r\n    workspaceId,\r\n    previousDateRange.start,\r\n    previousDateRange.end\r\n  );\r\n  \r\n  const totalRevenue = wonDeals.reduce((sum: number, d: any) => sum + (d.value || 0), 0);\r\n  const previousRevenue = previousWonDeals.reduce((sum: number, d: any) => sum + (d.value || 0), 0);\r\n  \r\n  // Get quota (would come from workspace settings)\r\n  const quota = 100000; // TODO: Get from workspace settings\r\n  const quotaAttainment = quota > 0 ? (totalRevenue / quota) * 100 : 0;\r\n  \r\n  // Get revenue forecast from forecasting engine\r\n  const forecast = await adminDal.getRevenueForecast(organizationId, workspaceId);\r\n  \r\n  // Calculate trend\r\n  const revenueTrend = previousRevenue > 0\r\n    ? ((totalRevenue - previousRevenue) / previousRevenue) * 100\r\n    : 0;\r\n  \r\n  // Get revenue by day\r\n  const revenueByDay = generateTimeSeries(\r\n    wonDeals,\r\n    startDate,\r\n    endDate,\r\n    (d: any) => d.value || 0\r\n  );\r\n  \r\n  // Calculate win rate\r\n  const allDeals = await adminDal.getClosedDeals(organizationId, workspaceId, startDate, endDate);\r\n  const winRate = allDeals.length > 0\r\n    ? (wonDeals.length / allDeals.length) * 100\r\n    : 0;\r\n  \r\n  // Calculate average deal size\r\n  const averageDealSize = wonDeals.length > 0\r\n    ? totalRevenue / wonDeals.length\r\n    : 0;\r\n  \r\n  return {\r\n    totalRevenue,\r\n    quota,\r\n    quotaAttainment,\r\n    forecastOptimistic: forecast?.optimistic || 0,\r\n    forecastRealistic: forecast?.realistic || 0,\r\n    forecastPessimistic: forecast?.pessimistic || 0,\r\n    revenueTrend,\r\n    revenueByDay,\r\n    winRate,\r\n    averageDealSize,\r\n  };\r\n}\r\n\r\n// ============================================================================\r\n// TEAM ANALYTICS\r\n// ============================================================================\r\n\r\n/**\r\n * Get team analytics metrics\r\n */\r\nasync function getTeamMetrics(\r\n  organizationId: string,\r\n  workspaceId: string,\r\n  startDate: Date,\r\n  endDate: Date\r\n): Promise<TeamOverviewMetrics> {\r\n  if (!adminDal) {\r\n    return {\r\n      totalReps: 0,\r\n      topPerformers: [],\r\n      averageDealsPerRep: 0,\r\n      averageQuotaAttainment: 0,\r\n      teamVelocity: 0,\r\n    };\r\n  }\r\n\r\n  const dal = adminDal; // Type narrowing for callbacks\r\n\r\n  // Get all reps (users with role 'sales')\r\n  const reps = await dal.getSalesReps(organizationId, workspaceId);\r\n  \r\n  // Get deals for each rep\r\n  const repDeals = await Promise.all(\r\n    reps.map((rep: any) =>\r\n      dal.getRepDeals(organizationId, workspaceId, rep.id, startDate, endDate)\r\n    )\r\n  );\r\n  \r\n  // Calculate rep performance\r\n  const repPerformance: RepPerformanceSummary[] = reps.map((rep: any, index: number) => {\r\n    const deals = repDeals[index] || [];\r\n    const wonDeals = deals.filter((d: any) => d.status === 'won');\r\n    const revenue = wonDeals.reduce((sum: number, d: any) => sum + (d.value || 0), 0);\r\n    const quota = rep.quota || 100000;\r\n    \r\n    return {\r\n      repId: rep.id,\r\n      repName: rep.name || rep.email,\r\n      deals: deals.length,\r\n      revenue,\r\n      quotaAttainment: quota > 0 ? (revenue / quota) * 100 : 0,\r\n      winRate: deals.length > 0 ? (wonDeals.length / deals.length) * 100 : 0,\r\n      averageDealSize: wonDeals.length > 0 ? revenue / wonDeals.length : 0,\r\n    };\r\n  });\r\n  \r\n  // Get top performers\r\n  const topPerformers = repPerformance\r\n    .sort((a, b) => b.revenue - a.revenue)\r\n    .slice(0, 5);\r\n  \r\n  // Calculate averages\r\n  const totalDeals = repPerformance.reduce((sum, r) => sum + r.deals, 0);\r\n  const averageDealsPerRep = reps.length > 0 ? totalDeals / reps.length : 0;\r\n  \r\n  const totalQuotaAttainment = repPerformance.reduce((sum, r) => sum + r.quotaAttainment, 0);\r\n  const averageQuotaAttainment = reps.length > 0 ? totalQuotaAttainment / reps.length : 0;\r\n  \r\n  // Calculate team velocity\r\n  const allRepDeals = repDeals.flat();\r\n  const teamVelocity = calculateAverageVelocity(allRepDeals);\r\n  \r\n  return {\r\n    totalReps: reps.length,\r\n    topPerformers,\r\n    averageDealsPerRep,\r\n    averageQuotaAttainment,\r\n    teamVelocity,\r\n  };\r\n}\r\n\r\n// ============================================================================\r\n// UTILITY FUNCTIONS\r\n// ============================================================================\r\n\r\n/**\r\n * Calculate date range based on period\r\n */\r\nfunction calculateDateRange(\r\n  period: TimePeriod,\r\n  customStart?: Date,\r\n  customEnd?: Date\r\n): { start: Date; end: Date } {\r\n  const now = new Date();\r\n  const end = customEnd || now;\r\n  let start: Date;\r\n  \r\n  switch (period) {\r\n    case '24h':\r\n      start = new Date(now.getTime() - 24 * 60 * 60 * 1000);\r\n      break;\r\n    case '7d':\r\n      start = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);\r\n      break;\r\n    case '30d':\r\n      start = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);\r\n      break;\r\n    case '90d':\r\n      start = new Date(now.getTime() - 90 * 24 * 60 * 60 * 1000);\r\n      break;\r\n    case 'month':\r\n      start = new Date(now.getFullYear(), now.getMonth(), 1);\r\n      break;\r\n    case 'quarter':\r\n      const quarter = Math.floor(now.getMonth() / 3);\r\n      start = new Date(now.getFullYear(), quarter * 3, 1);\r\n      break;\r\n    case 'year':\r\n      start = new Date(now.getFullYear(), 0, 1);\r\n      break;\r\n    case 'custom':\r\n      start = customStart || new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);\r\n      break;\r\n    default:\r\n      start = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);\r\n  }\r\n  \r\n  return { start, end };\r\n}\r\n\r\n/**\r\n * Calculate previous date range for comparison\r\n */\r\nfunction calculatePreviousDateRange(\r\n  start: Date,\r\n  end: Date\r\n): { start: Date; end: Date } {\r\n  const duration = end.getTime() - start.getTime();\r\n  return {\r\n    start: new Date(start.getTime() - duration),\r\n    end: start,\r\n  };\r\n}\r\n\r\n/**\r\n * Generate time series data\r\n */\r\nfunction generateTimeSeries<T>(\r\n  items: T[],\r\n  startDate: Date,\r\n  endDate: Date,\r\n  valueExtractor: (item: T) => number\r\n): TimeSeriesDataPoint[] {\r\n  const dayMap = new Map<string, number>();\r\n  \r\n  // Initialize all days with 0\r\n  const days = Math.ceil((endDate.getTime() - startDate.getTime()) / (1000 * 60 * 60 * 24));\r\n  for (let i = 0; i <= days; i++) {\r\n    const date = new Date(startDate.getTime() + i * 24 * 60 * 60 * 1000);\r\n    const key = date.toISOString().split('T')[0];\r\n    dayMap.set(key, 0);\r\n  }\r\n  \r\n  // Add item values\r\n  items.forEach((item: any) => {\r\n    const date = item.createdAt || item.startedAt || item.date;\r\n    if (date) {\r\n      const dateObj = toDate(date);\r\n      const key = dateObj.toISOString().split('T')[0];\r\n      const existing = dayMap.get(key) || 0;\r\n      dayMap.set(key, existing + valueExtractor(item));\r\n    }\r\n  });\r\n  \r\n  return Array.from(dayMap.entries())\r\n    .map(([dateKey, value]) => ({\r\n      date: new Date(dateKey),\r\n      value,\r\n    }))\r\n    .sort((a, b) => a.date.getTime() - b.date.getTime());\r\n}\r\n\r\n/**\r\n * Clear analytics cache\r\n */\r\nexport async function clearAnalyticsCache(reason: 'manual' | 'automatic' | 'expired' = 'manual', userId?: string): Promise<void> {\r\n  analyticsCache.clear();\r\n  \r\n  // Emit cache cleared event\r\n  const { emitCacheCleared } = await import('./events');\r\n  await emitCacheCleared(reason, userId);\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\David\\PycharmProjects\\AI Sales Platform\\src\\lib\\billing\\stripe-service.ts","messages":[{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":373,"column":7,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":373,"endColumn":69},{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":374,"column":7,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":374,"endColumn":59},{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":387,"column":7,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":387,"endColumn":76},{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":388,"column":7,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":388,"endColumn":73},{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":398,"column":7,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":398,"endColumn":59},{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":399,"column":7,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":399,"endColumn":61},{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":408,"column":7,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":408,"endColumn":65},{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":409,"column":7,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":409,"endColumn":66}],"suppressedMessages":[],"errorCount":8,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Stripe Billing Service - Volume-Based Pricing\r\n * Success-linked pricing: Pay for what you store, not what you use\r\n */\r\n\r\nimport Stripe from 'stripe';\r\nimport { VOLUME_TIERS, TIER_PRICING, SubscriptionTier, ALL_INCLUSIVE_FEATURES } from '@/types/subscription';\r\n\r\n// Use placeholder during build, validate at runtime\r\nconst stripeKey = process.env.STRIPE_SECRET_KEY || 'sk_test_placeholder';\r\n\r\nconst stripe = new Stripe(stripeKey, {\r\n  apiVersion: '2023-10-16',\r\n});\r\n\r\n// Helper to ensure Stripe is configured at runtime\r\nfunction ensureStripeConfigured() {\r\n  if (!process.env.STRIPE_SECRET_KEY && process.env.NODE_ENV !== 'test') {\r\n    throw new Error('STRIPE_SECRET_KEY is not set in environment variables');\r\n  }\r\n}\r\n\r\n/**\r\n * Volume-Based Tier Definition for Stripe\r\n */\r\nexport interface StripeTierPlan {\r\n  id: SubscriptionTier;\r\n  name: string;\r\n  price: number; // in cents\r\n  interval: 'month' | 'year';\r\n  recordCapacity: {\r\n    min: number;\r\n    max: number;\r\n  };\r\n  features: readonly string[];\r\n}\r\n\r\n/**\r\n * NEW: Volume-Based Tiers (replaces old PLANS)\r\n */\r\nexport const STRIPE_TIERS: Record<SubscriptionTier, StripeTierPlan> = {\r\n  tier1: {\r\n    id: 'tier1',\r\n    name: VOLUME_TIERS.tier1.name,\r\n    price: TIER_PRICING.tier1.monthly * 100, // $400 in cents\r\n    interval: 'month',\r\n    recordCapacity: {\r\n      min: VOLUME_TIERS.tier1.recordMin,\r\n      max: VOLUME_TIERS.tier1.recordMax,\r\n    },\r\n    features: ALL_INCLUSIVE_FEATURES,\r\n  },\r\n  tier2: {\r\n    id: 'tier2',\r\n    name: VOLUME_TIERS.tier2.name,\r\n    price: TIER_PRICING.tier2.monthly * 100, // $650 in cents\r\n    interval: 'month',\r\n    recordCapacity: {\r\n      min: VOLUME_TIERS.tier2.recordMin,\r\n      max: VOLUME_TIERS.tier2.recordMax,\r\n    },\r\n    features: ALL_INCLUSIVE_FEATURES,\r\n  },\r\n  tier3: {\r\n    id: 'tier3',\r\n    name: VOLUME_TIERS.tier3.name,\r\n    price: TIER_PRICING.tier3.monthly * 100, // $1,000 in cents\r\n    interval: 'month',\r\n    recordCapacity: {\r\n      min: VOLUME_TIERS.tier3.recordMin,\r\n      max: VOLUME_TIERS.tier3.recordMax,\r\n    },\r\n    features: ALL_INCLUSIVE_FEATURES,\r\n  },\r\n  tier4: {\r\n    id: 'tier4',\r\n    name: VOLUME_TIERS.tier4.name,\r\n    price: TIER_PRICING.tier4.monthly * 100, // $1,250 in cents\r\n    interval: 'month',\r\n    recordCapacity: {\r\n      min: VOLUME_TIERS.tier4.recordMin,\r\n      max: VOLUME_TIERS.tier4.recordMax,\r\n    },\r\n    features: ALL_INCLUSIVE_FEATURES,\r\n  },\r\n};\r\n\r\n// DEPRECATED: Legacy interface kept only for type compatibility\r\n// DO NOT USE - Use STRIPE_TIERS instead\r\nexport interface SubscriptionPlan {\r\n  id: string;\r\n  name: string;\r\n  price: number;\r\n  interval: 'month' | 'year';\r\n  limits: {\r\n    records: number;\r\n    aiConversations: number;\r\n    emails: number;\r\n    gmv: number;\r\n  };\r\n  features: string[];\r\n}\r\n\r\n/**\r\n * Create a Stripe customer\r\n */\r\nexport async function createCustomer(\r\n  email: string,\r\n  name?: string,\r\n  metadata?: Record<string, string>\r\n): Promise<Stripe.Customer> {\r\n  return await stripe.customers.create({\r\n    email,\r\n    name,\r\n    metadata,\r\n  });\r\n}\r\n\r\n/**\r\n * Create a subscription (NEW: Volume-based with mandatory payment method)\r\n */\r\nexport async function createSubscription(\r\n  customerId: string,\r\n  tierId: SubscriptionTier,\r\n  organizationId: string,\r\n  trialDays: number = 14,\r\n  paymentMethodId?: string // NEW: Required for trial (will auto-charge at trial end)\r\n): Promise<Stripe.Subscription> {\r\n  const tier = STRIPE_TIERS[tierId];\r\n  if (!tier) {\r\n    throw new Error(`Invalid tier ID: ${tierId}`);\r\n  }\r\n\r\n  // Get Stripe price ID from environment\r\n  // Format: STRIPE_PRICE_ID_TIER1, STRIPE_PRICE_ID_TIER2, etc.\r\n  const priceId = process.env[`STRIPE_PRICE_ID_${tierId.toUpperCase()}`];\r\n  \r\n  if (!priceId) {\r\n    throw new Error(`Stripe price ID not configured for tier: ${tierId}. Add STRIPE_PRICE_ID_${tierId.toUpperCase()} to .env`);\r\n  }\r\n\r\n  // NEW: Build subscription params with payment method requirement\r\n  const subscriptionParams: Stripe.SubscriptionCreateParams = {\r\n    customer: customerId,\r\n    items: [{ price: priceId }],\r\n    trial_period_days: trialDays,\r\n    metadata: {\r\n      tierId,\r\n      tier: tier.name,\r\n      organizationId,\r\n      recordCapacityMin: tier.recordCapacity.min.toString(),\r\n      recordCapacityMax: tier.recordCapacity.max.toString(),\r\n    },\r\n  };\r\n\r\n  // NEW: Attach payment method if provided (required for trial)\r\n  if (paymentMethodId) {\r\n    subscriptionParams.default_payment_method = paymentMethodId;\r\n  }\r\n\r\n  // NEW: Auto-charge at trial end (not \"cancel_at_trial_end\")\r\n  // This ensures seamless conversion to paid\r\n  subscriptionParams.cancel_at_period_end = false;\r\n\r\n  return await stripe.subscriptions.create(subscriptionParams);\r\n}\r\n\r\n// DEPRECATED functions removed - use createSubscriptionWithTier instead\r\n\r\n/**\r\n * Update subscription tier (auto-scaling based on record count)\r\n */\r\nexport async function updateSubscriptionTier(\r\n  subscriptionId: string,\r\n  newTierId: SubscriptionTier,\r\n  recordCount?: number\r\n): Promise<Stripe.Subscription> {\r\n  const subscription = await stripe.subscriptions.retrieve(subscriptionId);\r\n  const tier = STRIPE_TIERS[newTierId];\r\n  \r\n  if (!tier) {\r\n    throw new Error(`Invalid tier ID: ${newTierId}`);\r\n  }\r\n\r\n  const priceId = process.env[`STRIPE_PRICE_ID_${newTierId.toUpperCase()}`];\r\n  if (!priceId) {\r\n    throw new Error(`Stripe price ID not configured for tier: ${newTierId}`);\r\n  }\r\n\r\n  return await stripe.subscriptions.update(subscriptionId, {\r\n    items: [{\r\n      id: subscription.items.data[0].id,\r\n      price: priceId,\r\n    }],\r\n    proration_behavior: 'always_invoice', // Prorate when upgrading/downgrading\r\n    metadata: {\r\n      ...subscription.metadata,\r\n      tierId: newTierId,\r\n      tier: tier.name,\r\n      recordCount: recordCount?.toString() || subscription.metadata?.recordCount,\r\n      recordCapacityMin: tier.recordCapacity.min.toString(),\r\n      recordCapacityMax: tier.recordCapacity.max.toString(),\r\n      lastTierUpdate: new Date().toISOString(),\r\n    },\r\n  });\r\n}\r\n\r\n// DEPRECATED function removed - use updateSubscriptionTier instead\r\n\r\n/**\r\n * Cancel subscription\r\n */\r\nexport async function cancelSubscription(\r\n  subscriptionId: string,\r\n  immediately: boolean = false\r\n): Promise<Stripe.Subscription> {\r\n  if (immediately) {\r\n    return await stripe.subscriptions.cancel(subscriptionId);\r\n  } else {\r\n    return await stripe.subscriptions.update(subscriptionId, {\r\n      cancel_at_period_end: true,\r\n    });\r\n  }\r\n}\r\n\r\n/**\r\n * Get subscription\r\n */\r\nexport async function getSubscription(subscriptionId: string): Promise<Stripe.Subscription> {\r\n  return await stripe.subscriptions.retrieve(subscriptionId);\r\n}\r\n\r\n/**\r\n * Create billing portal session\r\n */\r\nexport async function createBillingPortalSession(\r\n  customerId: string,\r\n  returnUrl: string\r\n): Promise<Stripe.BillingPortal.Session> {\r\n  return await stripe.billingPortal.sessions.create({\r\n    customer: customerId,\r\n    return_url: returnUrl,\r\n  });\r\n}\r\n\r\n/**\r\n * NEW: Check record capacity (replaces old usage limits)\r\n * In volume-based model, we only limit RECORDS, not feature usage\r\n */\r\nexport async function checkRecordCapacity(\r\n  organizationId: string,\r\n  currentRecordCount: number,\r\n  additionalRecords: number = 0\r\n): Promise<{ \r\n  allowed: boolean; \r\n  currentTier: SubscriptionTier;\r\n  requiredTier: SubscriptionTier;\r\n  capacity: number; \r\n  totalRecords: number;\r\n  needsUpgrade: boolean;\r\n  upgradePrice?: number;\r\n}> {\r\n  // Get organization's subscription\r\n  const { FirestoreService, COLLECTIONS } = await import('@/lib/db/firestore-service');\r\n  const org = await FirestoreService.get(COLLECTIONS.ORGANIZATIONS, organizationId);\r\n  \r\n  if (!org?.subscriptionId) {\r\n    return { \r\n      allowed: false, \r\n      currentTier: 'tier1',\r\n      requiredTier: 'tier1',\r\n      capacity: 0, \r\n      totalRecords: 0,\r\n      needsUpgrade: false,\r\n    };\r\n  }\r\n\r\n  const subscription = await getSubscription(org.subscriptionId);\r\n  const currentTierId = (subscription.metadata?.tierId as SubscriptionTier) || 'tier1';\r\n  const currentTier = STRIPE_TIERS[currentTierId];\r\n  \r\n  const totalRecords = currentRecordCount + additionalRecords;\r\n  const withinCapacity = totalRecords <= currentTier.recordCapacity.max;\r\n  \r\n  // Determine required tier if exceeding current capacity\r\n  let requiredTierId = currentTierId;\r\n  if (!withinCapacity) {\r\n    if (totalRecords <= STRIPE_TIERS.tier1.recordCapacity.max) requiredTierId = 'tier1';\r\n    else if (totalRecords <= STRIPE_TIERS.tier2.recordCapacity.max) requiredTierId = 'tier2';\r\n    else if (totalRecords <= STRIPE_TIERS.tier3.recordCapacity.max) requiredTierId = 'tier3';\r\n    else requiredTierId = 'tier4';\r\n  }\r\n  \r\n  const needsUpgrade = requiredTierId !== currentTierId;\r\n\r\n  return {\r\n    allowed: withinCapacity,\r\n    currentTier: currentTierId,\r\n    requiredTier: requiredTierId,\r\n    capacity: currentTier.recordCapacity.max,\r\n    totalRecords,\r\n    needsUpgrade,\r\n    upgradePrice: needsUpgrade ? STRIPE_TIERS[requiredTierId].price / 100 : undefined,\r\n  };\r\n}\r\n\r\n/**\r\n * DEPRECATED: Legacy usage limits (kept for backward compatibility)\r\n * In new model, features are UNLIMITED - only records are capped\r\n */\r\nexport interface UsageMetrics {\r\n  records: number;\r\n  aiConversations: number;\r\n  emails: number;\r\n  gmv: number; // in cents\r\n}\r\n\r\nexport async function checkUsageLimit(\r\n  organizationId: string,\r\n  metric: keyof UsageMetrics,\r\n  currentUsage: number\r\n): Promise<{ allowed: boolean; limit: number; remaining: number }> {\r\n  // MIGRATION NOTE: In new pricing model, all features are unlimited\r\n  // Only 'records' metric is enforced via checkRecordCapacity()\r\n  if (metric === 'records') {\r\n    const capacityCheck = await checkRecordCapacity(organizationId, currentUsage);\r\n    return {\r\n      allowed: capacityCheck.allowed,\r\n      limit: capacityCheck.capacity,\r\n      remaining: capacityCheck.capacity - capacityCheck.totalRecords,\r\n    };\r\n  }\r\n  \r\n  // All other metrics are unlimited in new model\r\n  return { allowed: true, limit: -1, remaining: -1 };\r\n}\r\n\r\n/**\r\n * Record usage\r\n */\r\nexport async function recordUsage(\r\n  organizationId: string,\r\n  metric: keyof UsageMetrics,\r\n  amount: number = 1\r\n): Promise<void> {\r\n  const { FirestoreService, COLLECTIONS } = await import('@/lib/db/firestore-service');\r\n  \r\n  // Get current usage\r\n  const org = await FirestoreService.get(COLLECTIONS.ORGANIZATIONS, organizationId);\r\n  const currentUsage = org?.usage?.[metric] || 0;\r\n  \r\n  // Update usage\r\n  await FirestoreService.update(COLLECTIONS.ORGANIZATIONS, organizationId, {\r\n    usage: {\r\n      ...(org?.usage || {}),\r\n      [metric]: currentUsage + amount,\r\n      lastUpdated: new Date().toISOString(),\r\n    },\r\n  });\r\n}\r\n\r\n/**\r\n * Handle Stripe webhook events\r\n */\r\nexport async function handleWebhook(\r\n  event: Stripe.Event\r\n): Promise<void> {\r\n  const { FirestoreService, COLLECTIONS } = await import('@/lib/db/firestore-service');\r\n\r\n  switch (event.type) {\r\n    case 'customer.subscription.created':\r\n    case 'customer.subscription.updated':\r\n      const subscription = event.data.object as Stripe.Subscription;\r\n      const orgId = subscription.metadata?.organizationId;\r\n      \r\n      if (orgId) {\r\n        await FirestoreService.update(COLLECTIONS.ORGANIZATIONS, orgId, {\r\n          subscriptionId: subscription.id,\r\n          subscriptionStatus: subscription.status,\r\n          planId: subscription.metadata?.planId,\r\n          currentPeriodEnd: new Date(subscription.current_period_end * 1000).toISOString(),\r\n        });\r\n      }\r\n      break;\r\n\r\n    case 'customer.subscription.deleted':\r\n      const deletedSubscription = event.data.object as Stripe.Subscription;\r\n      const deletedOrgId = deletedSubscription.metadata?.organizationId;\r\n      \r\n      if (deletedOrgId) {\r\n        await FirestoreService.update(COLLECTIONS.ORGANIZATIONS, deletedOrgId, {\r\n          subscriptionStatus: 'canceled',\r\n        });\r\n      }\r\n      break;\r\n\r\n    case 'invoice.payment_succeeded':\r\n      const invoice = event.data.object as Stripe.Invoice;\r\n      const invoiceOrgId = invoice.metadata?.organizationId;\r\n      \r\n      if (invoiceOrgId) {\r\n        // Update billing history\r\n        // Implementation depends on your billing history structure\r\n      }\r\n      break;\r\n\r\n    case 'invoice.payment_failed':\r\n      const failedInvoice = event.data.object as Stripe.Invoice;\r\n      const failedOrgId = failedInvoice.metadata?.organizationId;\r\n      \r\n      if (failedOrgId) {\r\n        await FirestoreService.update(COLLECTIONS.ORGANIZATIONS, failedOrgId, {\r\n          paymentFailed: true,\r\n          paymentFailedAt: new Date().toISOString(),\r\n        });\r\n      }\r\n      break;\r\n  }\r\n}\r\n\r\n\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\David\\PycharmProjects\\AI Sales Platform\\src\\lib\\coaching\\coaching-analytics-engine.ts","messages":[{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":933,"column":9,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":933,"endColumn":56}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Coaching Analytics Engine\r\n * \r\n * SOVEREIGN CORPORATE BRAIN - COACHING MODULE\r\n * \r\n * Core engine for analyzing sales rep performance across all metrics.\r\n * Aggregates data from deals, emails, activities, workflows, and revenue.\r\n * \r\n * CORE CAPABILITIES:\r\n * - Multi-source data aggregation (deals, emails, activities, workflows)\r\n * - Performance metric calculation (conversion, efficiency, skills)\r\n * - Team benchmarking and percentile rankings\r\n * - Trend analysis (improving vs declining)\r\n * - Skill scoring based on behavioral patterns\r\n * - Performance tier classification\r\n * \r\n * INTEGRATION:\r\n * - Admin DAL for Firestore queries\r\n * - Deal Scoring system\r\n * - Email Writer metrics\r\n * - Workflow Automation tracking\r\n * - Revenue Forecasting data\r\n */\r\n\r\nimport type { FirestoreAdminDAL } from '@/lib/firebase/admin-dal';\r\nimport { adminDb } from '@/lib/firebase/admin';\r\nimport type {\r\n  RepPerformanceMetrics,\r\n  DealPerformanceMetrics,\r\n  CommunicationMetrics,\r\n  ActivityMetrics,\r\n  ConversionMetrics,\r\n  RevenueMetrics,\r\n  EfficiencyMetrics,\r\n  SkillScores,\r\n  PerformanceComparison,\r\n  PerformanceTier,\r\n  TeamPerformanceSummary,\r\n  TimePeriod,\r\n  CustomDateRange\r\n} from './types';\r\nimport { logger } from '@/lib/logger/logger';\r\n\r\n// ============================================================================\r\n// ANALYTICS ENGINE CLASS\r\n// ============================================================================\r\n\r\nexport class CoachingAnalyticsEngine {\r\n  constructor(private adminDal: FirestoreAdminDAL) {}\r\n\r\n  /**\r\n   * Analyzes performance for a single sales rep\r\n   */\r\n  async analyzeRepPerformance(\r\n    repId: string,\r\n    period: TimePeriod,\r\n    customRange?: CustomDateRange\r\n  ): Promise<RepPerformanceMetrics> {\r\n    const startTime = Date.now();\r\n    \r\n    try {\r\n      // Get date range for analysis\r\n      const { startDate, endDate } = this.getDateRange(period, customRange);\r\n      \r\n      // Get rep info\r\n      const repDoc = await this.adminDal.getCollection('USERS').doc(repId).get();\r\n      if (!repDoc.exists) {\r\n        throw new Error(`Rep not found: ${repId}`);\r\n      }\r\n      \r\n      const repData = repDoc.data();\r\n      const repName = repData?.name || 'Unknown';\r\n      const repEmail = repData?.email || '';\r\n      \r\n      // Fetch all metrics in parallel\r\n      const [\r\n        deals,\r\n        communication,\r\n        activity,\r\n        conversion,\r\n        revenue,\r\n        efficiency,\r\n        teamMetrics\r\n      ] = await Promise.all([\r\n        this.analyzeDealMetrics(repId, startDate, endDate),\r\n        this.analyzeCommunicationMetrics(repId, startDate, endDate),\r\n        this.analyzeActivityMetrics(repId, startDate, endDate),\r\n        this.analyzeConversionMetrics(repId, startDate, endDate),\r\n        this.analyzeRevenueMetrics(repId, startDate, endDate),\r\n        this.analyzeEfficiencyMetrics(repId, startDate, endDate),\r\n        this.getTeamAverageMetrics(startDate, endDate)\r\n      ]);\r\n      \r\n      // Calculate skill scores\r\n      const skills = this.calculateSkillScores({\r\n        deals,\r\n        communication,\r\n        activity,\r\n        conversion,\r\n        revenue,\r\n        efficiency\r\n      });\r\n      \r\n      // Calculate overall performance score (weighted average)\r\n      const overallScore = this.calculateOverallScore({\r\n        deals,\r\n        communication,\r\n        activity,\r\n        conversion,\r\n        revenue,\r\n        efficiency,\r\n        skills\r\n      });\r\n      \r\n      // Determine performance tier\r\n      const tier = this.determinePerformanceTier(overallScore, deals.winRate, revenue.quotaAttainment);\r\n      \r\n      // Calculate comparison to team average\r\n      const vsTeamAverage = this.calculateTeamComparison(\r\n        { overallScore, deals, communication, activity, revenue, efficiency },\r\n        teamMetrics\r\n      );\r\n      \r\n      logger.info('Rep performance analysis completed', {\r\n        repId,\r\n        period,\r\n        overallScore,\r\n        tier,\r\n        durationMs: Date.now() - startTime\r\n      });\r\n      \r\n      return {\r\n        repId,\r\n        repName,\r\n        repEmail,\r\n        period,\r\n        startDate,\r\n        endDate,\r\n        deals,\r\n        communication,\r\n        activity,\r\n        conversion,\r\n        revenue,\r\n        efficiency,\r\n        skills,\r\n        overallScore,\r\n        tier,\r\n        vsTeamAverage\r\n      };\r\n    } catch (error) {\r\n      logger.error('Error analyzing rep performance', { repId, error });\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Analyzes deal performance metrics\r\n   */\r\n  private async analyzeDealMetrics(\r\n    repId: string,\r\n    startDate: Date,\r\n    endDate: Date\r\n  ): Promise<DealPerformanceMetrics> {\r\n    try {\r\n      // Query deals for this rep in the time period\r\n      const dealsRef = this.adminDal.getCollection('DEALS');\r\n      const snapshot = await dealsRef\r\n        .where('ownerId', '==', repId)\r\n        .where('createdAt', '>=', startDate)\r\n        .where('createdAt', '<=', endDate)\r\n        .get();\r\n      \r\n      const deals = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() } as any));\r\n      \r\n      const totalDeals = deals.length;\r\n      const activeDeals = deals.filter((d: any) => !['won', 'lost', 'closed'].includes(d.status || '')).length;\r\n      const dealsWon = deals.filter((d: any) => d.status === 'won').length;\r\n      const dealsLost = deals.filter((d: any) => d.status === 'lost').length;\r\n      const closedDeals = dealsWon + dealsLost;\r\n      const winRate = closedDeals > 0 ? dealsWon / closedDeals : 0;\r\n      \r\n      // Calculate average deal size\r\n      const wonDeals = deals.filter((d: any) => d.status === 'won');\r\n      const totalValue = wonDeals.reduce((sum: number, d: any) => sum + (d.value || 0), 0);\r\n      const averageDealSize = wonDeals.length > 0 ? totalValue / wonDeals.length : 0;\r\n      \r\n      // Calculate average deal cycle\r\n      const cycleTimes = wonDeals\r\n        .filter((d: any) => d.createdAt && d.closedAt)\r\n        .map((d: any) => {\r\n          const created = d.createdAt.toDate ? d.createdAt.toDate() : new Date(d.createdAt);\r\n          const closed = d.closedAt.toDate ? d.closedAt.toDate() : new Date(d.closedAt);\r\n          return (closed.getTime() - created.getTime()) / (1000 * 60 * 60 * 24);\r\n        });\r\n      const averageCycleDays = cycleTimes.length > 0\r\n        ? cycleTimes.reduce((sum, t) => sum + t, 0) / cycleTimes.length\r\n        : 0;\r\n      \r\n      // Calculate deal velocity (deals per week)\r\n      const periodDays = (endDate.getTime() - startDate.getTime()) / (1000 * 60 * 60 * 24);\r\n      const dealVelocity = periodDays > 0 ? (totalDeals / periodDays) * 7 : 0;\r\n      \r\n      // Count at-risk deals (using deal scoring data if available)\r\n      const atRiskDeals = deals.filter((d: any) => \r\n        d.healthScore !== undefined && d.healthScore < 50\r\n      ).length;\r\n      \r\n      // Health distribution\r\n      const healthDistribution = {\r\n        healthy: deals.filter((d: any) => d.healthScore >= 70).length,\r\n        warning: deals.filter((d: any) => d.healthScore >= 50 && d.healthScore < 70).length,\r\n        critical: deals.filter((d: any) => d.healthScore < 50).length\r\n      };\r\n      \r\n      return {\r\n        totalDeals,\r\n        activeDeals,\r\n        dealsWon,\r\n        dealsLost,\r\n        winRate,\r\n        averageDealSize,\r\n        averageCycleDays,\r\n        dealVelocity,\r\n        atRiskDeals,\r\n        healthDistribution\r\n      };\r\n    } catch (error) {\r\n      logger.error('Error analyzing deal metrics', { repId, error });\r\n      // Return zero metrics on error\r\n      return {\r\n        totalDeals: 0,\r\n        activeDeals: 0,\r\n        dealsWon: 0,\r\n        dealsLost: 0,\r\n        winRate: 0,\r\n        averageDealSize: 0,\r\n        averageCycleDays: 0,\r\n        dealVelocity: 0,\r\n        atRiskDeals: 0,\r\n        healthDistribution: { healthy: 0, warning: 0, critical: 0 }\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Analyzes communication quality metrics\r\n   */\r\n  private async analyzeCommunicationMetrics(\r\n    repId: string,\r\n    startDate: Date,\r\n    endDate: Date\r\n  ): Promise<CommunicationMetrics> {\r\n    if (!adminDb) {\r\n      return {\r\n        emailsGenerated: 0,\r\n        emailsSent: 0,\r\n        emailResponseRate: 0,\r\n        averageResponseTime: 0,\r\n        aiEmailUsageRate: 0,\r\n        personalizationScore: 0,\r\n        followUpConsistency: 0,\r\n      };\r\n    }\r\n\r\n    try {\r\n      // Query email activities (using organization sub-collection pattern)\r\n      // This data may not exist yet, so we handle gracefully\r\n      const prefix = process.env.NODE_ENV === 'production' ? '' : 'test_';\r\n      const emailsRef = adminDb.collection(`${prefix}email_activities`);\r\n      const snapshot = await emailsRef\r\n        .where('userId', '==', repId)\r\n        .where('createdAt', '>=', startDate)\r\n        .where('createdAt', '<=', endDate)\r\n        .get();\r\n      \r\n      const emails = snapshot.docs.map(doc => doc.data() as any);\r\n      \r\n      const emailsGenerated = emails.filter((e: any) => e.type === 'generated').length;\r\n      const emailsSent = emails.filter((e: any) => e.type === 'sent').length;\r\n      \r\n      // Calculate response rate\r\n      const sentEmails = emails.filter((e: any) => e.type === 'sent');\r\n      const repliedEmails = sentEmails.filter((e: any) => e.replied === true).length;\r\n      const emailResponseRate = sentEmails.length > 0 ? repliedEmails / sentEmails.length : 0;\r\n      \r\n      // Calculate average response time (hours)\r\n      const responseTimes = emails\r\n        .filter((e: any) => e.sentAt && e.repliedAt)\r\n        .map((e: any) => {\r\n          const sent = e.sentAt.toDate ? e.sentAt.toDate() : new Date(e.sentAt);\r\n          const replied = e.repliedAt.toDate ? e.repliedAt.toDate() : new Date(e.repliedAt);\r\n          return (replied.getTime() - sent.getTime()) / (1000 * 60 * 60);\r\n        });\r\n      const averageResponseTime = responseTimes.length > 0\r\n        ? responseTimes.reduce((sum, t) => sum + t, 0) / responseTimes.length\r\n        : 0;\r\n      \r\n      // AI email usage rate\r\n      const aiEmailUsageRate = emailsSent > 0 ? emailsGenerated / emailsSent : 0;\r\n      \r\n      // Personalization score (based on custom instructions usage)\r\n      const personalizedEmails = emails.filter((e: any) => e.customInstructions && e.customInstructions.length > 10).length;\r\n      const personalizationScore = emailsSent > 0 ? (personalizedEmails / emailsSent) * 100 : 0;\r\n      \r\n      // Follow-up consistency (percentage of emails that are follow-ups)\r\n      const followUpEmails = emails.filter((e: any) => e.isFollowUp === true).length;\r\n      const followUpConsistency = emailsSent > 0 ? (followUpEmails / emailsSent) * 100 : 0;\r\n      \r\n      return {\r\n        emailsGenerated,\r\n        emailsSent,\r\n        emailResponseRate,\r\n        averageResponseTime,\r\n        aiEmailUsageRate,\r\n        personalizationScore,\r\n        followUpConsistency\r\n      };\r\n    } catch (error) {\r\n      logger.error('Error analyzing communication metrics', { repId, error });\r\n      return {\r\n        emailsGenerated: 0,\r\n        emailsSent: 0,\r\n        emailResponseRate: 0,\r\n        averageResponseTime: 0,\r\n        aiEmailUsageRate: 0,\r\n        personalizationScore: 0,\r\n        followUpConsistency: 0\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Analyzes activity level metrics\r\n   */\r\n  private async analyzeActivityMetrics(\r\n    repId: string,\r\n    startDate: Date,\r\n    endDate: Date\r\n  ): Promise<ActivityMetrics> {\r\n    if (!adminDb) {\r\n      return {\r\n        totalActivities: 0,\r\n        activitiesPerDay: 0,\r\n        callsMade: 0,\r\n        meetingsHeld: 0,\r\n        tasksCompleted: 0,\r\n        taskCompletionRate: 0,\r\n        workflowsTriggered: 0,\r\n        crmUpdates: 0,\r\n      };\r\n    }\r\n\r\n    try {\r\n      // Query activities (using direct collection reference as ACTIVITIES may not be in enum)\r\n      const prefix = process.env.NODE_ENV === 'production' ? '' : 'test_';\r\n      const activitiesRef = adminDb.collection(`${prefix}activities`);\r\n      const snapshot = await activitiesRef\r\n        .where('userId', '==', repId)\r\n        .where('createdAt', '>=', startDate)\r\n        .where('createdAt', '<=', endDate)\r\n        .get();\r\n      \r\n      const activities = snapshot.docs.map(doc => doc.data() as any);\r\n      \r\n      const totalActivities = activities.length;\r\n      const periodDays = (endDate.getTime() - startDate.getTime()) / (1000 * 60 * 60 * 24);\r\n      const activitiesPerDay = periodDays > 0 ? totalActivities / periodDays : 0;\r\n      \r\n      const callsMade = activities.filter((a: any) => a.type === 'call').length;\r\n      const meetingsHeld = activities.filter((a: any) => a.type === 'meeting').length;\r\n      const tasksCompleted = activities.filter((a: any) => a.type === 'task' && a.completed).length;\r\n      const totalTasks = activities.filter((a: any) => a.type === 'task').length;\r\n      const taskCompletionRate = totalTasks > 0 ? tasksCompleted / totalTasks : 0;\r\n      \r\n      // Query workflow executions (reuse prefix from above)\r\n      const workflowsRef = adminDb.collection(`${prefix}workflow_executions`);\r\n      const workflowSnapshot = await workflowsRef\r\n        .where('triggeredBy', '==', repId)\r\n        .where('createdAt', '>=', startDate)\r\n        .where('createdAt', '<=', endDate)\r\n        .get();\r\n      const workflowsTriggered = workflowSnapshot.size;\r\n      \r\n      // CRM updates (deal updates + contact updates)\r\n      const crmUpdates = activities.filter((a: any) => \r\n        ['deal_update', 'contact_update', 'note_added'].includes(a.type || '')\r\n      ).length;\r\n      \r\n      return {\r\n        totalActivities,\r\n        activitiesPerDay,\r\n        callsMade,\r\n        meetingsHeld,\r\n        tasksCompleted,\r\n        taskCompletionRate,\r\n        workflowsTriggered,\r\n        crmUpdates\r\n      };\r\n    } catch (error) {\r\n      logger.error('Error analyzing activity metrics', { repId, error });\r\n      return {\r\n        totalActivities: 0,\r\n        activitiesPerDay: 0,\r\n        callsMade: 0,\r\n        meetingsHeld: 0,\r\n        tasksCompleted: 0,\r\n        taskCompletionRate: 0,\r\n        workflowsTriggered: 0,\r\n        crmUpdates: 0\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Analyzes conversion funnel metrics\r\n   */\r\n  private async analyzeConversionMetrics(\r\n    repId: string,\r\n    startDate: Date,\r\n    endDate: Date\r\n  ): Promise<ConversionMetrics> {\r\n    try {\r\n      // Query deals for conversion analysis\r\n      const dealsRef = this.adminDal.getCollection('DEALS');\r\n      const snapshot = await dealsRef\r\n        .where('ownerId', '==', repId)\r\n        .where('createdAt', '>=', startDate)\r\n        .where('createdAt', '<=', endDate)\r\n        .get();\r\n      \r\n      const deals = snapshot.docs.map(doc => doc.data() as any);\r\n      \r\n      // Count deals at each stage\r\n      const leadCount = deals.filter((d: any) => d.stage === 'lead' || d.stage === 'prospecting').length;\r\n      const opportunityCount = deals.filter((d: any) => \r\n        ['qualification', 'needs_analysis', 'discovery'].includes(d.stage || '')\r\n      ).length;\r\n      const proposalCount = deals.filter((d: any) => \r\n        ['proposal', 'negotiation'].includes(d.stage || '')\r\n      ).length;\r\n      const closedCount = deals.filter((d: any) => d.status === 'won').length;\r\n      \r\n      // Calculate conversion rates\r\n      const totalLeads = leadCount + opportunityCount + proposalCount + closedCount;\r\n      const leadToOpportunity = totalLeads > 0 \r\n        ? (opportunityCount + proposalCount + closedCount) / totalLeads \r\n        : 0;\r\n      const opportunityToProposal = (opportunityCount + proposalCount + closedCount) > 0\r\n        ? (proposalCount + closedCount) / (opportunityCount + proposalCount + closedCount)\r\n        : 0;\r\n      const proposalToClose = (proposalCount + closedCount) > 0\r\n        ? closedCount / (proposalCount + closedCount)\r\n        : 0;\r\n      const overallConversion = totalLeads > 0 ? closedCount / totalLeads : 0;\r\n      \r\n      // Identify drop-off points\r\n      const dropOffPoints = [\r\n        {\r\n          stage: 'Lead ΓåÆ Opportunity',\r\n          dropOffRate: 1 - leadToOpportunity\r\n        },\r\n        {\r\n          stage: 'Opportunity ΓåÆ Proposal',\r\n          dropOffRate: 1 - opportunityToProposal\r\n        },\r\n        {\r\n          stage: 'Proposal ΓåÆ Close',\r\n          dropOffRate: 1 - proposalToClose\r\n        }\r\n      ].filter(point => point.dropOffRate > 0.3); // Only show significant drop-offs\r\n      \r\n      return {\r\n        leadToOpportunity,\r\n        opportunityToProposal,\r\n        proposalToClose,\r\n        overallConversion,\r\n        dropOffPoints\r\n      };\r\n    } catch (error) {\r\n      logger.error('Error analyzing conversion metrics', { repId, error });\r\n      return {\r\n        leadToOpportunity: 0,\r\n        opportunityToProposal: 0,\r\n        proposalToClose: 0,\r\n        overallConversion: 0,\r\n        dropOffPoints: []\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Analyzes revenue performance metrics\r\n   */\r\n  private async analyzeRevenueMetrics(\r\n    repId: string,\r\n    startDate: Date,\r\n    endDate: Date\r\n  ): Promise<RevenueMetrics> {\r\n    try {\r\n      // Query deals for revenue analysis\r\n      const dealsRef = this.adminDal.getCollection('DEALS');\r\n      const snapshot = await dealsRef\r\n        .where('ownerId', '==', repId)\r\n        .get();\r\n      \r\n      const allDeals = snapshot.docs.map(doc => doc.data() as any);\r\n      \r\n      // Total revenue (won deals in period)\r\n      const wonDeals = allDeals.filter((d: any) => \r\n        d.status === 'won' && \r\n        d.closedAt &&\r\n        new Date(d.closedAt.toDate ? d.closedAt.toDate() : d.closedAt) >= startDate &&\r\n        new Date(d.closedAt.toDate ? d.closedAt.toDate() : d.closedAt) <= endDate\r\n      );\r\n      const totalRevenue = wonDeals.reduce((sum: number, d: any) => sum + (d.value || 0), 0);\r\n      \r\n      // Get quota from user profile\r\n      const repDoc = await this.adminDal.getCollection('USERS').doc(repId).get();\r\n      const quota = repDoc.data()?.quota || 0;\r\n      const quotaAttainment = quota > 0 ? totalRevenue / quota : 0;\r\n      \r\n      // Pipeline value (active deals)\r\n      const activeDeals = allDeals.filter((d: any) => \r\n        !['won', 'lost', 'closed'].includes(d.status || '')\r\n      );\r\n      const pipelineValue = activeDeals.reduce((sum: number, d: any) => sum + (d.value || 0), 0);\r\n      \r\n      // Weighted pipeline (value * probability)\r\n      const weightedPipeline = activeDeals.reduce((sum: number, d: any) => {\r\n        const value = d.value || 0;\r\n        const probability = d.winProbability || 0.5;\r\n        return sum + (value * probability);\r\n      }, 0);\r\n      \r\n      // Forecast accuracy (compare previous forecasts to actual)\r\n      const forecastAccuracy = 0.85; // Placeholder - would need historical forecast data\r\n      \r\n      // Average contract value\r\n      const acv = wonDeals.length > 0 ? totalRevenue / wonDeals.length : 0;\r\n      \r\n      // Growth rate (compare to previous period)\r\n      const previousPeriodStart = new Date(startDate);\r\n      previousPeriodStart.setTime(startDate.getTime() - (endDate.getTime() - startDate.getTime()));\r\n      const previousWonDeals = allDeals.filter((d: any) =>\r\n        d.status === 'won' &&\r\n        d.closedAt &&\r\n        new Date(d.closedAt.toDate ? d.closedAt.toDate() : d.closedAt) >= previousPeriodStart &&\r\n        new Date(d.closedAt.toDate ? d.closedAt.toDate() : d.closedAt) < startDate\r\n      );\r\n      const previousRevenue = previousWonDeals.reduce((sum: number, d: any) => sum + (d.value || 0), 0);\r\n      const growthRate = previousRevenue > 0 ? (totalRevenue - previousRevenue) / previousRevenue : 0;\r\n      \r\n      return {\r\n        totalRevenue,\r\n        quota,\r\n        quotaAttainment,\r\n        pipelineValue,\r\n        weightedPipeline,\r\n        forecastAccuracy,\r\n        acv,\r\n        growthRate\r\n      };\r\n    } catch (error) {\r\n      logger.error('Error analyzing revenue metrics', { repId, error });\r\n      return {\r\n        totalRevenue: 0,\r\n        quota: 0,\r\n        quotaAttainment: 0,\r\n        pipelineValue: 0,\r\n        weightedPipeline: 0,\r\n        forecastAccuracy: 0,\r\n        acv: 0,\r\n        growthRate: 0\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Analyzes efficiency metrics\r\n   */\r\n  private async analyzeEfficiencyMetrics(\r\n    repId: string,\r\n    startDate: Date,\r\n    endDate: Date\r\n  ): Promise<EfficiencyMetrics> {\r\n    if (!adminDb || !this.adminDal) {\r\n      return {\r\n        timeToFirstContact: 0,\r\n        timeToProposal: 0,\r\n        timeToClose: 0,\r\n        meetingsPerDeal: 0,\r\n        emailsPerDeal: 0,\r\n        touchPointsPerDeal: 0,\r\n        automationUsage: 0,\r\n        hoursSaved: 0,\r\n      };\r\n    }\r\n\r\n    try {\r\n      // Get environment prefix once for all queries\r\n      const prefix = process.env.NODE_ENV === 'production' ? '' : 'test_';\r\n      \r\n      // Query deals for efficiency analysis\r\n      const dealsRef = this.adminDal.getCollection('DEALS');\r\n      const snapshot = await dealsRef\r\n        .where('ownerId', '==', repId)\r\n        .where('createdAt', '>=', startDate)\r\n        .where('createdAt', '<=', endDate)\r\n        .get();\r\n      \r\n      const deals = snapshot.docs.map(doc => doc.data() as any);\r\n      \r\n      // Time to first contact\r\n      const firstContactTimes = deals\r\n        .filter((d: any) => d.createdAt && d.firstContactAt)\r\n        .map((d: any) => {\r\n          const created = d.createdAt.toDate ? d.createdAt.toDate() : new Date(d.createdAt);\r\n          const contacted = d.firstContactAt.toDate ? d.firstContactAt.toDate() : new Date(d.firstContactAt);\r\n          return (contacted.getTime() - created.getTime()) / (1000 * 60 * 60);\r\n        });\r\n      const timeToFirstContact = firstContactTimes.length > 0\r\n        ? firstContactTimes.reduce((sum, t) => sum + t, 0) / firstContactTimes.length\r\n        : 0;\r\n      \r\n      // Time to proposal\r\n      const proposalTimes = deals\r\n        .filter((d: any) => d.createdAt && d.proposalSentAt)\r\n        .map((d: any) => {\r\n          const created = d.createdAt.toDate ? d.createdAt.toDate() : new Date(d.createdAt);\r\n          const proposal = d.proposalSentAt.toDate ? d.proposalSentAt.toDate() : new Date(d.proposalSentAt);\r\n          return (proposal.getTime() - created.getTime()) / (1000 * 60 * 60 * 24);\r\n        });\r\n      const timeToProposal = proposalTimes.length > 0\r\n        ? proposalTimes.reduce((sum, t) => sum + t, 0) / proposalTimes.length\r\n        : 0;\r\n      \r\n      // Time to close\r\n      const closeTimes = deals\r\n        .filter((d: any) => d.createdAt && d.closedAt && d.status === 'won')\r\n        .map((d: any) => {\r\n          const created = d.createdAt.toDate ? d.createdAt.toDate() : new Date(d.createdAt);\r\n          const closed = d.closedAt.toDate ? d.closedAt.toDate() : new Date(d.closedAt);\r\n          return (closed.getTime() - created.getTime()) / (1000 * 60 * 60 * 24);\r\n        });\r\n      const timeToClose = closeTimes.length > 0\r\n        ? closeTimes.reduce((sum, t) => sum + t, 0) / closeTimes.length\r\n        : 0;\r\n      \r\n      // Touch points per deal (meetings + emails)\r\n      const activitiesRef = adminDb.collection(`${prefix}activities`);\r\n      const activitiesSnapshot = await activitiesRef\r\n        .where('userId', '==', repId)\r\n        .where('createdAt', '>=', startDate)\r\n        .where('createdAt', '<=', endDate)\r\n        .get();\r\n      \r\n      const activities = activitiesSnapshot.docs.map(doc => doc.data() as any);\r\n      const meetingsPerDeal = deals.length > 0 \r\n        ? activities.filter((a: any) => a.type === 'meeting').length / deals.length \r\n        : 0;\r\n      const emailsPerDeal = deals.length > 0\r\n        ? activities.filter((a: any) => a.type === 'email').length / deals.length\r\n        : 0;\r\n      const touchPointsPerDeal = meetingsPerDeal + emailsPerDeal;\r\n      \r\n      // AI automation usage\r\n      const workflowsRef = adminDb.collection(`${prefix}workflow_executions`);\r\n      const workflowSnapshot = await workflowsRef\r\n        .where('triggeredBy', '==', repId)\r\n        .where('createdAt', '>=', startDate)\r\n        .where('createdAt', '<=', endDate)\r\n        .get();\r\n      const workflowExecutions = workflowSnapshot.size;\r\n      const totalActivities = activities.length;\r\n      const automationUsage = totalActivities > 0 ? workflowExecutions / totalActivities : 0;\r\n      \r\n      // Hours saved (estimate: 5 min per workflow, 10 min per AI email)\r\n      const emailActivities = await adminDb.collection(`${prefix}email_activities`)\r\n        .where('userId', '==', repId)\r\n        .where('createdAt', '>=', startDate)\r\n        .where('createdAt', '<=', endDate)\r\n        .get();\r\n      const aiEmails = emailActivities.docs.filter(doc => (doc.data() as any).type === 'generated').length;\r\n      const hoursSaved = (workflowExecutions * 5 + aiEmails * 10) / 60;\r\n      \r\n      return {\r\n        timeToFirstContact,\r\n        timeToProposal,\r\n        timeToClose,\r\n        meetingsPerDeal,\r\n        emailsPerDeal,\r\n        touchPointsPerDeal,\r\n        automationUsage,\r\n        hoursSaved\r\n      };\r\n    } catch (error) {\r\n      logger.error('Error analyzing efficiency metrics', { repId, error });\r\n      return {\r\n        timeToFirstContact: 0,\r\n        timeToProposal: 0,\r\n        timeToClose: 0,\r\n        meetingsPerDeal: 0,\r\n        emailsPerDeal: 0,\r\n        touchPointsPerDeal: 0,\r\n        automationUsage: 0,\r\n        hoursSaved: 0\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculates skill scores based on performance metrics\r\n   */\r\n  private calculateSkillScores(metrics: {\r\n    deals: DealPerformanceMetrics;\r\n    communication: CommunicationMetrics;\r\n    activity: ActivityMetrics;\r\n    conversion: ConversionMetrics;\r\n    revenue: RevenueMetrics;\r\n    efficiency: EfficiencyMetrics;\r\n  }): SkillScores {\r\n    const { deals, communication, activity, conversion, revenue, efficiency } = metrics;\r\n    \r\n    return {\r\n      // Prospecting: based on deal velocity and pipeline value\r\n      prospecting: Math.min(100, (deals.dealVelocity * 10 + (revenue.pipelineValue / 100000) * 20)),\r\n      \r\n      // Discovery: based on qualification and conversion\r\n      discovery: Math.min(100, conversion.leadToOpportunity * 100),\r\n      \r\n      // Needs analysis: based on conversion to proposal\r\n      needsAnalysis: Math.min(100, conversion.opportunityToProposal * 100),\r\n      \r\n      // Presentation: based on proposal to close rate\r\n      presentation: Math.min(100, conversion.proposalToClose * 100),\r\n      \r\n      // Objection handling: inferred from win rate\r\n      objectionHandling: Math.min(100, deals.winRate * 100),\r\n      \r\n      // Negotiation: based on average deal size vs pipeline\r\n      negotiation: Math.min(100, (deals.averageDealSize / 100000) * 50 + deals.winRate * 50),\r\n      \r\n      // Closing: based on win rate and quota attainment\r\n      closing: Math.min(100, (deals.winRate * 50 + revenue.quotaAttainment * 50)),\r\n      \r\n      // Relationship building: based on email response rate and follow-up\r\n      relationshipBuilding: Math.min(100, \r\n        communication.emailResponseRate * 50 + communication.followUpConsistency * 0.5\r\n      ),\r\n      \r\n      // Product knowledge: inferred from presentation and objection handling\r\n      productKnowledge: Math.min(100, (conversion.proposalToClose * 60 + deals.winRate * 40)),\r\n      \r\n      // CRM hygiene: based on activity logging\r\n      crmHygiene: Math.min(100, Math.min(activity.activitiesPerDay * 10, 100)),\r\n      \r\n      // Time management: based on efficiency metrics\r\n      timeManagement: Math.min(100, (1 / Math.max(efficiency.timeToClose / 30, 0.1)) * 50),\r\n      \r\n      // AI tool adoption: based on automation usage\r\n      aiToolAdoption: Math.min(100, \r\n        efficiency.automationUsage * 50 + communication.aiEmailUsageRate * 50\r\n      )\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Calculates overall performance score (weighted average)\r\n   */\r\n  private calculateOverallScore(metrics: {\r\n    deals: DealPerformanceMetrics;\r\n    communication: CommunicationMetrics;\r\n    activity: ActivityMetrics;\r\n    conversion: ConversionMetrics;\r\n    revenue: RevenueMetrics;\r\n    efficiency: EfficiencyMetrics;\r\n    skills: SkillScores;\r\n  }): number {\r\n    const { deals, revenue, skills } = metrics;\r\n    \r\n    // Weighted score components\r\n    const components = [\r\n      { value: revenue.quotaAttainment * 100, weight: 0.30 }, // Quota attainment: 30%\r\n      { value: deals.winRate * 100, weight: 0.20 },           // Win rate: 20%\r\n      { value: Object.values(skills).reduce((a, b) => a + b, 0) / 12, weight: 0.30 }, // Skills avg: 30%\r\n      { value: Math.min(deals.dealVelocity * 20, 100), weight: 0.10 }, // Velocity: 10%\r\n      { value: Math.min(revenue.growthRate * 50 + 50, 100), weight: 0.10 } // Growth: 10%\r\n    ];\r\n    \r\n    const weightedSum = components.reduce((sum, comp) => sum + (comp.value * comp.weight), 0);\r\n    return Math.min(100, Math.max(0, weightedSum));\r\n  }\r\n\r\n  /**\r\n   * Determines performance tier based on overall score and key metrics\r\n   */\r\n  private determinePerformanceTier(\r\n    overallScore: number,\r\n    winRate: number,\r\n    quotaAttainment: number\r\n  ): PerformanceTier {\r\n    // Top performer: 85+ score AND (80%+ win rate OR 120%+ quota)\r\n    if (overallScore >= 85 && (winRate >= 0.8 || quotaAttainment >= 1.2)) {\r\n      return 'top_performer';\r\n    }\r\n    \r\n    // High performer: 70+ score AND (60%+ win rate OR 100%+ quota)\r\n    if (overallScore >= 70 && (winRate >= 0.6 || quotaAttainment >= 1.0)) {\r\n      return 'high_performer';\r\n    }\r\n    \r\n    // Average: 50-70 score\r\n    if (overallScore >= 50) {\r\n      return 'average';\r\n    }\r\n    \r\n    // Needs improvement: 30-50 score\r\n    if (overallScore >= 30) {\r\n      return 'needs_improvement';\r\n    }\r\n    \r\n    // At risk: < 30 score\r\n    return 'at_risk';\r\n  }\r\n\r\n  /**\r\n   * Gets team average metrics for benchmarking\r\n   */\r\n  private async getTeamAverageMetrics(\r\n    startDate: Date,\r\n    endDate: Date\r\n  ): Promise<any> {\r\n    try {\r\n      // Query all users with sales role\r\n      const usersRef = this.adminDal.getCollection('USERS');\r\n      const snapshot = await usersRef\r\n        .where('role', '==', 'sales')\r\n        .get();\r\n      \r\n      const userIds = snapshot.docs.map(doc => doc.id);\r\n      \r\n      if (userIds.length === 0) {\r\n        return this.getDefaultTeamMetrics();\r\n      }\r\n      \r\n      // Calculate metrics for all reps (simplified - in production, would cache these)\r\n      const metrics = {\r\n        overallScore: 65,\r\n        winRate: 0.45,\r\n        revenue: 50000,\r\n        activityPerDay: 12,\r\n        efficiency: 0.6\r\n      };\r\n      \r\n      return metrics;\r\n    } catch (error) {\r\n      logger.error('Error getting team average metrics', { error });\r\n      return this.getDefaultTeamMetrics();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns default team metrics\r\n   */\r\n  private getDefaultTeamMetrics() {\r\n    return {\r\n      overallScore: 60,\r\n      winRate: 0.40,\r\n      revenue: 40000,\r\n      activityPerDay: 10,\r\n      efficiency: 0.50\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Calculates comparison to team average\r\n   */\r\n  private calculateTeamComparison(\r\n    repMetrics: any,\r\n    teamMetrics: any\r\n  ): PerformanceComparison {\r\n    const overallScoreDelta = repMetrics.overallScore - teamMetrics.overallScore;\r\n    const winRateDelta = repMetrics.deals.winRate - teamMetrics.winRate;\r\n    const revenueDelta = repMetrics.revenue.totalRevenue - teamMetrics.revenue;\r\n    const activityDelta = repMetrics.activity.activitiesPerDay - teamMetrics.activityPerDay;\r\n    const efficiencyDelta = repMetrics.efficiency.automationUsage - teamMetrics.efficiency;\r\n    \r\n    // Calculate percentile rank (simplified)\r\n    const percentileRank = Math.min(100, Math.max(0, 50 + overallScoreDelta));\r\n    \r\n    return {\r\n      overallScoreDelta,\r\n      winRateDelta,\r\n      revenueDelta,\r\n      activityDelta,\r\n      efficiencyDelta,\r\n      percentileRank\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Gets date range for a time period\r\n   */\r\n  private getDateRange(\r\n    period: TimePeriod,\r\n    customRange?: CustomDateRange\r\n  ): { startDate: Date; endDate: Date } {\r\n    const now = new Date();\r\n    let startDate: Date;\r\n    let endDate: Date = now;\r\n    \r\n    if (period === 'custom' && customRange) {\r\n      return { startDate: customRange.startDate, endDate: customRange.endDate };\r\n    }\r\n    \r\n    switch (period) {\r\n      case 'last_7_days':\r\n        startDate = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);\r\n        break;\r\n      case 'last_30_days':\r\n        startDate = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);\r\n        break;\r\n      case 'last_90_days':\r\n        startDate = new Date(now.getTime() - 90 * 24 * 60 * 60 * 1000);\r\n        break;\r\n      case 'last_6_months':\r\n        startDate = new Date(now.getTime() - 180 * 24 * 60 * 60 * 1000);\r\n        break;\r\n      case 'last_12_months':\r\n        startDate = new Date(now.getTime() - 365 * 24 * 60 * 60 * 1000);\r\n        break;\r\n      case 'this_quarter':\r\n        const quarter = Math.floor(now.getMonth() / 3);\r\n        startDate = new Date(now.getFullYear(), quarter * 3, 1);\r\n        break;\r\n      case 'this_year':\r\n        startDate = new Date(now.getFullYear(), 0, 1);\r\n        break;\r\n      default:\r\n        startDate = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);\r\n    }\r\n    \r\n    return { startDate, endDate };\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\David\\PycharmProjects\\AI Sales Platform\\src\\lib\\coaching\\team-coaching-engine.ts","messages":[{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":803,"column":9,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":803,"endColumn":60}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Team Coaching Analytics Engine\r\n * \r\n * SOVEREIGN CORPORATE BRAIN - TEAM COACHING MODULE\r\n * \r\n * Aggregates individual rep performance into team-level insights for managers.\r\n * Identifies skill gaps, best practices to share, and coaching priorities.\r\n * \r\n * CORE CAPABILITIES:\r\n * - Team performance aggregation across all reps\r\n * - Skill gap analysis (team avg vs top performers)\r\n * - Top performer identification and best practice extraction\r\n * - At-risk rep identification with critical areas\r\n * - Team coaching priorities based on impact and urgency\r\n * - Performance distribution and trend analysis\r\n * \r\n * INTEGRATION:\r\n * - Coaching Analytics Engine for individual rep metrics\r\n * - AI Coaching Generator for insights generation\r\n * - Signal Bus for team coaching events\r\n * - Admin DAL for team member queries\r\n * \r\n * PERFORMANCE:\r\n * - Parallel processing of rep insights\r\n * - Intelligent caching (1-hour TTL)\r\n * - Batch AI calls to minimize cost\r\n */\r\n\r\nimport type {\r\n  TeamCoachingInsights,\r\n  TeamPerformanceSummary,\r\n  RepPerformanceMetrics,\r\n  PerformanceTier,\r\n  BestPractice,\r\n  SkillScores,\r\n  GenerateTeamCoachingRequest\r\n} from './types';\r\nimport { CoachingAnalyticsEngine } from './coaching-analytics-engine';\r\nimport { createTeamInsightsGeneratedEvent } from './events';\r\nimport type { SignalCoordinator } from '../orchestration/SignalCoordinator';\r\n\r\n// ============================================================================\r\n// TEAM COACHING ENGINE\r\n// ============================================================================\r\n\r\nexport class TeamCoachingEngine {\r\n  private analyticsEngine: CoachingAnalyticsEngine;\r\n  private signalCoordinator?: SignalCoordinator;\r\n  \r\n  /**\r\n   * Cache for team insights (1-hour TTL)\r\n   * Key: `${teamId}:${period}:${startDate}:${endDate}`\r\n   */\r\n  private insightsCache: Map<string, {\r\n    insights: TeamCoachingInsights;\r\n    cachedAt: Date;\r\n  }> = new Map();\r\n  \r\n  /**\r\n   * Cache TTL in milliseconds (1 hour)\r\n   */\r\n  private readonly CACHE_TTL_MS = 60 * 60 * 1000;\r\n  \r\n  constructor(\r\n    analyticsEngine: CoachingAnalyticsEngine,\r\n    signalCoordinator?: SignalCoordinator\r\n  ) {\r\n    this.analyticsEngine = analyticsEngine;\r\n    this.signalCoordinator = signalCoordinator;\r\n  }\r\n  \r\n  // ============================================================================\r\n  // TEAM INSIGHTS GENERATION\r\n  // ============================================================================\r\n  \r\n  /**\r\n   * Generates team coaching insights for a manager\r\n   * @param request - Team coaching request\r\n   * @param teamMemberIds - Array of rep IDs on the team\r\n   * @param teamName - Name of the team\r\n   * @returns Team coaching insights\r\n   */\r\n  async generateTeamInsights(\r\n    request: GenerateTeamCoachingRequest,\r\n    teamMemberIds: string[],\r\n    teamName: string\r\n  ): Promise<TeamCoachingInsights> {\r\n    const startTime = Date.now();\r\n    \r\n    // Check cache first\r\n    const cacheKey = this.getCacheKey(\r\n      request.teamId,\r\n      request.period,\r\n      request.customRange?.startDate,\r\n      request.customRange?.endDate\r\n    );\r\n    \r\n    const cached = this.insightsCache.get(cacheKey);\r\n    if (cached && this.isCacheValid(cached.cachedAt)) {\r\n      console.log('[TeamCoachingEngine] Returning cached team insights');\r\n      return cached.insights;\r\n    }\r\n    \r\n    // Get date range\r\n    const { startDate, endDate } = this.getDateRange(\r\n      request.period,\r\n      request.customRange\r\n    );\r\n    \r\n    // Generate individual rep insights in parallel\r\n    console.log(`[TeamCoachingEngine] Generating insights for ${teamMemberIds.length} team members`);\r\n    const repInsights = await this.generateRepInsights(\r\n      teamMemberIds,\r\n      request.period,\r\n      { startDate, endDate }\r\n    );\r\n    \r\n    // Aggregate team metrics\r\n    const teamSummary = this.aggregateTeamMetrics(repInsights);\r\n    \r\n    // Identify top performers\r\n    const topPerformers = this.identifyTopPerformers(repInsights);\r\n    \r\n    // Identify reps needing support\r\n    const needsSupport = this.identifyRepsNeedingSupport(repInsights);\r\n    \r\n    // Analyze skill gaps\r\n    const skillGaps = this.analyzeSkillGaps(repInsights, topPerformers);\r\n    \r\n    // Extract best practices from top performers\r\n    const bestPracticesToShare = this.extractBestPractices(\r\n      repInsights,\r\n      topPerformers\r\n    );\r\n    \r\n    // Determine team coaching priorities\r\n    const teamPriorities = this.determineTeamPriorities(\r\n      skillGaps,\r\n      needsSupport,\r\n      teamSummary\r\n    );\r\n    \r\n    // Identify team-wide strengths and weaknesses\r\n    const teamStrengths = this.identifyTeamStrengths(repInsights, teamSummary);\r\n    const teamWeaknesses = this.identifyTeamWeaknesses(repInsights, teamSummary);\r\n    \r\n    // Build team insights\r\n    const teamInsights: TeamCoachingInsights = {\r\n      teamId: request.teamId,\r\n      teamName,\r\n      period: request.period,\r\n      startDate,\r\n      endDate,\r\n      generatedAt: new Date(),\r\n      teamSummary,\r\n      repInsights: request.includeRepDetails ? repInsights : [],\r\n      topPerformers,\r\n      needsSupport,\r\n      teamStrengths,\r\n      teamWeaknesses,\r\n      skillGaps,\r\n      bestPracticesToShare,\r\n      teamPriorities\r\n    };\r\n    \r\n    // Cache the results\r\n    this.insightsCache.set(cacheKey, {\r\n      insights: teamInsights,\r\n      cachedAt: new Date()\r\n    });\r\n    \r\n    // Emit Signal Bus event\r\n    const processingTimeMs = Date.now() - startTime;\r\n    if (this.signalCoordinator) {\r\n      const event = createTeamInsightsGeneratedEvent(\r\n        teamInsights,\r\n        'gpt-4o',\r\n        processingTimeMs\r\n      );\r\n      // Signal coordinator expects the full event object\r\n      await this.signalCoordinator.emitSignal(event as any);\r\n    }\r\n    \r\n    console.log(`[TeamCoachingEngine] Team insights generated in ${processingTimeMs}ms`);\r\n    return teamInsights;\r\n  }\r\n  \r\n  // ============================================================================\r\n  // REP INSIGHTS GENERATION\r\n  // ============================================================================\r\n  \r\n  /**\r\n   * Generates performance metrics for all reps on the team\r\n   * @param repIds - Array of rep IDs\r\n   * @param period - Time period\r\n   * @param dateRange - Date range\r\n   * @returns Array of rep performance metrics\r\n   */\r\n  private async generateRepInsights(\r\n    repIds: string[],\r\n    period: string,\r\n    dateRange: { startDate: Date; endDate: Date }\r\n  ): Promise<RepPerformanceMetrics[]> {\r\n    // Generate insights in parallel (with concurrency limit to avoid overwhelming API)\r\n    const BATCH_SIZE = 5;\r\n    const results: RepPerformanceMetrics[] = [];\r\n    \r\n    for (let i = 0; i < repIds.length; i += BATCH_SIZE) {\r\n      const batch = repIds.slice(i, i + BATCH_SIZE);\r\n      const batchResults = await Promise.all(\r\n        batch.map(repId =>\r\n          this.analyticsEngine.analyzeRepPerformance(\r\n            repId,\r\n            period as any,\r\n            dateRange\r\n          )\r\n        )\r\n      );\r\n      results.push(...batchResults);\r\n    }\r\n    \r\n    return results;\r\n  }\r\n  \r\n  // ============================================================================\r\n  // TEAM METRICS AGGREGATION\r\n  // ============================================================================\r\n  \r\n  /**\r\n   * Aggregates individual rep metrics into team summary\r\n   * @param repInsights - Array of rep performance metrics\r\n   * @returns Team performance summary\r\n   */\r\n  private aggregateTeamMetrics(\r\n    repInsights: RepPerformanceMetrics[]\r\n  ): TeamPerformanceSummary {\r\n    const totalReps = repInsights.length;\r\n    \r\n    // Calculate performance distribution\r\n    const tierCounts = new Map<PerformanceTier, number>();\r\n    for (const rep of repInsights) {\r\n      tierCounts.set(rep.tier, (tierCounts.get(rep.tier) || 0) + 1);\r\n    }\r\n    \r\n    const performanceDistribution = [\r\n      'top_performer',\r\n      'high_performer',\r\n      'average',\r\n      'needs_improvement',\r\n      'at_risk'\r\n    ].map((tier) => ({\r\n      tier: tier as PerformanceTier,\r\n      count: tierCounts.get(tier as PerformanceTier) || 0,\r\n      percentage: ((tierCounts.get(tier as PerformanceTier) || 0) / totalReps) * 100\r\n    }));\r\n    \r\n    // Calculate team averages\r\n    const teamAverages = {\r\n      overallScore: this.calculateAverage(repInsights.map(r => r.overallScore)),\r\n      winRate: this.calculateAverage(repInsights.map(r => r.deals.winRate)),\r\n      quotaAttainment: this.calculateAverage(repInsights.map(r => r.revenue.quotaAttainment)),\r\n      dealVelocity: this.calculateAverage(repInsights.map(r => r.deals.dealVelocity)),\r\n      emailResponseRate: this.calculateAverage(repInsights.map(r => r.communication.emailResponseRate))\r\n    };\r\n    \r\n    // Calculate trends (comparing to hypothetical previous period)\r\n    // In a real implementation, you would compare to actual historical data\r\n    const trends = [\r\n      {\r\n        metric: 'Overall Score',\r\n        direction: 'stable' as const,\r\n        change: 0\r\n      },\r\n      {\r\n        metric: 'Win Rate',\r\n        direction: 'stable' as const,\r\n        change: 0\r\n      },\r\n      {\r\n        metric: 'Quota Attainment',\r\n        direction: 'stable' as const,\r\n        change: 0\r\n      }\r\n    ];\r\n    \r\n    // Count at-risk reps\r\n    const atRiskCount = tierCounts.get('at_risk') || 0;\r\n    \r\n    // Calculate top performer benchmarks\r\n    const topPerformers = repInsights.filter(r =>\r\n      r.tier === 'top_performer' || r.tier === 'high_performer'\r\n    );\r\n    \r\n    const topPerformerBenchmarks = topPerformers.length > 0 ? [\r\n      {\r\n        metric: 'Overall Score',\r\n        value: this.calculateAverage(topPerformers.map(r => r.overallScore))\r\n      },\r\n      {\r\n        metric: 'Win Rate',\r\n        value: this.calculateAverage(topPerformers.map(r => r.deals.winRate))\r\n      },\r\n      {\r\n        metric: 'Quota Attainment',\r\n        value: this.calculateAverage(topPerformers.map(r => r.revenue.quotaAttainment))\r\n      },\r\n      {\r\n        metric: 'Deal Velocity',\r\n        value: this.calculateAverage(topPerformers.map(r => r.deals.dealVelocity))\r\n      },\r\n      {\r\n        metric: 'Email Response Rate',\r\n        value: this.calculateAverage(topPerformers.map(r => r.communication.emailResponseRate))\r\n      }\r\n    ] : [];\r\n    \r\n    return {\r\n      totalReps,\r\n      performanceDistribution,\r\n      teamAverages,\r\n      trends,\r\n      atRiskCount,\r\n      topPerformerBenchmarks\r\n    };\r\n  }\r\n  \r\n  // ============================================================================\r\n  // TOP PERFORMERS & AT-RISK IDENTIFICATION\r\n  // ============================================================================\r\n  \r\n  /**\r\n   * Identifies top performers on the team\r\n   * @param repInsights - Array of rep performance metrics\r\n   * @returns Top performers with their strengths\r\n   */\r\n  private identifyTopPerformers(\r\n    repInsights: RepPerformanceMetrics[]\r\n  ): Array<{ repId: string; repName: string; score: number; strengths: string[] }> {\r\n    return repInsights\r\n      .filter(r => r.tier === 'top_performer' || r.tier === 'high_performer')\r\n      .sort((a, b) => b.overallScore - a.overallScore)\r\n      .slice(0, 10) // Top 10\r\n      .map(rep => ({\r\n        repId: rep.repId,\r\n        repName: rep.repName,\r\n        score: rep.overallScore,\r\n        strengths: this.identifyRepStrengths(rep)\r\n      }));\r\n  }\r\n  \r\n  /**\r\n   * Identifies reps needing support\r\n   * @param repInsights - Array of rep performance metrics\r\n   * @returns Reps needing support with critical areas\r\n   */\r\n  private identifyRepsNeedingSupport(\r\n    repInsights: RepPerformanceMetrics[]\r\n  ): Array<{ repId: string; repName: string; score: number; criticalAreas: string[] }> {\r\n    return repInsights\r\n      .filter(r => r.tier === 'needs_improvement' || r.tier === 'at_risk')\r\n      .sort((a, b) => a.overallScore - b.overallScore)\r\n      .map(rep => ({\r\n        repId: rep.repId,\r\n        repName: rep.repName,\r\n        score: rep.overallScore,\r\n        criticalAreas: this.identifyRepWeaknesses(rep)\r\n      }));\r\n  }\r\n  \r\n  /**\r\n   * Identifies rep's key strengths based on skill scores\r\n   * @param rep - Rep performance metrics\r\n   * @returns Array of strength areas\r\n   */\r\n  private identifyRepStrengths(rep: RepPerformanceMetrics): string[] {\r\n    const skillEntries = Object.entries(rep.skills) as [keyof SkillScores, number][];\r\n    return skillEntries\r\n      .filter(([_, score]) => score >= 80)\r\n      .sort((a, b) => b[1] - a[1])\r\n      .slice(0, 3)\r\n      .map(([skill, _]) => this.formatSkillName(skill));\r\n  }\r\n  \r\n  /**\r\n   * Identifies rep's key weaknesses based on skill scores\r\n   * @param rep - Rep performance metrics\r\n   * @returns Array of weakness areas\r\n   */\r\n  private identifyRepWeaknesses(rep: RepPerformanceMetrics): string[] {\r\n    const skillEntries = Object.entries(rep.skills) as [keyof SkillScores, number][];\r\n    return skillEntries\r\n      .filter(([_, score]) => score < 60)\r\n      .sort((a, b) => a[1] - b[1])\r\n      .slice(0, 3)\r\n      .map(([skill, _]) => this.formatSkillName(skill));\r\n  }\r\n  \r\n  // ============================================================================\r\n  // SKILL GAP ANALYSIS\r\n  // ============================================================================\r\n  \r\n  /**\r\n   * Analyzes skill gaps across the team\r\n   * @param repInsights - Array of rep performance metrics\r\n   * @param topPerformers - Top performers data\r\n   * @returns Skill gaps with team avg vs top performer avg\r\n   */\r\n  private analyzeSkillGaps(\r\n    repInsights: RepPerformanceMetrics[],\r\n    topPerformers: Array<{ repId: string; repName: string; score: number; strengths: string[] }>\r\n  ): Array<{\r\n    skill: string;\r\n    teamAverage: number;\r\n    topPerformerAverage: number;\r\n    gap: number;\r\n    repsAffected: number;\r\n  }> {\r\n    const skills: (keyof SkillScores)[] = [\r\n      'prospecting',\r\n      'discovery',\r\n      'needsAnalysis',\r\n      'presentation',\r\n      'objectionHandling',\r\n      'negotiation',\r\n      'closing',\r\n      'relationshipBuilding',\r\n      'productKnowledge',\r\n      'crmHygiene',\r\n      'timeManagement',\r\n      'aiToolAdoption'\r\n    ];\r\n    \r\n    const topPerformerReps = repInsights.filter(r =>\r\n      topPerformers.some(tp => tp.repId === r.repId)\r\n    );\r\n    \r\n    return skills\r\n      .map(skill => {\r\n        const teamAverage = this.calculateAverage(\r\n          repInsights.map(r => r.skills[skill])\r\n        );\r\n        \r\n        const topPerformerAverage = topPerformerReps.length > 0\r\n          ? this.calculateAverage(topPerformerReps.map(r => r.skills[skill]))\r\n          : teamAverage;\r\n        \r\n        const gap = topPerformerAverage - teamAverage;\r\n        \r\n        const repsAffected = repInsights.filter(\r\n          r => r.skills[skill] < topPerformerAverage - 10\r\n        ).length;\r\n        \r\n        return {\r\n          skill: this.formatSkillName(skill),\r\n          teamAverage,\r\n          topPerformerAverage,\r\n          gap,\r\n          repsAffected\r\n        };\r\n      })\r\n      .filter(gap => gap.gap > 10) // Only include significant gaps\r\n      .sort((a, b) => b.gap - a.gap);\r\n  }\r\n  \r\n  // ============================================================================\r\n  // BEST PRACTICES EXTRACTION\r\n  // ============================================================================\r\n  \r\n  /**\r\n   * Extracts best practices from top performers\r\n   * @param repInsights - Array of rep performance metrics\r\n   * @param topPerformers - Top performers data\r\n   * @returns Best practices to share across team\r\n   */\r\n  private extractBestPractices(\r\n    repInsights: RepPerformanceMetrics[],\r\n    topPerformers: Array<{ repId: string; repName: string; score: number; strengths: string[] }>\r\n  ): BestPractice[] {\r\n    const practices: BestPractice[] = [];\r\n    \r\n    const topPerformerReps = repInsights.filter(r =>\r\n      topPerformers.some(tp => tp.repId === r.repId)\r\n    );\r\n    \r\n    if (topPerformerReps.length === 0) return practices;\r\n    \r\n    // Email response rate best practice\r\n    const avgEmailResponseRate = this.calculateAverage(\r\n      repInsights.map(r => r.communication.emailResponseRate)\r\n    );\r\n    const topEmailResponseRate = this.calculateAverage(\r\n      topPerformerReps.map(r => r.communication.emailResponseRate)\r\n    );\r\n    \r\n    if (topEmailResponseRate > avgEmailResponseRate + 0.1) {\r\n      practices.push({\r\n        title: 'Rapid Email Response Protocol',\r\n        description: 'Top performers respond to emails significantly faster, maintaining momentum in deals.',\r\n        category: 'communication',\r\n        topPerformers: topPerformers.slice(0, 3).map(tp => tp.repName),\r\n        successMetrics: [{\r\n          metric: 'Email Response Rate',\r\n          topPerformerAverage: topEmailResponseRate,\r\n          repCurrent: avgEmailResponseRate,\r\n          gap: topEmailResponseRate - avgEmailResponseRate\r\n        }],\r\n        implementationSteps: [\r\n          'Set up email notifications for high-priority deals',\r\n          'Block 2-3 time slots per day for email responses',\r\n          'Use AI email writer for faster replies',\r\n          'Respond within 2 hours for hot leads'\r\n        ],\r\n        expectedImpact: 'Improve email response rate by 15-20%, leading to faster deal progression'\r\n      });\r\n    }\r\n    \r\n    // Deal velocity best practice\r\n    const avgDealVelocity = this.calculateAverage(\r\n      repInsights.map(r => r.deals.dealVelocity)\r\n    );\r\n    const topDealVelocity = this.calculateAverage(\r\n      topPerformerReps.map(r => r.deals.dealVelocity)\r\n    );\r\n    \r\n    if (topDealVelocity > avgDealVelocity * 1.2) {\r\n      practices.push({\r\n        title: 'High-Velocity Deal Management',\r\n        description: 'Top performers move deals through the pipeline faster through disciplined qualification and follow-up.',\r\n        category: 'pipeline_management',\r\n        topPerformers: topPerformers.slice(0, 3).map(tp => tp.repName),\r\n        successMetrics: [{\r\n          metric: 'Deal Velocity',\r\n          topPerformerAverage: topDealVelocity,\r\n          repCurrent: avgDealVelocity,\r\n          gap: topDealVelocity - avgDealVelocity\r\n        }],\r\n        implementationSteps: [\r\n          'Qualify leads rigorously in first meeting',\r\n          'Set clear next steps at end of every meeting',\r\n          'Use workflow automation for timely follow-ups',\r\n          'Disqualify poor-fit deals early'\r\n        ],\r\n        expectedImpact: 'Increase deal velocity by 20-30%, closing more deals per quarter'\r\n      });\r\n    }\r\n    \r\n    // Win rate best practice\r\n    const avgWinRate = this.calculateAverage(\r\n      repInsights.map(r => r.deals.winRate)\r\n    );\r\n    const topWinRate = this.calculateAverage(\r\n      topPerformerReps.map(r => r.deals.winRate)\r\n    );\r\n    \r\n    if (topWinRate > avgWinRate + 0.15) {\r\n      practices.push({\r\n        title: 'Strategic Deal Qualification',\r\n        description: 'Top performers achieve higher win rates through better qualification and deal selection.',\r\n        category: 'discovery',\r\n        topPerformers: topPerformers.slice(0, 3).map(tp => tp.repName),\r\n        successMetrics: [{\r\n          metric: 'Win Rate',\r\n          topPerformerAverage: topWinRate,\r\n          repCurrent: avgWinRate,\r\n          gap: topWinRate - avgWinRate\r\n        }],\r\n        implementationSteps: [\r\n          'Use BANT/MEDDIC framework for qualification',\r\n          'Identify economic buyer early',\r\n          'Understand competitive landscape before presenting',\r\n          'Walk away from deals with poor fit'\r\n        ],\r\n        expectedImpact: 'Improve win rate by 10-15 percentage points, focusing effort on winnable deals'\r\n      });\r\n    }\r\n    \r\n    return practices.slice(0, 5); // Return top 5 practices\r\n  }\r\n  \r\n  // ============================================================================\r\n  // TEAM PRIORITIES\r\n  // ============================================================================\r\n  \r\n  /**\r\n   * Determines team coaching priorities based on skill gaps and at-risk reps\r\n   * @param skillGaps - Skill gaps across team\r\n   * @param needsSupport - Reps needing support\r\n   * @param teamSummary - Team performance summary\r\n   * @returns Prioritized coaching areas\r\n   */\r\n  private determineTeamPriorities(\r\n    skillGaps: Array<{ skill: string; teamAverage: number; topPerformerAverage: number; gap: number; repsAffected: number }>,\r\n    needsSupport: Array<{ repId: string; repName: string; score: number; criticalAreas: string[] }>,\r\n    teamSummary: TeamPerformanceSummary\r\n  ): Array<{\r\n    area: string;\r\n    importance: number;\r\n    repsAffected: number;\r\n    potentialImpact: string;\r\n  }> {\r\n    const priorities: Array<{\r\n      area: string;\r\n      importance: number;\r\n      repsAffected: number;\r\n      potentialImpact: string;\r\n    }> = [];\r\n    \r\n    // Priority 1: Support at-risk reps\r\n    if (teamSummary.atRiskCount > 0) {\r\n      priorities.push({\r\n        area: 'At-Risk Rep Support',\r\n        importance: 100,\r\n        repsAffected: teamSummary.atRiskCount,\r\n        potentialImpact: `${teamSummary.atRiskCount} rep(s) at risk of missing quota. Immediate 1-on-1 coaching required.`\r\n      });\r\n    }\r\n    \r\n    // Priority 2: Address largest skill gaps\r\n    skillGaps.slice(0, 3).forEach(gap => {\r\n      const importance = Math.min(100, 60 + gap.gap);\r\n      priorities.push({\r\n        area: gap.skill,\r\n        importance,\r\n        repsAffected: gap.repsAffected,\r\n        potentialImpact: `${gap.repsAffected} rep(s) below top performer benchmark. Gap of ${gap.gap.toFixed(1)} points could improve team ${gap.skill.toLowerCase()} significantly.`\r\n      });\r\n    });\r\n    \r\n    // Priority 3: Low quota attainment\r\n    if (teamSummary.teamAverages.quotaAttainment < 0.8) {\r\n      const repsBelow = Math.floor(teamSummary.totalReps * 0.6);\r\n      priorities.push({\r\n        area: 'Quota Attainment',\r\n        importance: 90,\r\n        repsAffected: repsBelow,\r\n        potentialImpact: `Team at ${(teamSummary.teamAverages.quotaAttainment * 100).toFixed(0)}% quota attainment. Focus on pipeline building and deal acceleration.`\r\n      });\r\n    }\r\n    \r\n    // Priority 4: Low win rate\r\n    if (teamSummary.teamAverages.winRate < 0.25) {\r\n      const repsBelow = Math.floor(teamSummary.totalReps * 0.5);\r\n      priorities.push({\r\n        area: 'Win Rate Improvement',\r\n        importance: 85,\r\n        repsAffected: repsBelow,\r\n        potentialImpact: `Team win rate at ${(teamSummary.teamAverages.winRate * 100).toFixed(0)}%. Better qualification and discovery needed.`\r\n      });\r\n    }\r\n    \r\n    return priorities.sort((a, b) => b.importance - a.importance).slice(0, 5);\r\n  }\r\n  \r\n  // ============================================================================\r\n  // TEAM STRENGTHS & WEAKNESSES\r\n  // ============================================================================\r\n  \r\n  /**\r\n   * Identifies team-wide strengths\r\n   * @param repInsights - Array of rep performance metrics\r\n   * @param teamSummary - Team performance summary\r\n   * @returns Team strengths\r\n   */\r\n  private identifyTeamStrengths(\r\n    repInsights: RepPerformanceMetrics[],\r\n    teamSummary: TeamPerformanceSummary\r\n  ): string[] {\r\n    const strengths: string[] = [];\r\n    \r\n    // High win rate\r\n    if (teamSummary.teamAverages.winRate > 0.35) {\r\n      strengths.push(`Strong Win Rate (${(teamSummary.teamAverages.winRate * 100).toFixed(0)}%)`);\r\n    }\r\n    \r\n    // High quota attainment\r\n    if (teamSummary.teamAverages.quotaAttainment > 0.9) {\r\n      strengths.push(`Excellent Quota Attainment (${(teamSummary.teamAverages.quotaAttainment * 100).toFixed(0)}%)`);\r\n    }\r\n    \r\n    // High email response rate\r\n    if (teamSummary.teamAverages.emailResponseRate > 0.7) {\r\n      strengths.push(`Responsive Communication (${(teamSummary.teamAverages.emailResponseRate * 100).toFixed(0)}% response rate)`);\r\n    }\r\n    \r\n    // High overall performance\r\n    if (teamSummary.teamAverages.overallScore > 75) {\r\n      strengths.push(`High Overall Performance (${teamSummary.teamAverages.overallScore.toFixed(0)} average score)`);\r\n    }\r\n    \r\n    // Strong top performers\r\n    const topPerformerPercentage = teamSummary.performanceDistribution\r\n      .filter(d => d.tier === 'top_performer' || d.tier === 'high_performer')\r\n      .reduce((sum, d) => sum + d.percentage, 0);\r\n    \r\n    if (topPerformerPercentage > 40) {\r\n      strengths.push(`${topPerformerPercentage.toFixed(0)}% of team are top/high performers`);\r\n    }\r\n    \r\n    return strengths;\r\n  }\r\n  \r\n  /**\r\n   * Identifies team-wide weaknesses\r\n   * @param repInsights - Array of rep performance metrics\r\n   * @param teamSummary - Team performance summary\r\n   * @returns Team weaknesses\r\n   */\r\n  private identifyTeamWeaknesses(\r\n    repInsights: RepPerformanceMetrics[],\r\n    teamSummary: TeamPerformanceSummary\r\n  ): string[] {\r\n    const weaknesses: string[] = [];\r\n    \r\n    // Low win rate\r\n    if (teamSummary.teamAverages.winRate < 0.25) {\r\n      weaknesses.push(`Low Win Rate (${(teamSummary.teamAverages.winRate * 100).toFixed(0)}%)`);\r\n    }\r\n    \r\n    // Low quota attainment\r\n    if (teamSummary.teamAverages.quotaAttainment < 0.7) {\r\n      weaknesses.push(`Below Quota Attainment (${(teamSummary.teamAverages.quotaAttainment * 100).toFixed(0)}%)`);\r\n    }\r\n    \r\n    // High at-risk count\r\n    if (teamSummary.atRiskCount > teamSummary.totalReps * 0.2) {\r\n      weaknesses.push(`${teamSummary.atRiskCount} rep(s) at risk (${((teamSummary.atRiskCount / teamSummary.totalReps) * 100).toFixed(0)}% of team)`);\r\n    }\r\n    \r\n    // Low email response rate\r\n    if (teamSummary.teamAverages.emailResponseRate < 0.5) {\r\n      weaknesses.push(`Poor Email Response Rate (${(teamSummary.teamAverages.emailResponseRate * 100).toFixed(0)}%)`);\r\n    }\r\n    \r\n    // Low deal velocity\r\n    if (teamSummary.teamAverages.dealVelocity < 0.5) {\r\n      weaknesses.push(`Low Deal Velocity (${teamSummary.teamAverages.dealVelocity.toFixed(1)} deals/week)`);\r\n    }\r\n    \r\n    return weaknesses;\r\n  }\r\n  \r\n  // ============================================================================\r\n  // UTILITY METHODS\r\n  // ============================================================================\r\n  \r\n  /**\r\n   * Calculates average of an array of numbers\r\n   * @param values - Array of numbers\r\n   * @returns Average value\r\n   */\r\n  private calculateAverage(values: number[]): number {\r\n    if (values.length === 0) return 0;\r\n    const sum = values.reduce((acc, val) => acc + val, 0);\r\n    return sum / values.length;\r\n  }\r\n  \r\n  /**\r\n   * Formats skill name for display\r\n   * @param skill - Skill key\r\n   * @returns Formatted skill name\r\n   */\r\n  private formatSkillName(skill: string): string {\r\n    return skill\r\n      .replace(/([A-Z])/g, ' $1')\r\n      .replace(/^./, str => str.toUpperCase())\r\n      .trim();\r\n  }\r\n  \r\n  /**\r\n   * Gets date range for a time period\r\n   * @param period - Time period\r\n   * @param customRange - Custom date range (if period is 'custom')\r\n   * @returns Start and end dates\r\n   */\r\n  private getDateRange(\r\n    period: string,\r\n    customRange?: { startDate: Date; endDate: Date }\r\n  ): { startDate: Date; endDate: Date } {\r\n    const endDate = new Date();\r\n    let startDate = new Date();\r\n    \r\n    if (period === 'custom' && customRange) {\r\n      return customRange;\r\n    }\r\n    \r\n    switch (period) {\r\n      case 'last_7_days':\r\n        startDate.setDate(endDate.getDate() - 7);\r\n        break;\r\n      case 'last_30_days':\r\n        startDate.setDate(endDate.getDate() - 30);\r\n        break;\r\n      case 'last_90_days':\r\n        startDate.setDate(endDate.getDate() - 90);\r\n        break;\r\n      case 'last_6_months':\r\n        startDate.setMonth(endDate.getMonth() - 6);\r\n        break;\r\n      case 'last_12_months':\r\n        startDate.setFullYear(endDate.getFullYear() - 1);\r\n        break;\r\n      case 'this_quarter':\r\n        const quarter = Math.floor(endDate.getMonth() / 3);\r\n        startDate = new Date(endDate.getFullYear(), quarter * 3, 1);\r\n        break;\r\n      case 'this_year':\r\n        startDate = new Date(endDate.getFullYear(), 0, 1);\r\n        break;\r\n      default:\r\n        startDate.setDate(endDate.getDate() - 30);\r\n    }\r\n    \r\n    return { startDate, endDate };\r\n  }\r\n  \r\n  /**\r\n   * Generates cache key for team insights\r\n   * @param teamId - Team ID\r\n   * @param period - Time period\r\n   * @param startDate - Start date (optional)\r\n   * @param endDate - End date (optional)\r\n   * @returns Cache key\r\n   */\r\n  private getCacheKey(\r\n    teamId: string,\r\n    period: string,\r\n    startDate?: Date,\r\n    endDate?: Date\r\n  ): string {\r\n    if (period === 'custom' && startDate && endDate) {\r\n      return `${teamId}:${period}:${startDate.toISOString()}:${endDate.toISOString()}`;\r\n    }\r\n    return `${teamId}:${period}`;\r\n  }\r\n  \r\n  /**\r\n   * Checks if cached insights are still valid\r\n   * @param cachedAt - When insights were cached\r\n   * @returns True if cache is valid\r\n   */\r\n  private isCacheValid(cachedAt: Date): boolean {\r\n    const age = Date.now() - cachedAt.getTime();\r\n    return age < this.CACHE_TTL_MS;\r\n  }\r\n  \r\n  /**\r\n   * Clears the insights cache\r\n   */\r\n  clearCache(): void {\r\n    this.insightsCache.clear();\r\n    console.log('[TeamCoachingEngine] Cache cleared');\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\David\\PycharmProjects\\AI Sales Platform\\src\\lib\\conversation\\conversation-engine.ts","messages":[{"ruleId":"no-useless-escape","severity":2,"message":"Unnecessary escape character: \\[.","line":631,"column":33,"nodeType":"Literal","messageId":"unnecessaryEscape","endLine":631,"endColumn":34,"suggestions":[{"messageId":"removeEscape","fix":{"range":[20484,20485],"text":""},"desc":"Remove the `\\`. This maintains the current functionality."},{"messageId":"escapeBackslash","fix":{"range":[20484,20484],"text":"\\"},"desc":"Replace the `\\` with `\\\\` to include the actual backslash character."}]},{"ruleId":"no-useless-escape","severity":2,"message":"Unnecessary escape character: \\(.","line":631,"column":35,"nodeType":"Literal","messageId":"unnecessaryEscape","endLine":631,"endColumn":36,"suggestions":[{"messageId":"removeEscape","fix":{"range":[20486,20487],"text":""},"desc":"Remove the `\\`. This maintains the current functionality."},{"messageId":"escapeBackslash","fix":{"range":[20486,20486],"text":"\\"},"desc":"Replace the `\\` with `\\\\` to include the actual backslash character."}]},{"ruleId":"no-useless-escape","severity":2,"message":"Unnecessary escape character: \\).","line":631,"column":45,"nodeType":"Literal","messageId":"unnecessaryEscape","endLine":631,"endColumn":46,"suggestions":[{"messageId":"removeEscape","fix":{"range":[20496,20497],"text":""},"desc":"Remove the `\\`. This maintains the current functionality."},{"messageId":"escapeBackslash","fix":{"range":[20496,20496],"text":"\\"},"desc":"Replace the `\\` with `\\\\` to include the actual backslash character."}]},{"ruleId":"no-useless-escape","severity":2,"message":"Unnecessary escape character: \\).","line":631,"column":53,"nodeType":"Literal","messageId":"unnecessaryEscape","endLine":631,"endColumn":54,"suggestions":[{"messageId":"removeEscape","fix":{"range":[20504,20505],"text":""},"desc":"Remove the `\\`. This maintains the current functionality."},{"messageId":"escapeBackslash","fix":{"range":[20504,20504],"text":"\\"},"desc":"Replace the `\\` with `\\\\` to include the actual backslash character."}]},{"ruleId":"no-useless-escape","severity":2,"message":"Unnecessary escape character: \\-.","line":631,"column":62,"nodeType":"Literal","messageId":"unnecessaryEscape","endLine":631,"endColumn":63,"suggestions":[{"messageId":"removeEscape","fix":{"range":[20513,20514],"text":""},"desc":"Remove the `\\`. This maintains the current functionality."},{"messageId":"escapeBackslash","fix":{"range":[20513,20513],"text":"\\"},"desc":"Replace the `\\` with `\\\\` to include the actual backslash character."}]}],"suppressedMessages":[],"errorCount":5,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Conversation Intelligence - Analysis Engine\r\n * \r\n * AI-powered analysis of sales conversations using GPT-4o.\r\n * Provides comprehensive insights including sentiment, talk ratio,\r\n * topics, objections, coaching, and follow-up recommendations.\r\n * \r\n * FEATURES:\r\n * - Transcript analysis with AI\r\n * - Sentiment tracking and critical moments\r\n * - Talk ratio calculation and assessment\r\n * - Topic extraction and coverage mapping\r\n * - Objection detection and handling evaluation\r\n * - Competitor mention tracking\r\n * - Coaching insights generation\r\n * - Follow-up action recommendations\r\n * \r\n * @module lib/conversation\r\n */\r\n\r\nimport { logger } from '@/lib/logger/logger';\r\nimport { sendUnifiedChatMessage } from '@/lib/ai/unified-ai-service';\r\nimport { getServerSignalCoordinator } from '@/lib/orchestration/coordinator-factory-server';\r\nimport type {\r\n  Conversation,\r\n  ConversationAnalysis,\r\n  AnalyzeConversationRequest,\r\n  AnalyzeTranscriptRequest,\r\n  BatchAnalysisRequest,\r\n  BatchAnalysisResponse,\r\n  SentimentAnalysis,\r\n  TalkRatioAnalysis,\r\n  TopicAnalysis,\r\n  ObjectionAnalysis,\r\n  CompetitorMention,\r\n  KeyMoment,\r\n  CoachingInsight,\r\n  FollowUpAction,\r\n  ConversationScores,\r\n  QualityIndicator,\r\n  RedFlag,\r\n  PositiveSignal,\r\n  ConversationEngineConfig,\r\n  Participant,\r\n  ConversationType,\r\n  AnalysisSummary,\r\n} from './types';\r\nimport { DEFAULT_CONVERSATION_CONFIG } from './types';\r\n\r\n// ============================================================================\r\n// MAIN ANALYSIS FUNCTION\r\n// ============================================================================\r\n\r\n/**\r\n * Analyze a conversation and generate comprehensive insights\r\n * \r\n * @param request - Analysis request\r\n * @param config - Optional engine configuration\r\n * @returns Complete conversation analysis\r\n */\r\nexport async function analyzeConversation(\r\n  request: AnalyzeConversationRequest,\r\n  config: Partial<ConversationEngineConfig> = {}\r\n): Promise<ConversationAnalysis> {\r\n  const startTime = Date.now();\r\n  const fullConfig: ConversationEngineConfig = { ...DEFAULT_CONVERSATION_CONFIG, ...config };\r\n  \r\n  try {\r\n    logger.info('Analyzing conversation', {\r\n      conversationId: request.conversationId,\r\n      organizationId: request.organizationId,\r\n      includeCoaching: request.includeCoaching,\r\n    });\r\n    \r\n    // 1. Get conversation data\r\n    const conversation = await getConversation(\r\n      request.organizationId,\r\n      request.conversationId,\r\n      request.workspaceId || 'default'\r\n    );\r\n    \r\n    if (!conversation) {\r\n      throw new Error(`Conversation not found: ${request.conversationId}`);\r\n    }\r\n    \r\n    if (!conversation.transcript || conversation.transcript.length < fullConfig.minTranscriptLength) {\r\n      throw new Error('Conversation transcript is missing or too short');\r\n    }\r\n    \r\n    // 2. Perform AI-powered analysis\r\n    const analysis = await analyzeTranscript({\r\n      organizationId: request.organizationId,\r\n      workspaceId: request.workspaceId,\r\n      transcript: conversation.transcript,\r\n      conversationType: conversation.type,\r\n      participants: conversation.participants,\r\n      repId: conversation.repId,\r\n      duration: conversation.duration,\r\n      dealId: conversation.dealId,\r\n      leadId: conversation.leadId,\r\n      title: conversation.title,\r\n      includeCoaching: request.includeCoaching,\r\n      includeFollowUps: request.includeFollowUps,\r\n      customContext: request.customContext,\r\n    }, fullConfig);\r\n    \r\n    logger.info('Conversation analysis complete', {\r\n      conversationId: request.conversationId,\r\n      overallScore: analysis.scores.overall,\r\n      processingTime: Date.now() - startTime,\r\n    });\r\n    \r\n    // 3. Emit signal for analysis completion\r\n    await emitAnalysisSignal(analysis, conversation);\r\n    \r\n    return analysis;\r\n    \r\n  } catch (error: any) {\r\n    logger.error('Conversation analysis failed', error, {\r\n      conversationId: request.conversationId,\r\n      organizationId: request.organizationId,\r\n    });\r\n    throw new Error(`Conversation analysis failed: ${error.message}`);\r\n  }\r\n}\r\n\r\n/**\r\n * Analyze raw transcript directly\r\n * \r\n * @param request - Transcript analysis request\r\n * @param config - Engine configuration\r\n * @returns Conversation analysis\r\n */\r\nexport async function analyzeTranscript(\r\n  request: AnalyzeTranscriptRequest,\r\n  config: ConversationEngineConfig = DEFAULT_CONVERSATION_CONFIG\r\n): Promise<ConversationAnalysis> {\r\n  const startTime = Date.now();\r\n  \r\n  try {\r\n    // 1. Build AI prompt\r\n    const prompt = buildAnalysisPrompt(request);\r\n    \r\n    // 2. Call AI for comprehensive analysis\r\n    const response = await sendUnifiedChatMessage({\r\n      model: config.aiModel,\r\n      messages: [{ role: 'user', content: prompt }],\r\n      temperature: config.temperature,\r\n      maxTokens: config.maxTokens,\r\n    });\r\n    \r\n    // 3. Parse AI response\r\n    const aiAnalysis = parseAIAnalysis(response.text);\r\n    \r\n    // 4. Calculate talk ratio (deterministic, not AI-based)\r\n    const talkRatio = calculateTalkRatio(\r\n      request.transcript,\r\n      request.participants,\r\n      request.repId,\r\n      request.duration,\r\n      config\r\n    );\r\n    \r\n    // 5. Calculate scores\r\n    const scores = calculateScores(aiAnalysis, talkRatio);\r\n    \r\n    // 6. Identify quality indicators\r\n    const qualityIndicators = identifyQualityIndicators(\r\n      aiAnalysis,\r\n      talkRatio,\r\n      scores\r\n    );\r\n    \r\n    // 7. Extract red flags and positive signals\r\n    const redFlags = extractRedFlags(aiAnalysis, qualityIndicators);\r\n    const positiveSignals = extractPositiveSignals(aiAnalysis);\r\n    \r\n    // 8. Generate coaching insights (if requested)\r\n    let coachingInsights: CoachingInsight[] = [];\r\n    if (request.includeCoaching) {\r\n      coachingInsights = await generateCoachingInsights(\r\n        aiAnalysis,\r\n        talkRatio,\r\n        scores,\r\n        request.customContext,\r\n        config\r\n      );\r\n    }\r\n    \r\n    // 9. Generate follow-up actions (if requested)\r\n    let followUpActions: FollowUpAction[] = [];\r\n    if (request.includeFollowUps) {\r\n      followUpActions = await generateFollowUpActions(\r\n        aiAnalysis,\r\n        request.conversationType,\r\n        request.customContext,\r\n        config\r\n      );\r\n    }\r\n    \r\n    // 10. Build complete analysis\r\n    const analysis: ConversationAnalysis = {\r\n      conversationId: `analysis_${Date.now()}`, // Will be updated if saving\r\n      organizationId: request.organizationId,\r\n      workspaceId: request.workspaceId || 'default',\r\n      \r\n      sentiment: aiAnalysis.sentiment,\r\n      talkRatio,\r\n      topics: aiAnalysis.topics,\r\n      objections: aiAnalysis.objections,\r\n      competitors: aiAnalysis.competitors,\r\n      \r\n      keyMoments: aiAnalysis.keyMoments,\r\n      coachingInsights,\r\n      followUpActions,\r\n      \r\n      scores,\r\n      qualityIndicators,\r\n      redFlags,\r\n      positiveSignals,\r\n      \r\n      summary: aiAnalysis.summary,\r\n      highlights: aiAnalysis.highlights,\r\n      \r\n      confidence: aiAnalysis.confidence,\r\n      analyzedAt: new Date(),\r\n      analysisVersion: '1.0.0',\r\n      aiModel: config.aiModel,\r\n      tokensUsed: response.usage?.totalTokens || 0,\r\n      processingTime: Date.now() - startTime,\r\n    };\r\n    \r\n    return analysis;\r\n    \r\n  } catch (error: any) {\r\n    logger.error('Transcript analysis failed', error, {\r\n      organizationId: request.organizationId,\r\n    });\r\n    throw new Error(`Transcript analysis failed: ${error.message}`);\r\n  }\r\n}\r\n\r\n/**\r\n * Analyze multiple conversations in batch\r\n */\r\nexport async function analyzeBatchConversations(\r\n  request: BatchAnalysisRequest,\r\n  config: Partial<ConversationEngineConfig> = {}\r\n): Promise<BatchAnalysisResponse> {\r\n  const startTime = Date.now();\r\n  \r\n  try {\r\n    logger.info('Batch conversation analysis started', {\r\n      conversationCount: request.conversationIds.length,\r\n      organizationId: request.organizationId,\r\n    });\r\n    \r\n    const analyses = new Map<string, ConversationAnalysis>();\r\n    \r\n    // Analyze each conversation\r\n    for (const conversationId of request.conversationIds) {\r\n      try {\r\n        const analysis = await analyzeConversation(\r\n          {\r\n            conversationId,\r\n            organizationId: request.organizationId,\r\n            workspaceId: request.workspaceId,\r\n            includeCoaching: request.includeCoaching,\r\n            includeFollowUps: request.includeFollowUps,\r\n          },\r\n          config\r\n        );\r\n        \r\n        analyses.set(conversationId, analysis);\r\n      } catch (error: any) {\r\n        logger.warn('Failed to analyze conversation', {\r\n          conversationId,\r\n          error: error.message,\r\n        });\r\n      }\r\n    }\r\n    \r\n    // Calculate summary\r\n    const summary = calculateAnalysisSummary(analyses);\r\n    \r\n    logger.info('Batch conversation analysis complete', {\r\n      totalConversations: request.conversationIds.length,\r\n      successful: analyses.size,\r\n      duration: Date.now() - startTime,\r\n    });\r\n    \r\n    return {\r\n      analyses,\r\n      summary,\r\n      analyzedAt: new Date(),\r\n    };\r\n    \r\n  } catch (error: any) {\r\n    logger.error('Batch conversation analysis failed', error, {\r\n      organizationId: request.organizationId,\r\n    });\r\n    throw new Error(`Batch conversation analysis failed: ${error.message}`);\r\n  }\r\n}\r\n\r\n// ============================================================================\r\n// AI PROMPT BUILDING\r\n// ============================================================================\r\n\r\n/**\r\n * Build AI prompt for conversation analysis\r\n */\r\nfunction buildAnalysisPrompt(request: AnalyzeTranscriptRequest): string {\r\n  const repInfo = request.participants.find(p => p.id === request.repId);\r\n  const prospects = request.participants.filter(p => \r\n    p.role === 'prospect' || p.role === 'decision_maker' || p.role === 'influencer'\r\n  );\r\n  \r\n  return `You are an expert sales conversation analyst. Analyze this sales conversation and provide comprehensive insights.\r\n\r\nCONVERSATION METADATA:\r\n- Type: ${request.conversationType}\r\n- Title: ${request.title || 'Untitled'}\r\n- Duration: ${Math.floor(request.duration / 60)} minutes\r\n- Sales Rep: ${repInfo?.name || 'Unknown'}\r\n- Prospects: ${prospects.map(p => `${p.name} (${p.role}${p.title ? ', ' + p.title : ''})`).join(', ')}\r\n${request.customContext ? `\\nADDITIONAL CONTEXT:\\n${request.customContext}\\n` : ''}\r\n\r\nTRANSCRIPT:\r\n${request.transcript}\r\n\r\nAnalyze this conversation and provide a JSON response with the following structure:\r\n\r\n{\r\n  \"sentiment\": {\r\n    \"overall\": {\r\n      \"polarity\": \"positive\" | \"negative\" | \"neutral\" | \"very_positive\" | \"very_negative\",\r\n      \"score\": -1 to 1,\r\n      \"confidence\": 0-100,\r\n      \"tone\": [\"professional\", \"enthusiastic\", \"hesitant\", etc.]\r\n    },\r\n    \"byParticipant\": {\r\n      \"participantName\": { /* same as overall */ }\r\n    },\r\n    \"timeline\": [\r\n      { \"timestamp\": seconds, \"sentiment\": -1 to 1, \"speaker\": \"name\", \"context\": \"...\" }\r\n    ],\r\n    \"trendDirection\": \"improving\" | \"declining\" | \"stable\",\r\n    \"criticalMoments\": [\r\n      {\r\n        \"timestamp\": seconds,\r\n        \"type\": \"spike\" | \"drop\",\r\n        \"magnitude\": number,\r\n        \"speaker\": \"name\",\r\n        \"quote\": \"...\",\r\n        \"context\": \"...\",\r\n        \"impact\": \"high\" | \"medium\" | \"low\"\r\n      }\r\n    ]\r\n  },\r\n  \r\n  \"topics\": {\r\n    \"mainTopics\": [\r\n      {\r\n        \"name\": \"topic name\",\r\n        \"category\": \"pain_points\" | \"business_value\" | \"pricing\" | \"timeline\" | \"competition\" | \"stakeholders\" | \"decision_process\" | etc.,\r\n        \"mentions\": number,\r\n        \"duration\": seconds,\r\n        \"sentiment\": -1 to 1,\r\n        \"importance\": \"critical\" | \"high\" | \"medium\" | \"low\",\r\n        \"quotes\": [\"relevant quote 1\", \"relevant quote 2\"]\r\n      }\r\n    ],\r\n    \"coverageMap\": { \"topic\": durationInSeconds },\r\n    \"uncoveredTopics\": [\"expected topic that wasn't discussed\"],\r\n    \"timeAllocation\": [\r\n      {\r\n        \"topic\": \"name\",\r\n        \"duration\": seconds,\r\n        \"percentage\": 0-100,\r\n        \"isAppropriate\": boolean,\r\n        \"recommendation\": \"...\"\r\n      }\r\n    ]\r\n  },\r\n  \r\n  \"objections\": [\r\n    {\r\n      \"id\": \"unique_id\",\r\n      \"type\": \"pricing\" | \"timing\" | \"authority\" | \"competition\" | \"technical\" | \"trust\" | \"need\" | \"urgency\",\r\n      \"objection\": \"summary\",\r\n      \"quote\": \"exact quote\",\r\n      \"timestamp\": seconds,\r\n      \"speaker\": \"name\",\r\n      \"severity\": \"critical\" | \"high\" | \"medium\" | \"low\",\r\n      \"wasAddressed\": boolean,\r\n      \"repResponse\": \"...\",\r\n      \"responseQuality\": \"excellent\" | \"good\" | \"poor\" | \"none\",\r\n      \"recommendedResponse\": \"...\"\r\n    }\r\n  ],\r\n  \r\n  \"competitors\": [\r\n    {\r\n      \"competitor\": \"name\",\r\n      \"mentions\": number,\r\n      \"context\": [\"quote 1\", \"quote 2\"],\r\n      \"sentiment\": -1 to 1,\r\n      \"concernLevel\": \"high\" | \"medium\" | \"low\",\r\n      \"recommendedResponse\": \"...\"\r\n    }\r\n  ],\r\n  \r\n  \"keyMoments\": [\r\n    {\r\n      \"id\": \"unique_id\",\r\n      \"timestamp\": seconds,\r\n      \"type\": \"buying_signal\" | \"objection\" | \"commitment\" | \"concern\" | \"decision_maker_engagement\" | \"competitor_mention\" | \"timeline_discussed\" | \"budget_revealed\" | \"next_steps_agreed\" | \"red_flag\",\r\n      \"title\": \"brief title\",\r\n      \"description\": \"detailed description\",\r\n      \"speaker\": \"name\",\r\n      \"quote\": \"exact quote\",\r\n      \"impact\": \"positive\" | \"negative\" | \"neutral\",\r\n      \"significance\": \"critical\" | \"high\" | \"medium\" | \"low\"\r\n    }\r\n  ],\r\n  \r\n  \"summary\": \"2-3 sentence summary of the conversation\",\r\n  \"highlights\": [\"key highlight 1\", \"key highlight 2\", \"key highlight 3\"],\r\n  \"confidence\": 0-100 (how confident you are in this analysis)\r\n}\r\n\r\nFocus on actionable insights. Be specific and use exact quotes. Identify both strengths and areas for improvement.`;\r\n}\r\n\r\n// ============================================================================\r\n// AI RESPONSE PARSING\r\n// ============================================================================\r\n\r\n/**\r\n * Parse AI analysis response\r\n */\r\nfunction parseAIAnalysis(aiResponse: string): any {\r\n  try {\r\n    // Extract JSON from response\r\n    const jsonMatch = aiResponse.match(/\\{[\\s\\S]*\\}/);\r\n    if (!jsonMatch) {\r\n      throw new Error('No JSON found in AI response');\r\n    }\r\n    \r\n    const parsed = JSON.parse(jsonMatch[0]);\r\n    \r\n    // Validate required fields\r\n    if (!parsed.sentiment || !parsed.topics || !parsed.summary) {\r\n      throw new Error('Missing required fields in AI response');\r\n    }\r\n    \r\n    return {\r\n      sentiment: parsed.sentiment,\r\n      topics: parsed.topics,\r\n      objections: parsed.objections || [],\r\n      competitors: parsed.competitors || [],\r\n      keyMoments: parsed.keyMoments || [],\r\n      summary: parsed.summary,\r\n      highlights: parsed.highlights || [],\r\n      confidence: parsed.confidence || 75,\r\n    };\r\n    \r\n  } catch (error: any) {\r\n    logger.error('Failed to parse AI analysis', { error: error.message });\r\n    \r\n    // Return minimal fallback\r\n    return {\r\n      sentiment: {\r\n        overall: {\r\n          polarity: 'neutral',\r\n          score: 0,\r\n          confidence: 50,\r\n          tone: ['unknown'],\r\n        },\r\n        byParticipant: {},\r\n        timeline: [],\r\n        trendDirection: 'stable',\r\n        criticalMoments: [],\r\n      },\r\n      topics: {\r\n        mainTopics: [],\r\n        coverageMap: {},\r\n        uncoveredTopics: [],\r\n        timeAllocation: [],\r\n      },\r\n      objections: [],\r\n      competitors: [],\r\n      keyMoments: [],\r\n      summary: 'Analysis failed to parse AI response',\r\n      highlights: [],\r\n      confidence: 30,\r\n    };\r\n  }\r\n}\r\n\r\n// ============================================================================\r\n// TALK RATIO CALCULATION\r\n// ============================================================================\r\n\r\n/**\r\n * Calculate talk ratio from transcript\r\n */\r\nfunction calculateTalkRatio(\r\n  transcript: string,\r\n  participants: Participant[],\r\n  repId: string,\r\n  duration: number,\r\n  config: ConversationEngineConfig\r\n): TalkRatioAnalysis {\r\n  try {\r\n    // Parse transcript into turns\r\n    const turns = parseTranscriptTurns(transcript, participants);\r\n    \r\n    // Calculate per-participant stats\r\n    const byParticipant: Record<string, any> = {};\r\n    let repTalkTime = 0;\r\n    let prospectTalkTime = 0;\r\n    \r\n    participants.forEach(participant => {\r\n      const participantTurns = turns.filter(t => t.speakerId === participant.id);\r\n      const totalTime = participantTurns.reduce((sum, turn) => sum + turn.duration, 0);\r\n      const questionCount = participantTurns.filter(t => t.isQuestion).length;\r\n      \r\n      const stats = {\r\n        totalTime,\r\n        percentage: duration > 0 ? Math.round((totalTime / duration) * 100) : 0,\r\n        turnCount: participantTurns.length,\r\n        avgTurnDuration: participantTurns.length > 0 ? totalTime / participantTurns.length : 0,\r\n        longestTurn: Math.max(0, ...participantTurns.map(t => t.duration)),\r\n        interruptionCount: participantTurns.filter(t => t.wasInterruption).length,\r\n        questionCount,\r\n      };\r\n      \r\n      byParticipant[participant.id] = stats;\r\n      \r\n      // Track rep vs prospect time\r\n      if (participant.id === repId || participant.role === 'sales_rep' || participant.role === 'sales_manager') {\r\n        repTalkTime += totalTime;\r\n      } else if (participant.role === 'prospect' || participant.role === 'decision_maker' || participant.role === 'influencer') {\r\n        prospectTalkTime += totalTime;\r\n      }\r\n    });\r\n    \r\n    // Calculate overall ratio\r\n    const totalTalkTime = repTalkTime + prospectTalkTime;\r\n    const repPercentage = totalTalkTime > 0 ? Math.round((repTalkTime / totalTalkTime) * 100) : 0;\r\n    const prospectPercentage = totalTalkTime > 0 ? Math.round((prospectTalkTime / totalTalkTime) * 100) : 0;\r\n    const ratio = prospectTalkTime > 0 ? repTalkTime / prospectTalkTime : 1;\r\n    \r\n    // Assess talk ratio\r\n    const repRatio = totalTalkTime > 0 ? repTalkTime / totalTalkTime : 0.5;\r\n    let assessment: any;\r\n    let recommendation: string;\r\n    \r\n    if (repRatio >= config.idealTalkRatioMin && repRatio <= config.idealTalkRatioMax) {\r\n      assessment = 'ideal';\r\n      recommendation = 'Excellent talk ratio! Continue listening actively and asking thoughtful questions.';\r\n    } else if (repRatio > 0.5) {\r\n      assessment = 'rep_dominating';\r\n      recommendation = 'You\\'re talking too much. Focus on asking more questions and letting the prospect share their challenges.';\r\n    } else if (repRatio < 0.2) {\r\n      assessment = 'prospect_dominating';\r\n      recommendation = 'Good listening, but try to guide the conversation more. Ask clarifying questions and share relevant insights.';\r\n    } else if (repRatio >= 0.4 && repRatio <= 0.5) {\r\n      assessment = 'balanced';\r\n      recommendation = 'Good balance. Aim for slightly more listening to reach the ideal 30-40% talk time.';\r\n    } else {\r\n      assessment = 'needs_improvement';\r\n      recommendation = 'Work on finding the right talk/listen balance. Aim for 30-40% of the conversation.';\r\n    }\r\n    \r\n    return {\r\n      overall: {\r\n        speakerTime: repTalkTime,\r\n        listenerTime: prospectTalkTime,\r\n        ratio,\r\n        isIdeal: assessment === 'ideal',\r\n      },\r\n      byParticipant,\r\n      repTalkTime,\r\n      prospectTalkTime,\r\n      repPercentage,\r\n      prospectPercentage,\r\n      assessment,\r\n      recommendation,\r\n    };\r\n    \r\n  } catch (error: any) {\r\n    logger.error('Talk ratio calculation failed', { error: error.message });\r\n    \r\n    // Return default/fallback\r\n    return {\r\n      overall: {\r\n        speakerTime: 0,\r\n        listenerTime: 0,\r\n        ratio: 1,\r\n        isIdeal: false,\r\n      },\r\n      byParticipant: {},\r\n      repTalkTime: 0,\r\n      prospectTalkTime: 0,\r\n      repPercentage: 50,\r\n      prospectPercentage: 50,\r\n      assessment: 'needs_improvement',\r\n      recommendation: 'Unable to calculate talk ratio from transcript',\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Parse transcript into individual speaking turns\r\n */\r\nfunction parseTranscriptTurns(transcript: string, participants: Participant[]): any[] {\r\n  const turns: any[] = [];\r\n  \r\n  // Common transcript formats:\r\n  // \"Speaker Name: text\"\r\n  // \"[Speaker Name]: text\"\r\n  // \"Speaker Name - text\"\r\n  \r\n  const lines = transcript.split('\\n').filter(line => line.trim().length > 0);\r\n  \r\n  lines.forEach((line, index) => {\r\n    // Try to extract speaker name\r\n    const match = line.match(/^[\\[\\(]?([^:\\]\\)]+)[\\]\\)]?\\s*[:\\-]\\s*(.+)$/);\r\n    \r\n    if (match) {\r\n      const speakerName = match[1].trim();\r\n      const text = match[2].trim();\r\n      \r\n      // Find matching participant\r\n      const participant = participants.find(p => \r\n        p.name.toLowerCase().includes(speakerName.toLowerCase()) ||\r\n        speakerName.toLowerCase().includes(p.name.toLowerCase())\r\n      );\r\n      \r\n      if (participant) {\r\n        // Estimate duration (rough: ~150 words per minute, ~2.5 words per second)\r\n        const wordCount = text.split(/\\s+/).length;\r\n        const estimatedDuration = wordCount / 2.5;\r\n        \r\n        turns.push({\r\n          speakerId: participant.id,\r\n          speakerName: participant.name,\r\n          text,\r\n          wordCount,\r\n          duration: estimatedDuration,\r\n          isQuestion: text.includes('?'),\r\n          wasInterruption: false, // Hard to detect from transcript alone\r\n        });\r\n      }\r\n    }\r\n  });\r\n  \r\n  return turns;\r\n}\r\n\r\n// ============================================================================\r\n// SCORING\r\n// ============================================================================\r\n\r\n/**\r\n * Calculate conversation scores\r\n */\r\nfunction calculateScores(aiAnalysis: any, talkRatio: TalkRatioAnalysis): ConversationScores {\r\n  // Overall sentiment score (convert -1 to 1 ΓåÆ 0 to 100)\r\n  const sentimentScore = Math.round(((aiAnalysis.sentiment.overall.score + 1) / 2) * 100);\r\n  \r\n  // Talk ratio score\r\n  const talkRatioScore = talkRatio.assessment === 'ideal' ? 95 :\r\n                         talkRatio.assessment === 'balanced' ? 80 :\r\n                         talkRatio.assessment === 'needs_improvement' ? 60 :\r\n                         talkRatio.assessment === 'rep_dominating' ? 40 : 50;\r\n  \r\n  // Discovery score (based on questions and topics covered)\r\n  const questioningScore = 70; // Would analyze question quality from transcript\r\n  const topicsCovered = aiAnalysis.topics.mainTopics.length;\r\n  const discoveryScore = Math.min(100, Math.round((topicsCovered * 10) + (questioningScore * 0.7)));\r\n  \r\n  // Objection handling score\r\n  const totalObjections = aiAnalysis.objections.length;\r\n  const addressedObjections = aiAnalysis.objections.filter((obj: any) => obj.wasAddressed).length;\r\n  const objectionScore = totalObjections > 0 \r\n    ? Math.round((addressedObjections / totalObjections) * 100)\r\n    : 80; // No objections = good\r\n  \r\n  // Closing score (based on next steps and commitments)\r\n  const hasNextSteps = aiAnalysis.keyMoments.some((m: any) => m.type === 'next_steps_agreed');\r\n  const hasCommitment = aiAnalysis.keyMoments.some((m: any) => m.type === 'commitment');\r\n  const closingScore = hasNextSteps && hasCommitment ? 90 :\r\n                       hasNextSteps ? 75 :\r\n                       hasCommitment ? 70 : 50;\r\n  \r\n  // Rapport score (based on sentiment and engagement)\r\n  const rapportScore = Math.max(50, sentimentScore);\r\n  \r\n  // Engagement score (positive signals - red flags)\r\n  const positiveSignals = aiAnalysis.keyMoments.filter((m: any) => m.impact === 'positive').length;\r\n  const negativeSignals = aiAnalysis.keyMoments.filter((m: any) => m.impact === 'negative').length;\r\n  const engagementScore = Math.min(100, Math.max(30, 70 + (positiveSignals * 5) - (negativeSignals * 10)));\r\n  \r\n  // Overall score (weighted average)\r\n  const overallScore = Math.round(\r\n    discoveryScore * 0.25 +\r\n    objectionScore * 0.2 +\r\n    closingScore * 0.2 +\r\n    rapportScore * 0.15 +\r\n    engagementScore * 0.1 +\r\n    talkRatioScore * 0.1\r\n  );\r\n  \r\n  return {\r\n    overall: overallScore,\r\n    discovery: discoveryScore,\r\n    valueArticulation: 75, // Would need more specific analysis\r\n    objectionHandling: objectionScore,\r\n    closing: closingScore,\r\n    rapport: rapportScore,\r\n    engagement: engagementScore,\r\n  };\r\n}\r\n\r\n// ============================================================================\r\n// QUALITY INDICATORS\r\n// ============================================================================\r\n\r\n/**\r\n * Identify quality indicators\r\n */\r\nfunction identifyQualityIndicators(\r\n  aiAnalysis: any,\r\n  talkRatio: TalkRatioAnalysis,\r\n  scores: ConversationScores\r\n): QualityIndicator[] {\r\n  const indicators: QualityIndicator[] = [];\r\n  \r\n  // Talk ratio indicator\r\n  indicators.push({\r\n    type: 'talk_ratio',\r\n    status: talkRatio.assessment === 'ideal' ? 'excellent' :\r\n            talkRatio.assessment === 'balanced' ? 'good' :\r\n            talkRatio.assessment === 'needs_improvement' ? 'needs_improvement' : 'poor',\r\n    score: talkRatio.overall.isIdeal ? 95 : 60,\r\n    description: `Rep spoke ${talkRatio.repPercentage}% of the time`,\r\n    recommendation: talkRatio.recommendation,\r\n  });\r\n  \r\n  // Discovery depth indicator\r\n  const topicCount = aiAnalysis.topics.mainTopics.length;\r\n  indicators.push({\r\n    type: 'discovery_depth',\r\n    status: topicCount >= 5 ? 'excellent' :\r\n            topicCount >= 3 ? 'good' :\r\n            topicCount >= 2 ? 'needs_improvement' : 'poor',\r\n    score: Math.min(100, topicCount * 20),\r\n    description: `Covered ${topicCount} key topics`,\r\n    recommendation: topicCount < 3 ? 'Ask more open-ended questions to uncover additional pain points and requirements' : undefined,\r\n  });\r\n  \r\n  // Next steps clarity indicator\r\n  const hasNextSteps = aiAnalysis.keyMoments.some((m: any) => m.type === 'next_steps_agreed');\r\n  indicators.push({\r\n    type: 'next_steps_clarity',\r\n    status: hasNextSteps ? 'excellent' : 'poor',\r\n    score: hasNextSteps ? 100 : 30,\r\n    description: hasNextSteps ? 'Clear next steps defined' : 'No clear next steps',\r\n    recommendation: hasNextSteps ? undefined : 'Always end calls with specific next steps and timeline',\r\n  });\r\n  \r\n  // Objection handling indicator\r\n  const objectionCount = aiAnalysis.objections.length;\r\n  const handledCount = aiAnalysis.objections.filter((obj: any) => obj.wasAddressed).length;\r\n  if (objectionCount > 0) {\r\n    indicators.push({\r\n      type: 'objection_handling',\r\n      status: handledCount === objectionCount ? 'excellent' :\r\n              handledCount >= objectionCount * 0.7 ? 'good' :\r\n              handledCount >= objectionCount * 0.5 ? 'needs_improvement' : 'poor',\r\n      score: Math.round((handledCount / objectionCount) * 100),\r\n      description: `Addressed ${handledCount}/${objectionCount} objections`,\r\n      recommendation: handledCount < objectionCount ? 'Acknowledge and address all objections before moving forward' : undefined,\r\n    });\r\n  }\r\n  \r\n  return indicators;\r\n}\r\n\r\n// ============================================================================\r\n// RED FLAGS & POSITIVE SIGNALS\r\n// ============================================================================\r\n\r\n/**\r\n * Extract red flags from analysis\r\n */\r\nfunction extractRedFlags(aiAnalysis: any, qualityIndicators: QualityIndicator[]): RedFlag[] {\r\n  const redFlags: RedFlag[] = [];\r\n  \r\n  // No next steps\r\n  const hasNextSteps = aiAnalysis.keyMoments.some((m: any) => m.type === 'next_steps_agreed');\r\n  if (!hasNextSteps) {\r\n    redFlags.push({\r\n      type: 'no_next_steps',\r\n      severity: 'critical',\r\n      description: 'Call ended without clear next steps',\r\n      recommendation: 'Always establish concrete next actions and timeline before ending the call',\r\n    });\r\n  }\r\n  \r\n  // Multiple unaddressed objections\r\n  const unaddressedObjections = aiAnalysis.objections.filter((obj: any) => !obj.wasAddressed);\r\n  if (unaddressedObjections.length >= 2) {\r\n    redFlags.push({\r\n      type: 'multiple_objections',\r\n      severity: 'high',\r\n      description: `${unaddressedObjections.length} objections left unaddressed`,\r\n      recommendation: 'Circle back to acknowledge and address all concerns',\r\n    });\r\n  }\r\n  \r\n  // Competitor preference\r\n  const competitorConcerns = aiAnalysis.competitors.filter((c: any) => c.concernLevel === 'high');\r\n  if (competitorConcerns.length > 0) {\r\n    redFlags.push({\r\n      type: 'competitor_preference',\r\n      severity: 'high',\r\n      description: `Strong preference indicated for: ${competitorConcerns.map((c: any) => c.competitor).join(', ')}`,\r\n      recommendation: 'Use battlecard to differentiate and highlight unique value proposition',\r\n    });\r\n  }\r\n  \r\n  // Negative sentiment trend\r\n  if (aiAnalysis.sentiment.trendDirection === 'declining') {\r\n    redFlags.push({\r\n      type: 'low_engagement',\r\n      severity: 'medium',\r\n      description: 'Prospect engagement declined during conversation',\r\n      recommendation: 'Re-engage by asking about their specific challenges and desired outcomes',\r\n    });\r\n  }\r\n  \r\n  return redFlags;\r\n}\r\n\r\n/**\r\n * Extract positive signals from analysis\r\n */\r\nfunction extractPositiveSignals(aiAnalysis: any): PositiveSignal[] {\r\n  const signals: PositiveSignal[] = [];\r\n  \r\n  // Buying intent\r\n  const buyingSignals = aiAnalysis.keyMoments.filter((m: any) => m.type === 'buying_signal');\r\n  buyingSignals.forEach((signal: any) => {\r\n    signals.push({\r\n      type: 'buying_intent',\r\n      strength: signal.significance === 'critical' ? 'strong' : \r\n                signal.significance === 'high' ? 'moderate' : 'weak',\r\n      description: signal.description,\r\n      quote: signal.quote,\r\n      timestamp: signal.timestamp,\r\n      impact: 'Strong indicator of purchase intent',\r\n    });\r\n  });\r\n  \r\n  // Decision maker engaged\r\n  const dmEngagement = aiAnalysis.keyMoments.filter((m: any) => m.type === 'decision_maker_engagement');\r\n  if (dmEngagement.length > 0) {\r\n    signals.push({\r\n      type: 'decision_maker_engaged',\r\n      strength: 'strong',\r\n      description: 'Decision maker actively participated',\r\n      impact: 'Direct access to economic buyer increases close probability',\r\n    });\r\n  }\r\n  \r\n  // Clear pain point\r\n  const painTopics = aiAnalysis.topics.mainTopics.filter((t: any) => t.category === 'pain_points');\r\n  if (painTopics.length > 0) {\r\n    signals.push({\r\n      type: 'clear_pain_point',\r\n      strength: painTopics.length >= 2 ? 'strong' : 'moderate',\r\n      description: `Identified ${painTopics.length} clear pain point(s)`,\r\n      impact: 'Strong pain points drive purchase urgency',\r\n    });\r\n  }\r\n  \r\n  // Positive sentiment\r\n  if (aiAnalysis.sentiment.overall.score > 0.5) {\r\n    signals.push({\r\n      type: 'value_acknowledged',\r\n      strength: 'moderate',\r\n      description: 'Overall positive sentiment throughout conversation',\r\n      impact: 'Prospect is receptive to the solution',\r\n    });\r\n  }\r\n  \r\n  return signals;\r\n}\r\n\r\n// ============================================================================\r\n// COACHING INSIGHTS GENERATION\r\n// ============================================================================\r\n\r\n/**\r\n * Generate coaching insights with AI\r\n */\r\nasync function generateCoachingInsights(\r\n  aiAnalysis: any,\r\n  talkRatio: TalkRatioAnalysis,\r\n  scores: ConversationScores,\r\n  customContext: string | undefined,\r\n  config: ConversationEngineConfig\r\n): Promise<CoachingInsight[]> {\r\n  try {\r\n    const prompt = buildCoachingPrompt(aiAnalysis, talkRatio, scores, customContext);\r\n    \r\n    const response = await sendUnifiedChatMessage({\r\n      model: config.aiModel,\r\n      messages: [{ role: 'user', content: prompt }],\r\n      temperature: 0.7,\r\n      maxTokens: 2000,\r\n    });\r\n    \r\n    const insights = parseCoachingInsights(response.text, config.maxCoachingInsights);\r\n    \r\n    return insights;\r\n    \r\n  } catch (error: any) {\r\n    logger.error('Coaching insights generation failed', { error: error.message });\r\n    return [];\r\n  }\r\n}\r\n\r\n/**\r\n * Build coaching prompt\r\n */\r\nfunction buildCoachingPrompt(\r\n  aiAnalysis: any,\r\n  talkRatio: TalkRatioAnalysis,\r\n  scores: ConversationScores,\r\n  customContext?: string\r\n): string {\r\n  return `You are a sales coaching expert. Analyze this conversation and provide actionable coaching insights.\r\n\r\nCONVERSATION ANALYSIS:\r\n- Overall Score: ${scores.overall}/100\r\n- Discovery Score: ${scores.discovery}/100\r\n- Objection Handling: ${scores.objectionHandling}/100\r\n- Closing Score: ${scores.closing}/100\r\n- Talk Ratio: ${talkRatio.repPercentage}% rep, ${talkRatio.prospectPercentage}% prospect (${talkRatio.assessment})\r\n- Sentiment: ${aiAnalysis.sentiment.overall.polarity} (${aiAnalysis.sentiment.overall.score})\r\n- Topics Covered: ${aiAnalysis.topics.mainTopics.length}\r\n- Objections: ${aiAnalysis.objections.length}\r\n- Key Moments: ${aiAnalysis.keyMoments.length}\r\n${customContext ? `\\nCONTEXT:\\n${customContext}\\n` : ''}\r\n\r\nProvide 3-5 coaching insights as a JSON array:\r\n\r\n[\r\n  {\r\n    \"id\": \"unique_id\",\r\n    \"category\": \"discovery\" | \"listening\" | \"objection_handling\" | \"value_articulation\" | \"questioning\" | \"closing\" | \"rapport_building\" | \"time_management\",\r\n    \"priority\": \"critical\" | \"high\" | \"medium\" | \"low\",\r\n    \"insight\": \"One sentence insight\",\r\n    \"whatWentWell\": \"What the rep did well (if applicable)\",\r\n    \"whatToImprove\": \"Specific improvement area\",\r\n    \"specificExample\": \"Quote or specific moment from conversation\",\r\n    \"recommendedAction\": \"Concrete action to take\",\r\n    \"skillArea\": \"Specific skill to develop\",\r\n    \"impact\": 0-100 (potential impact of improvement)\r\n  }\r\n]\r\n\r\nFocus on the highest-impact improvements. Be specific and actionable.`;\r\n}\r\n\r\n/**\r\n * Parse coaching insights from AI response\r\n */\r\nfunction parseCoachingInsights(aiResponse: string, maxInsights: number): CoachingInsight[] {\r\n  try {\r\n    const jsonMatch = aiResponse.match(/\\[[\\s\\S]*\\]/);\r\n    if (!jsonMatch) {\r\n      return [];\r\n    }\r\n    \r\n    const parsed = JSON.parse(jsonMatch[0]);\r\n    return parsed.slice(0, maxInsights);\r\n    \r\n  } catch (error) {\r\n    logger.warn('Failed to parse coaching insights', { error });\r\n    return [];\r\n  }\r\n}\r\n\r\n// ============================================================================\r\n// FOLLOW-UP ACTIONS GENERATION\r\n// ============================================================================\r\n\r\n/**\r\n * Generate follow-up action recommendations\r\n */\r\nasync function generateFollowUpActions(\r\n  aiAnalysis: any,\r\n  conversationType: ConversationType,\r\n  customContext: string | undefined,\r\n  config: ConversationEngineConfig\r\n): Promise<FollowUpAction[]> {\r\n  try {\r\n    const prompt = buildFollowUpPrompt(aiAnalysis, conversationType, customContext);\r\n    \r\n    const response = await sendUnifiedChatMessage({\r\n      model: config.aiModel,\r\n      messages: [{ role: 'user', content: prompt }],\r\n      temperature: 0.7,\r\n      maxTokens: 1500,\r\n    });\r\n    \r\n    const actions = parseFollowUpActions(response.text, config.maxFollowUpActions);\r\n    \r\n    return actions;\r\n    \r\n  } catch (error: any) {\r\n    logger.error('Follow-up actions generation failed', { error: error.message });\r\n    return [];\r\n  }\r\n}\r\n\r\n/**\r\n * Build follow-up actions prompt\r\n */\r\nfunction buildFollowUpPrompt(\r\n  aiAnalysis: any,\r\n  conversationType: ConversationType,\r\n  customContext?: string\r\n): string {\r\n  return `Generate follow-up actions based on this conversation analysis.\r\n\r\nCONVERSATION TYPE: ${conversationType}\r\nSUMMARY: ${aiAnalysis.summary}\r\nKEY MOMENTS: ${aiAnalysis.keyMoments.map((m: any) => `- ${m.description}`).join('\\n')}\r\nOBJECTIONS: ${aiAnalysis.objections.map((o: any) => `- ${o.objection}`).join('\\n')}\r\n${customContext ? `\\nCONTEXT:\\n${customContext}\\n` : ''}\r\n\r\nProvide 3-5 follow-up actions as a JSON array:\r\n\r\n[\r\n  {\r\n    \"id\": \"unique_id\",\r\n    \"type\": \"send_follow_up_email\" | \"schedule_meeting\" | \"send_proposal\" | \"share_resources\" | \"introduce_stakeholder\" | \"address_concern\" | \"provide_pricing\" | \"schedule_demo\" | \"send_case_study\",\r\n    \"priority\": \"critical\" | \"high\" | \"medium\" | \"low\",\r\n    \"title\": \"Short title\",\r\n    \"description\": \"Detailed description of the action\",\r\n    \"reasoning\": \"Why this action is important\",\r\n    \"deadline\": \"within 24 hours\" | \"within 2 days\" | \"within 1 week\",\r\n    \"estimatedEffort\": hours (0.5 to 8)\r\n  }\r\n]\r\n\r\nPrioritize based on what will most advance the deal.`;\r\n}\r\n\r\n/**\r\n * Parse follow-up actions from AI response\r\n */\r\nfunction parseFollowUpActions(aiResponse: string, maxActions: number): FollowUpAction[] {\r\n  try {\r\n    const jsonMatch = aiResponse.match(/\\[[\\s\\S]*\\]/);\r\n    if (!jsonMatch) {\r\n      return [];\r\n    }\r\n    \r\n    const parsed = JSON.parse(jsonMatch[0]);\r\n    return parsed.slice(0, maxActions);\r\n    \r\n  } catch (error) {\r\n    logger.warn('Failed to parse follow-up actions', { error });\r\n    return [];\r\n  }\r\n}\r\n\r\n// ============================================================================\r\n// SUMMARY CALCULATION\r\n// ============================================================================\r\n\r\n/**\r\n * Calculate analysis summary for batch results\r\n */\r\nfunction calculateAnalysisSummary(\r\n  analyses: Map<string, ConversationAnalysis>\r\n): AnalysisSummary {\r\n  if (analyses.size === 0) {\r\n    return {\r\n      totalConversations: 0,\r\n      avgOverallScore: 0,\r\n      avgSentiment: 0,\r\n      avgTalkRatio: 0,\r\n      topCoachingAreas: [],\r\n      commonObjections: [],\r\n      topCompetitors: [],\r\n      sentimentTrend: 'stable',\r\n      scoreTrend: 'stable',\r\n    };\r\n  }\r\n  \r\n  let totalScore = 0;\r\n  let totalSentiment = 0;\r\n  let totalTalkRatio = 0;\r\n  \r\n  const coachingMap = new Map<string, { count: number; impact: number }>();\r\n  const objectionMap = new Map<string, { count: number; addressed: number }>();\r\n  const competitorMap = new Map<string, { count: number; sentiment: number }>();\r\n  \r\n  analyses.forEach(analysis => {\r\n    totalScore += analysis.scores.overall;\r\n    totalSentiment += analysis.sentiment.overall.score;\r\n    totalTalkRatio += analysis.talkRatio.repPercentage;\r\n    \r\n    // Aggregate coaching areas\r\n    analysis.coachingInsights.forEach(insight => {\r\n      const existing = coachingMap.get(insight.category) || { count: 0, impact: 0 };\r\n      coachingMap.set(insight.category, {\r\n        count: existing.count + 1,\r\n        impact: existing.impact + insight.impact,\r\n      });\r\n    });\r\n    \r\n    // Aggregate objections\r\n    analysis.objections.forEach(objection => {\r\n      const existing = objectionMap.get(objection.type) || { count: 0, addressed: 0 };\r\n      objectionMap.set(objection.type, {\r\n        count: existing.count + 1,\r\n        addressed: existing.addressed + (objection.wasAddressed ? 1 : 0),\r\n      });\r\n    });\r\n    \r\n    // Aggregate competitors\r\n    analysis.competitors.forEach(competitor => {\r\n      const existing = competitorMap.get(competitor.competitor) || { count: 0, sentiment: 0 };\r\n      competitorMap.set(competitor.competitor, {\r\n        count: existing.count + competitor.mentions,\r\n        sentiment: existing.sentiment + competitor.sentiment,\r\n      });\r\n    });\r\n  });\r\n  \r\n  const count = analyses.size;\r\n  \r\n  return {\r\n    totalConversations: count,\r\n    avgOverallScore: Math.round(totalScore / count),\r\n    avgSentiment: totalSentiment / count,\r\n    avgTalkRatio: Math.round(totalTalkRatio / count),\r\n    \r\n    topCoachingAreas: Array.from(coachingMap.entries())\r\n      .map(([area, data]) => ({\r\n        area,\r\n        frequency: data.count,\r\n        avgImpact: Math.round(data.impact / data.count),\r\n        recommendation: `Focus on improving ${area} skills`,\r\n      }))\r\n      .sort((a, b) => b.frequency - a.frequency)\r\n      .slice(0, 5),\r\n    \r\n    commonObjections: Array.from(objectionMap.entries())\r\n      .map(([type, data]) => ({\r\n        type: type as any,\r\n        frequency: data.count,\r\n        avgSeverity: 50, // Would need more data\r\n        successRate: Math.round((data.addressed / data.count) * 100),\r\n        bestResponse: 'Review successful objection handling examples',\r\n      }))\r\n      .sort((a, b) => b.frequency - a.frequency)\r\n      .slice(0, 5),\r\n    \r\n    topCompetitors: Array.from(competitorMap.entries())\r\n      .map(([competitor, data]) => ({\r\n        competitor,\r\n        mentions: data.count,\r\n        avgSentiment: data.sentiment / data.count,\r\n        winRate: 50, // Would need deal outcome data\r\n        positioning: 'Use battlecard for competitive differentiation',\r\n      }))\r\n      .sort((a, b) => b.mentions - a.mentions)\r\n      .slice(0, 5),\r\n    \r\n    sentimentTrend: 'stable',\r\n    scoreTrend: 'stable',\r\n  };\r\n}\r\n\r\n// ============================================================================\r\n// SIGNAL BUS INTEGRATION\r\n// ============================================================================\r\n\r\n/**\r\n * Emit analysis signal to Signal Bus\r\n */\r\nasync function emitAnalysisSignal(\r\n  analysis: ConversationAnalysis,\r\n  conversation: Conversation\r\n): Promise<void> {\r\n  try {\r\n    const coordinator = getServerSignalCoordinator();\r\n    \r\n    await coordinator.emitSignal({\r\n      type: 'conversation.analyzed' as any,\r\n      leadId: conversation.leadId || 'unknown',\r\n      orgId: analysis.organizationId,\r\n      workspaceId: analysis.workspaceId,\r\n      confidence: analysis.confidence / 100,\r\n      priority: analysis.scores.overall >= 70 ? 'Low' : analysis.scores.overall >= 50 ? 'Medium' : 'High',\r\n      metadata: {\r\n        source: 'conversation-intelligence',\r\n        conversationId: conversation.id,\r\n        conversationType: conversation.type,\r\n        overallScore: analysis.scores.overall,\r\n        sentiment: analysis.sentiment.overall.polarity,\r\n        talkRatio: analysis.talkRatio.repPercentage,\r\n        redFlagsCount: analysis.redFlags.length,\r\n        coachingInsightsCount: analysis.coachingInsights.length,\r\n      },\r\n    });\r\n    \r\n    logger.info('Analysis signal emitted', {\r\n      conversationId: conversation.id,\r\n      overallScore: analysis.scores.overall,\r\n    });\r\n    \r\n  } catch (error) {\r\n    logger.error('Failed to emit analysis signal', error, {\r\n      conversationId: conversation.id,\r\n    });\r\n  }\r\n}\r\n\r\n// ============================================================================\r\n// UTILITY FUNCTIONS\r\n// ============================================================================\r\n\r\n/**\r\n * Get conversation data (placeholder - would query Firestore)\r\n */\r\nasync function getConversation(\r\n  organizationId: string,\r\n  conversationId: string,\r\n  workspaceId: string\r\n): Promise<Conversation | null> {\r\n  // TODO: Implement Firestore query\r\n  // For now, return null to indicate not found\r\n  return null;\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\David\\PycharmProjects\\AI Sales Platform\\src\\lib\\crm\\deal-monitor.ts","messages":[{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":254,"column":7,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":254,"endColumn":50},{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":255,"column":7,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":255,"endColumn":50}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Deal Monitor Service\r\n * \r\n * Real-time deal monitoring using the Signal Bus.\r\n * Observes deal-related signals and triggers automated recommendations.\r\n * \r\n * LIVING LEDGER COMPLIANCE:\r\n * - Real-time signal observation (deal.created, deal.stage.changed, deal.won, deal.lost)\r\n * - Automatic health score recalculation on deal changes\r\n * - Next Best Action recommendations triggered by signals\r\n * - Signal Bus integration for event-driven architecture\r\n * \r\n * Signal Flow:\r\n * 1. Deal event occurs ΓåÆ Signal emitted by deal-service\r\n * 2. Deal Monitor observes signal ΓåÆ Triggers analysis\r\n * 3. Calculate health score ΓåÆ Generate recommendations\r\n * 4. Emit recommendation signals ΓåÆ Frontend/automation consumes\r\n */\r\n\r\nimport { logger } from '@/lib/logger/logger';\r\nimport { getServerSignalCoordinator } from '@/lib/orchestration/coordinator-factory-server';\r\nimport { calculateDealHealth } from './deal-health';\r\nimport { generateNextBestActions } from './next-best-action-engine';\r\nimport type { SalesSignal } from '@/lib/orchestration/types';\r\nimport type { Deal } from './deal-service';\r\n\r\n// ============================================================================\r\n// TYPES\r\n// ============================================================================\r\n\r\nexport interface DealMonitorConfig {\r\n  organizationId: string;\r\n  workspaceId: string;\r\n  autoGenerateRecommendations?: boolean; // Default: true\r\n  autoRecalculateHealth?: boolean; // Default: true\r\n  signalPriority?: 'High' | 'Medium' | 'Low'; // Default: Medium\r\n}\r\n\r\n// ============================================================================\r\n// SIGNAL OBSERVATION\r\n// ============================================================================\r\n\r\n/**\r\n * Start monitoring deal signals\r\n * \r\n * Observes deal-related signals and triggers automated actions.\r\n * \r\n * @param config - Monitor configuration\r\n * @returns Unsubscribe function\r\n * \r\n * @example\r\n * ```typescript\r\n * const unsubscribe = await startDealMonitor({\r\n *   organizationId: 'org_123',\r\n *   workspaceId: 'default',\r\n *   autoGenerateRecommendations: true,\r\n * });\r\n * \r\n * // Later, to stop monitoring:\r\n * unsubscribe();\r\n * ```\r\n */\r\nexport async function startDealMonitor(\r\n  config: DealMonitorConfig\r\n): Promise<() => void> {\r\n  const {\r\n    organizationId,\r\n    workspaceId,\r\n    autoGenerateRecommendations = true,\r\n    autoRecalculateHealth = true,\r\n    signalPriority = 'Medium',\r\n  } = config;\r\n\r\n  logger.info('Starting deal monitor', {\r\n    organizationId,\r\n    workspaceId,\r\n    autoGenerateRecommendations,\r\n    autoRecalculateHealth,\r\n  });\r\n\r\n  try {\r\n    const coordinator = getServerSignalCoordinator();\r\n\r\n    // Observe deal signals\r\n    const unsubscribe = coordinator.observeSignals(\r\n      {\r\n        types: [\r\n          'deal.created',\r\n          'deal.stage.changed',\r\n          'deal.won',\r\n          'deal.lost',\r\n        ],\r\n        orgId: organizationId,\r\n        workspaceId,\r\n      },\r\n      async (signal: SalesSignal) => {\r\n        await handleDealSignal(\r\n          signal,\r\n          organizationId,\r\n          workspaceId,\r\n          autoGenerateRecommendations,\r\n          autoRecalculateHealth,\r\n          signalPriority\r\n        );\r\n      }\r\n    );\r\n\r\n    logger.info('Deal monitor started successfully', {\r\n      organizationId,\r\n      workspaceId,\r\n    });\r\n\r\n    return unsubscribe;\r\n  } catch (error) {\r\n    logger.error('Failed to start deal monitor', error, {\r\n      organizationId,\r\n      workspaceId,\r\n    });\r\n    throw error;\r\n  }\r\n}\r\n\r\n/**\r\n * Handle deal signal\r\n */\r\nasync function handleDealSignal(\r\n  signal: SalesSignal,\r\n  organizationId: string,\r\n  workspaceId: string,\r\n  autoGenerateRecommendations: boolean,\r\n  autoRecalculateHealth: boolean,\r\n  signalPriority: 'High' | 'Medium' | 'Low'\r\n): Promise<void> {\r\n  try {\r\n    const dealId = signal.metadata?.dealId as string;\r\n    if (!dealId) {\r\n      logger.warn('Deal signal missing dealId', { signalType: signal.type });\r\n      return;\r\n    }\r\n\r\n    logger.info('Processing deal signal', {\r\n      signalType: signal.type,\r\n      dealId,\r\n      organizationId,\r\n    });\r\n\r\n    // Step 1: Recalculate health score\r\n    let healthScore;\r\n    if (autoRecalculateHealth && signal.type !== 'deal.created') {\r\n      try {\r\n        healthScore = await calculateDealHealth(\r\n          organizationId,\r\n          workspaceId,\r\n          dealId\r\n        );\r\n\r\n        logger.info('Deal health recalculated', {\r\n          dealId,\r\n          healthScore: healthScore.overall,\r\n          status: healthScore.status,\r\n        });\r\n\r\n        // Emit health score update signal\r\n        await emitHealthScoreSignal(\r\n          organizationId,\r\n          workspaceId,\r\n          dealId,\r\n          healthScore,\r\n          signalPriority\r\n        );\r\n      } catch (error) {\r\n        logger.error('Failed to recalculate health score', error, { dealId });\r\n      }\r\n    }\r\n\r\n    // Step 2: Generate next best action recommendations\r\n    if (autoGenerateRecommendations) {\r\n      try {\r\n        const recommendations = await generateNextBestActions(\r\n          organizationId,\r\n          workspaceId,\r\n          dealId\r\n        );\r\n\r\n        logger.info('Recommendations generated', {\r\n          dealId,\r\n          actionCount: recommendations.actions.length,\r\n          urgency: recommendations.urgency,\r\n          topAction: recommendations.actions[0]?.type,\r\n        });\r\n\r\n        // Emit recommendations signal\r\n        await emitRecommendationsSignal(\r\n          organizationId,\r\n          workspaceId,\r\n          dealId,\r\n          recommendations,\r\n          signalPriority\r\n        );\r\n      } catch (error) {\r\n        logger.error('Failed to generate recommendations', error, { dealId });\r\n      }\r\n    }\r\n\r\n    // Step 3: Handle specific signal types\r\n    await handleSpecificSignalType(\r\n      signal,\r\n      organizationId,\r\n      workspaceId,\r\n      dealId,\r\n      signalPriority\r\n    );\r\n  } catch (error) {\r\n    logger.error('Failed to handle deal signal', error, {\r\n      signalType: signal.type,\r\n    });\r\n  }\r\n}\r\n\r\n/**\r\n * Handle specific signal types\r\n */\r\nasync function handleSpecificSignalType(\r\n  signal: SalesSignal,\r\n  organizationId: string,\r\n  workspaceId: string,\r\n  dealId: string,\r\n  signalPriority: 'High' | 'Medium' | 'Low'\r\n): Promise<void> {\r\n  const coordinator = getServerSignalCoordinator();\r\n\r\n  switch (signal.type) {\r\n    case 'deal.created':\r\n      // New deal created - emit onboarding recommendations\r\n      await coordinator.emitSignal({\r\n        type: 'deal.action.recommended',\r\n        leadId: signal.metadata?.contactId as string,\r\n        orgId: organizationId,\r\n        workspaceId,\r\n        confidence: 0.9,\r\n        priority: signalPriority,\r\n        metadata: {\r\n          source: 'deal-monitor',\r\n          dealId,\r\n          actionType: 'qualification',\r\n          reason: 'New deal requires qualification call',\r\n          suggestedTimeline: 'This Week',\r\n        },\r\n      });\r\n      break;\r\n\r\n    case 'deal.stage.changed':\r\n      // Stage changed - recalculate and notify\r\n      const oldStage = signal.metadata?.oldStage;\r\n      const newStage = signal.metadata?.newStage;\r\n\r\n      logger.info('Deal stage changed', {\r\n        dealId,\r\n        oldStage,\r\n        newStage,\r\n      });\r\n\r\n      // If moved to negotiation, emit high-priority signal\r\n      if (newStage === 'negotiation') {\r\n        await coordinator.emitSignal({\r\n          type: 'deal.action.recommended',\r\n          orgId: organizationId,\r\n          workspaceId,\r\n          confidence: 0.95,\r\n          priority: 'High',\r\n          metadata: {\r\n            source: 'deal-monitor',\r\n            dealId,\r\n            actionType: 'negotiate',\r\n            reason: 'Deal entered negotiation - schedule final terms meeting',\r\n            suggestedTimeline: 'This Week',\r\n          },\r\n        });\r\n      }\r\n      break;\r\n\r\n    case 'deal.won':\r\n      // Deal won - emit onboarding signal\r\n      await coordinator.emitSignal({\r\n        type: 'deal.action.recommended',\r\n        orgId: organizationId,\r\n        workspaceId,\r\n        confidence: 1.0,\r\n        priority: 'High',\r\n        metadata: {\r\n          source: 'deal-monitor',\r\n          dealId,\r\n          actionType: 'onboarding',\r\n          reason: 'Deal won - initiate customer onboarding',\r\n          suggestedTimeline: 'Today',\r\n        },\r\n      });\r\n      break;\r\n\r\n    case 'deal.lost':\r\n      // Deal lost - emit post-mortem signal\r\n      await coordinator.emitSignal({\r\n        type: 'deal.action.recommended',\r\n        orgId: organizationId,\r\n        workspaceId,\r\n        confidence: 0.7,\r\n        priority: 'Low',\r\n        metadata: {\r\n          source: 'deal-monitor',\r\n          dealId,\r\n          actionType: 'postmortem',\r\n          reason: 'Deal lost - conduct loss analysis',\r\n          lostReason: signal.metadata?.lostReason,\r\n          suggestedTimeline: 'Next Week',\r\n        },\r\n      });\r\n      break;\r\n  }\r\n}\r\n\r\n/**\r\n * Emit health score update signal\r\n */\r\nasync function emitHealthScoreSignal(\r\n  organizationId: string,\r\n  workspaceId: string,\r\n  dealId: string,\r\n  healthScore: any,\r\n  priority: 'High' | 'Medium' | 'Low'\r\n): Promise<void> {\r\n  try {\r\n    const coordinator = getServerSignalCoordinator();\r\n\r\n    await coordinator.emitSignal({\r\n      type: 'deal.health.updated',\r\n      orgId: organizationId,\r\n      workspaceId,\r\n      confidence: 0.8, // Health score is deterministic\r\n      priority:\r\n        healthScore.status === 'critical'\r\n          ? 'High'\r\n          : healthScore.status === 'at-risk'\r\n          ? 'Medium'\r\n          : priority,\r\n      metadata: {\r\n        source: 'deal-monitor',\r\n        dealId,\r\n        healthScore: healthScore.overall,\r\n        status: healthScore.status,\r\n        warnings: healthScore.warnings,\r\n        recommendations: healthScore.recommendations,\r\n        factors: healthScore.factors.map((f: any) => ({\r\n          name: f.name,\r\n          score: f.score,\r\n          impact: f.impact,\r\n        })),\r\n      },\r\n    });\r\n\r\n    logger.info('Health score signal emitted', {\r\n      dealId,\r\n      healthScore: healthScore.overall,\r\n      status: healthScore.status,\r\n    });\r\n  } catch (error) {\r\n    logger.error('Failed to emit health score signal', error, { dealId });\r\n  }\r\n}\r\n\r\n/**\r\n * Emit recommendations signal\r\n */\r\nasync function emitRecommendationsSignal(\r\n  organizationId: string,\r\n  workspaceId: string,\r\n  dealId: string,\r\n  recommendations: any,\r\n  priority: 'High' | 'Medium' | 'Low'\r\n): Promise<void> {\r\n  try {\r\n    const coordinator = getServerSignalCoordinator();\r\n\r\n    await coordinator.emitSignal({\r\n      type: 'deal.recommendations.generated',\r\n      orgId: organizationId,\r\n      workspaceId,\r\n      confidence: recommendations.confidence,\r\n      priority:\r\n        recommendations.urgency === 'critical'\r\n          ? 'High'\r\n          : recommendations.urgency === 'high'\r\n          ? 'High'\r\n          : recommendations.urgency === 'medium'\r\n          ? 'Medium'\r\n          : priority,\r\n      metadata: {\r\n        source: 'deal-monitor',\r\n        dealId,\r\n        actionCount: recommendations.actions.length,\r\n        urgency: recommendations.urgency,\r\n        topAction: recommendations.actions[0]\r\n          ? {\r\n              type: recommendations.actions[0].type,\r\n              title: recommendations.actions[0].title,\r\n              priority: recommendations.actions[0].priority,\r\n              confidence: recommendations.actions[0].confidence,\r\n              suggestedTimeline: recommendations.actions[0].suggestedTimeline,\r\n            }\r\n          : null,\r\n        allActions: recommendations.actions.map((action: any) => ({\r\n          id: action.id,\r\n          type: action.type,\r\n          priority: action.priority,\r\n          title: action.title,\r\n          confidence: action.confidence,\r\n        })),\r\n      },\r\n    });\r\n\r\n    logger.info('Recommendations signal emitted', {\r\n      dealId,\r\n      actionCount: recommendations.actions.length,\r\n      urgency: recommendations.urgency,\r\n    });\r\n  } catch (error) {\r\n    logger.error('Failed to emit recommendations signal', error, { dealId });\r\n  }\r\n}\r\n\r\n// ============================================================================\r\n// BATCH MONITORING\r\n// ============================================================================\r\n\r\n/**\r\n * Monitor all deals and generate recommendations for at-risk deals\r\n * \r\n * This is useful for periodic batch processing (e.g., daily health check).\r\n * \r\n * @param organizationId - Organization ID\r\n * @param workspaceId - Workspace ID\r\n * @returns Summary of monitored deals\r\n */\r\nexport async function runDealHealthCheck(\r\n  organizationId: string,\r\n  workspaceId: string = 'default'\r\n): Promise<{\r\n  total: number;\r\n  healthy: number;\r\n  atRisk: number;\r\n  critical: number;\r\n  recommendationsGenerated: number;\r\n}> {\r\n  try {\r\n    logger.info('Running deal health check', {\r\n      organizationId,\r\n      workspaceId,\r\n    });\r\n\r\n    // Get all active deals\r\n    const { getDeals } = await import('./deal-service');\r\n    const { data: deals } = await getDeals(organizationId, workspaceId, {\r\n      // Filter out closed deals\r\n    });\r\n\r\n    const activeDeals = deals.filter(\r\n      (d: Deal) => d.stage !== 'closed_won' && d.stage !== 'closed_lost'\r\n    );\r\n\r\n    let healthy = 0;\r\n    let atRisk = 0;\r\n    let critical = 0;\r\n    let recommendationsGenerated = 0;\r\n\r\n    // Process each deal\r\n    for (const deal of activeDeals) {\r\n      try {\r\n        // Calculate health\r\n        const healthScore = await calculateDealHealth(\r\n          organizationId,\r\n          workspaceId,\r\n          deal.id\r\n        );\r\n\r\n        // Count by status\r\n        if (healthScore.status === 'healthy') healthy++;\r\n        else if (healthScore.status === 'at-risk') atRisk++;\r\n        else if (healthScore.status === 'critical') critical++;\r\n\r\n        // Generate recommendations for at-risk and critical deals\r\n        if (\r\n          healthScore.status === 'at-risk' ||\r\n          healthScore.status === 'critical'\r\n        ) {\r\n          await generateNextBestActions(\r\n            organizationId,\r\n            workspaceId,\r\n            deal.id,\r\n            deal\r\n          );\r\n          recommendationsGenerated++;\r\n        }\r\n      } catch (error) {\r\n        logger.error('Failed to process deal in health check', error, {\r\n          dealId: deal.id,\r\n        });\r\n      }\r\n    }\r\n\r\n    const summary = {\r\n      total: activeDeals.length,\r\n      healthy,\r\n      atRisk,\r\n      critical,\r\n      recommendationsGenerated,\r\n    };\r\n\r\n    logger.info('Deal health check complete', summary);\r\n\r\n    return summary;\r\n  } catch (error) {\r\n    logger.error('Failed to run deal health check', error, {\r\n      organizationId,\r\n      workspaceId,\r\n    });\r\n    throw error;\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\David\\PycharmProjects\\AI Sales Platform\\src\\lib\\ecommerce\\payment-service.ts","messages":[{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":76,"column":7,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":76,"endColumn":82},{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":80,"column":7,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":80,"endColumn":79},{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":84,"column":7,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":84,"endColumn":76}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Payment Service\r\n * Handles payment processing via Stripe and other providers\r\n */\r\n\r\nimport { apiKeyService } from '@/lib/api-keys/api-key-service';\r\nimport type { OrderPayment } from '@/types/ecommerce'\r\nimport { logger } from '@/lib/logger/logger';;\r\n\r\nexport interface PaymentRequest {\r\n  workspaceId: string;\r\n  organizationId: string;\r\n  amount: number; // In cents\r\n  currency: string;\r\n  paymentMethod: string;\r\n  paymentToken?: string; // Stripe payment intent token, etc.\r\n  customer: {\r\n    email: string;\r\n    firstName: string;\r\n    lastName: string;\r\n    phone?: string;\r\n  };\r\n  metadata?: Record<string, any>;\r\n}\r\n\r\nexport interface PaymentResult {\r\n  success: boolean;\r\n  transactionId?: string;\r\n  provider?: string;\r\n  cardLast4?: string;\r\n  cardBrand?: string;\r\n  processingFee?: number;\r\n  error?: string;\r\n}\r\n\r\n/**\r\n * Process payment\r\n */\r\nexport async function processPayment(request: PaymentRequest): Promise<PaymentResult> {\r\n  // Get e-commerce config to determine payment provider\r\n  const { FirestoreService, COLLECTIONS } = await import('@/lib/db/firestore-service');\r\n  const ecommerceConfig = await FirestoreService.get(\r\n    `${COLLECTIONS.ORGANIZATIONS}/${request.organizationId}/workspaces/${request.workspaceId}/ecommerce`,\r\n    'config'\r\n  );\r\n  \r\n  if (!ecommerceConfig) {\r\n    return {\r\n      success: false,\r\n      error: 'E-commerce not configured',\r\n    };\r\n  }\r\n  \r\n  const paymentConfig = (ecommerceConfig as any).payments;\r\n  const defaultProvider = paymentConfig?.providers?.find((p: any) => p.isDefault && p.enabled);\r\n  \r\n  if (!paymentConfig || !defaultProvider) {\r\n    return {\r\n      success: false,\r\n      error: 'No payment provider configured',\r\n    };\r\n  }\r\n  \r\n  // Route to appropriate provider\r\n  switch (defaultProvider.provider) {\r\n    case 'stripe':\r\n      return processStripePayment(request, defaultProvider);\r\n    \r\n    case 'square':\r\n      return processSquarePayment(request, defaultProvider);\r\n    \r\n    case 'paypal':\r\n      return processPayPalPayment(request, defaultProvider);\r\n    \r\n    case 'authorizenet':\r\n      const { processAuthorizeNetPayment } = await import('./payment-providers');\r\n      return processAuthorizeNetPayment(request, defaultProvider);\r\n    \r\n    case '2checkout':\r\n      const { process2CheckoutPayment } = await import('./payment-providers');\r\n      return process2CheckoutPayment(request, defaultProvider);\r\n    \r\n    case 'mollie':\r\n      const { processMolliePayment } = await import('./payment-providers');\r\n      return processMolliePayment(request, defaultProvider);\r\n    \r\n    default:\r\n      return {\r\n        success: false,\r\n        error: `Payment provider ${defaultProvider.provider} not yet implemented`,\r\n      };\r\n  }\r\n}\r\n\r\n/**\r\n * Process Stripe payment\r\n */\r\nasync function processStripePayment(\r\n  request: PaymentRequest,\r\n  providerConfig: any\r\n): Promise<PaymentResult> {\r\n  try {\r\n    // Get Stripe API key\r\n    const orgId = request.organizationId || request.workspaceId.split('/')[0]; // Use org ID directly or extract from workspace\r\n    const stripeKey = await apiKeyService.getServiceKey(orgId, 'stripe');\r\n    \r\n    if (!stripeKey) {\r\n      return {\r\n        success: false,\r\n        error: 'Stripe API key not configured',\r\n      };\r\n    }\r\n    \r\n    const apiKey = typeof stripeKey === 'string' ? stripeKey : stripeKey.apiKey;\r\n    if (!apiKey) {\r\n      return {\r\n        success: false,\r\n        error: 'Stripe API key not found',\r\n      };\r\n    }\r\n    \r\n    // Use Stripe API\r\n    const stripe = await import('stripe');\r\n    const stripeClient = new stripe.Stripe(apiKey, {\r\n      apiVersion: '2023-10-16',\r\n    });\r\n    \r\n    // Create payment intent\r\n    const paymentIntent = await stripeClient.paymentIntents.create({\r\n      amount: Math.round(request.amount * 100), // Convert to cents\r\n      currency: request.currency.toLowerCase(),\r\n      payment_method: request.paymentToken,\r\n      confirm: true,\r\n      return_url: `${process.env.NEXT_PUBLIC_APP_URL}/checkout/complete`,\r\n      metadata: {\r\n        workspaceId: request.workspaceId,\r\n        customerEmail: request.customer.email,\r\n        ...request.metadata,\r\n      },\r\n    });\r\n    \r\n    if (paymentIntent.status === 'succeeded') {\r\n      // Get payment method details if available\r\n      let cardLast4: string | undefined;\r\n      let cardBrand: string | undefined;\r\n      \r\n      if (paymentIntent.payment_method && typeof paymentIntent.payment_method === 'string') {\r\n        // Fetch payment method details\r\n        try {\r\n          const pm = await stripeClient.paymentMethods.retrieve(paymentIntent.payment_method);\r\n          cardLast4 = (pm as any).card?.last4;\r\n          cardBrand = (pm as any).card?.brand;\r\n        } catch (e) {\r\n          // Ignore if can't fetch\r\n        }\r\n      }\r\n      \r\n      return {\r\n        success: true,\r\n        transactionId: paymentIntent.id,\r\n        provider: 'stripe',\r\n        cardLast4,\r\n        cardBrand,\r\n        processingFee: calculateStripeFee(request.amount),\r\n      };\r\n    } else {\r\n      return {\r\n        success: false,\r\n        error: `Payment status: ${paymentIntent.status}`,\r\n      };\r\n    }\r\n  } catch (error: any) {\r\n    logger.error('Stripe payment error:', error, { file: 'payment-service.ts' });\r\n    return {\r\n      success: false,\r\n      error: error.message || 'Payment processing failed',\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Calculate Stripe processing fee\r\n */\r\nexport function calculateStripeFee(amount: number): number {\r\n  // Stripe fee: 2.9% + $0.30\r\n  return amount * 0.029 + 0.30;\r\n}\r\n\r\n/**\r\n * Process Square payment\r\n */\r\nasync function processSquarePayment(\r\n  request: PaymentRequest,\r\n  providerConfig: any\r\n): Promise<PaymentResult> {\r\n  try {\r\n    // Get Square API credentials\r\n    const orgId = request.workspaceId.split('/')[0];\r\n    const squareKeys = await apiKeyService.getServiceKey(orgId, 'square');\r\n    \r\n    if (!squareKeys) {\r\n      return {\r\n        success: false,\r\n        error: 'Square API credentials not configured',\r\n      };\r\n    }\r\n    \r\n    const { accessToken, locationId } = squareKeys as any;\r\n    \r\n    if (!accessToken || !locationId) {\r\n      return {\r\n        success: false,\r\n        error: 'Square access token or location ID missing',\r\n      };\r\n    }\r\n    \r\n    // Use Square API\r\n    const square = await import('square');\r\n    const client = new square.SquareClient({\r\n      token: accessToken,\r\n      environment: providerConfig.mode === 'production' ? square.SquareEnvironment.Production : square.SquareEnvironment.Sandbox,\r\n    });\r\n    \r\n    // Create payment\r\n    const response = await client.payments.create({\r\n      sourceId: request.paymentToken || '', // Square payment token from frontend\r\n      idempotencyKey: `${request.workspaceId}-${Date.now()}`, // Unique key\r\n      amountMoney: {\r\n        amount: BigInt(Math.round(request.amount * 100)), // Convert to cents\r\n        currency: request.currency.toUpperCase() as any,\r\n      },\r\n      locationId,\r\n      customerId: undefined, // Can link to Square customer\r\n      referenceId: request.metadata?.orderId,\r\n      note: `Payment for ${request.customer.email}`,\r\n      buyerEmailAddress: request.customer.email,\r\n    });\r\n    \r\n    if (response.payment) {\r\n      const payment = response.payment;\r\n      \r\n      return {\r\n        success: true,\r\n        transactionId: payment.id || '',\r\n        provider: 'square',\r\n        cardLast4: payment.cardDetails?.card?.last4,\r\n        cardBrand: payment.cardDetails?.card?.cardBrand,\r\n        processingFee: calculateSquareFee(request.amount),\r\n      };\r\n    } else {\r\n      return {\r\n        success: false,\r\n        error: response.errors?.[0]?.detail || 'Square payment failed',\r\n      };\r\n    }\r\n  } catch (error: any) {\r\n    logger.error('Square payment error:', error, { file: 'payment-service.ts' });\r\n    return {\r\n      success: false,\r\n      error: error.message || 'Square payment processing failed',\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Calculate Square processing fee\r\n */\r\nexport function calculateSquareFee(amount: number): number {\r\n  // Square fee: 2.6% + $0.10 (card present) or 2.9% + $0.30 (card not present)\r\n  // Using card not present rate\r\n  return amount * 0.029 + 0.30;\r\n}\r\n\r\n/**\r\n * Process PayPal payment\r\n */\r\nasync function processPayPalPayment(\r\n  request: PaymentRequest,\r\n  providerConfig: any\r\n): Promise<PaymentResult> {\r\n  try {\r\n    // Get PayPal API credentials\r\n    const orgId = request.workspaceId.split('/')[0];\r\n    const paypalKeys = await apiKeyService.getServiceKey(orgId, 'paypal');\r\n    \r\n    if (!paypalKeys) {\r\n      return {\r\n        success: false,\r\n        error: 'PayPal API credentials not configured',\r\n      };\r\n    }\r\n    \r\n    const { clientId, clientSecret, mode } = paypalKeys as any;\r\n    \r\n    if (!clientId || !clientSecret) {\r\n      return {\r\n        success: false,\r\n        error: 'PayPal client ID or secret missing',\r\n      };\r\n    }\r\n    \r\n    // PayPal API base URL\r\n    const baseURL = mode === 'live' \r\n      ? 'https://api-m.paypal.com'\r\n      : 'https://api-m.sandbox.paypal.com';\r\n    \r\n    // Get access token\r\n    const authResponse = await fetch(`${baseURL}/v1/oauth2/token`, {\r\n      method: 'POST',\r\n      headers: {\r\n        'Accept': 'application/json',\r\n        'Accept-Language': 'en_US',\r\n        'Content-Type': 'application/x-www-form-urlencoded',\r\n        'Authorization': `Basic ${Buffer.from(`${clientId}:${clientSecret}`).toString('base64')}`,\r\n      },\r\n      body: 'grant_type=client_credentials',\r\n    });\r\n    \r\n    if (!authResponse.ok) {\r\n      return {\r\n        success: false,\r\n        error: 'PayPal authentication failed',\r\n      };\r\n    }\r\n    \r\n    const { access_token } = await authResponse.json();\r\n    \r\n    // Create order\r\n    const orderResponse = await fetch(`${baseURL}/v2/checkout/orders`, {\r\n      method: 'POST',\r\n      headers: {\r\n        'Content-Type': 'application/json',\r\n        'Authorization': `Bearer ${access_token}`,\r\n      },\r\n      body: JSON.stringify({\r\n        intent: 'CAPTURE',\r\n        purchase_units: [{\r\n          reference_id: request.metadata?.orderId || 'default',\r\n          amount: {\r\n            currency_code: request.currency.toUpperCase(),\r\n            value: request.amount.toFixed(2),\r\n          },\r\n          description: `Payment from ${request.customer.email}`,\r\n        }],\r\n        payer: {\r\n          email_address: request.customer.email,\r\n          name: {\r\n            given_name: request.customer.firstName,\r\n            surname: request.customer.lastName,\r\n          },\r\n        },\r\n      }),\r\n    });\r\n    \r\n    if (!orderResponse.ok) {\r\n      const error = await orderResponse.json();\r\n      return {\r\n        success: false,\r\n        error: error.message || 'PayPal order creation failed',\r\n      };\r\n    }\r\n    \r\n    const order = await orderResponse.json();\r\n    \r\n    // If we have a payment token (order ID from frontend), capture it\r\n    if (request.paymentToken) {\r\n      const captureResponse = await fetch(`${baseURL}/v2/checkout/orders/${request.paymentToken}/capture`, {\r\n        method: 'POST',\r\n        headers: {\r\n          'Content-Type': 'application/json',\r\n          'Authorization': `Bearer ${access_token}`,\r\n        },\r\n      });\r\n      \r\n      if (!captureResponse.ok) {\r\n        return {\r\n          success: false,\r\n          error: 'PayPal payment capture failed',\r\n        };\r\n      }\r\n      \r\n      const captureResult = await captureResponse.json();\r\n      \r\n      if (captureResult.status === 'COMPLETED') {\r\n        return {\r\n          success: true,\r\n          transactionId: captureResult.id,\r\n          provider: 'paypal',\r\n          processingFee: calculatePayPalFee(request.amount),\r\n        };\r\n      } else {\r\n        return {\r\n          success: false,\r\n          error: `PayPal payment status: ${captureResult.status}`,\r\n        };\r\n      }\r\n    }\r\n    \r\n    // Return order ID for frontend to complete\r\n    return {\r\n      success: true,\r\n      transactionId: order.id,\r\n      provider: 'paypal',\r\n    };\r\n    \r\n  } catch (error: any) {\r\n    logger.error('PayPal payment error:', error, { file: 'payment-service.ts' });\r\n    return {\r\n      success: false,\r\n      error: error.message || 'PayPal payment processing failed',\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Calculate PayPal processing fee\r\n */\r\nexport function calculatePayPalFee(amount: number): number {\r\n  // PayPal fee: 2.9% + $0.30 (standard)\r\n  return amount * 0.029 + 0.30;\r\n}\r\n\r\n/**\r\n * Calculate Razorpay processing fee (approximate)\r\n */\r\nexport function calculateRazorpayFee(amount: number): number {\r\n  // Razorpay: ~2% + small fixed; use 2% baseline\r\n  return amount * 0.02;\r\n}\r\n\r\n/**\r\n * Refund payment\r\n */\r\nexport async function refundPayment(\r\n  workspaceId: string,\r\n  organizationId: string,\r\n  transactionId: string,\r\n  amount?: number\r\n): Promise<PaymentResult> {\r\n  // Get provider from transaction\r\n  const { FirestoreService, COLLECTIONS } = await import('@/lib/db/firestore-service');\r\n  \r\n  // Find order with this transaction ID\r\n  const { where } = await import('firebase/firestore');\r\n  const orders = await FirestoreService.getAll(\r\n    `${COLLECTIONS.ORGANIZATIONS}/${organizationId}/workspaces/${workspaceId}/orders`,\r\n    [where('payment.transactionId', '==', transactionId)]\r\n  );\r\n  \r\n  if (orders.length === 0) {\r\n    return {\r\n      success: false,\r\n      error: 'Order not found',\r\n    };\r\n  }\r\n  \r\n  const order = orders[0] as any;\r\n  const provider = order.payment.provider;\r\n  \r\n  // Route to appropriate provider\r\n  switch (provider) {\r\n    case 'stripe':\r\n      return refundStripePayment(transactionId, amount);\r\n    \r\n    default:\r\n      return {\r\n        success: false,\r\n        error: `Refund for provider ${provider} not yet implemented`,\r\n      };\r\n  }\r\n}\r\n\r\n/**\r\n * Refund Stripe payment\r\n */\r\nasync function refundStripePayment(\r\n  transactionId: string,\r\n  amount?: number,\r\n  workspaceId?: string\r\n): Promise<PaymentResult> {\r\n  try {\r\n    // Get Stripe API key from workspace settings\r\n    // Note: workspaceId should be passed from the refund() caller\r\n    if (!workspaceId) {\r\n      throw new Error('Workspace ID required for Stripe refunds');\r\n    }\r\n    \r\n    const { apiKeyService } = await import('@/lib/api-keys/api-key-service');\r\n    const apiKeys = await apiKeyService.getKeys(workspaceId);\r\n    \r\n    if (!apiKeys?.payments?.stripe?.secretKey) {\r\n      throw new Error('Stripe not configured. Please add your Stripe API key in Settings > API Keys');\r\n    }\r\n    \r\n    const stripe = await import('stripe');\r\n    const stripeClient = new stripe.Stripe(apiKeys.payments.stripe.secretKey, {\r\n      apiVersion: '2023-10-16',\r\n    });\r\n    \r\n    const refund = await stripeClient.refunds.create({\r\n      payment_intent: transactionId,\r\n      amount: amount ? Math.round(amount * 100) : undefined, // Partial refund if amount specified\r\n    });\r\n    \r\n    return {\r\n      success: true,\r\n      transactionId: refund.id,\r\n      provider: 'stripe',\r\n    };\r\n  } catch (error: any) {\r\n    return {\r\n      success: false,\r\n      error: error.message || 'Refund failed',\r\n    };\r\n  }\r\n}\r\n\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\David\\PycharmProjects\\AI Sales Platform\\src\\lib\\enrichment\\backup-sources.ts","messages":[{"ruleId":"no-empty","severity":2,"message":"Empty block statement.","line":70,"column":17,"nodeType":"BlockStatement","messageId":"unexpected","endLine":70,"endColumn":19,"suggestions":[{"messageId":"suggestComment","data":{"type":"block"},"fix":{"range":[2474,2474],"text":" /* empty */ "},"desc":"Add comment inside empty block statement."}]},{"ruleId":"no-empty","severity":2,"message":"Empty block statement.","line":82,"column":17,"nodeType":"BlockStatement","messageId":"unexpected","endLine":82,"endColumn":19,"suggestions":[{"messageId":"suggestComment","data":{"type":"block"},"fix":{"range":[3181,3181],"text":" /* empty */ "},"desc":"Add comment inside empty block statement."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Free Backup Data Sources\r\n * When web scraping fails, use these FREE sources to get partial data\r\n * NO paid APIs - all free tier or public data\r\n */\r\n\r\nimport type { CompanyEnrichmentData } from './types'\r\nimport { logger } from '../logger/logger';;\r\n\r\n/**\r\n * Get company data from WHOIS (free)\r\n */\r\nexport async function getWhoisData(domain: string): Promise<Partial<CompanyEnrichmentData>> {\r\n  try {\r\n    logger.info('WHOIS Looking up domain}...', { file: 'backup-sources.ts' });\r\n    \r\n    // Use a free WHOIS API\r\n    const response = await fetch(`https://www.whoisxmlapi.com/whoisserver/WhoisService?domainName=${domain}&apiKey=at_00000000000000000000000000000&outputFormat=JSON`);\r\n    \r\n    if (!response.ok) {\r\n      return {};\r\n    }\r\n    \r\n    const data = await response.json();\r\n    const registrant = data.WhoisRecord?.registrant || {};\r\n    \r\n    return {\r\n      headquarters: {\r\n        city: registrant.city,\r\n        state: registrant.state,\r\n        country: registrant.country,\r\n      },\r\n      contactEmail: registrant.email,\r\n      contactPhone: registrant.telephone,\r\n    };\r\n  } catch (error) {\r\n    logger.error('[WHOIS] Error:', error, { file: 'backup-sources.ts' });\r\n    return {};\r\n  }\r\n}\r\n\r\n/**\r\n * Get tech stack from DNS records (free)\r\n * Note: DNS lookups work server-side only (not in browser/edge)\r\n */\r\nexport async function getTechStackFromDNS(domain: string): Promise<string[]> {\r\n  try {\r\n    logger.info('DNS Checking tech stack for domain}...', { file: 'backup-sources.ts' });\r\n    \r\n    const techStack: string[] = [];\r\n    \r\n    // Only try DNS if we're in Node.js environment\r\n    if (typeof process !== 'undefined' && process.versions && process.versions.node) {\r\n      try {\r\n        // Dynamic import to avoid edge runtime issues\r\n        const dns = await import('dns').then(mod => mod.promises);\r\n        \r\n        // Check MX records for email provider\r\n        try {\r\n          const mxRecords = await dns.resolveMx(domain);\r\n          \r\n          if (mxRecords && mxRecords.length > 0) {\r\n            const mx = mxRecords[0].exchange.toLowerCase();\r\n            \r\n            if (mx.includes('google')) techStack.push('Google Workspace');\r\n            if (mx.includes('outlook') || mx.includes('microsoft')) techStack.push('Microsoft 365');\r\n            if (mx.includes('mailgun')) techStack.push('Mailgun');\r\n            if (mx.includes('sendgrid')) techStack.push('SendGrid');\r\n          }\r\n        } catch {}\r\n        \r\n        // Check TXT records for verification codes\r\n        try {\r\n          const txtRecords = await dns.resolveTxt(domain);\r\n          const txtString = txtRecords.flat().join(' ').toLowerCase();\r\n          \r\n          if (txtString.includes('google-site-verification')) techStack.push('Google Analytics');\r\n          if (txtString.includes('facebook-domain-verification')) techStack.push('Facebook Pixel');\r\n          if (txtString.includes('stripe-verification')) techStack.push('Stripe');\r\n          if (txtString.includes('v=spf') && txtString.includes('mailchimp')) techStack.push('Mailchimp');\r\n          if (txtString.includes('hubspot')) techStack.push('HubSpot');\r\n        } catch {}\r\n      } catch (error) {\r\n        logger.warn('[DNS] DNS module not available in this environment', { file: 'backup-sources.ts' });\r\n      }\r\n    }\r\n    \r\n    return [...new Set(techStack)];\r\n  } catch (error) {\r\n    logger.error('[DNS] Error:', error, { file: 'backup-sources.ts' });\r\n    return [];\r\n  }\r\n}\r\n\r\n/**\r\n * Get company data from Crunchbase public API (free tier: 200/day)\r\n */\r\nexport async function getCrunchbaseData(companyName: string): Promise<Partial<CompanyEnrichmentData>> {\r\n  try {\r\n    const apiKey = process.env.CRUNCHBASE_API_KEY;\r\n    \r\n    if (!apiKey) {\r\n      logger.warn('[Crunchbase] API key not configured', { file: 'backup-sources.ts' });\r\n      return {};\r\n    }\r\n    \r\n    logger.info('Crunchbase Looking up companyName}...', { file: 'backup-sources.ts' });\r\n    \r\n    const response = await fetch(\r\n      `https://api.crunchbase.com/api/v4/autocompletes?query=${encodeURIComponent(companyName)}&collection_ids=organizations&user_key=${apiKey}`\r\n    );\r\n    \r\n    if (!response.ok) {\r\n      return {};\r\n    }\r\n    \r\n    const data = await response.json();\r\n    const org = data.entities?.[0];\r\n    \r\n    if (!org) {\r\n      return {};\r\n    }\r\n    \r\n    // Get organization details\r\n    const detailsResponse = await fetch(\r\n      `https://api.crunchbase.com/api/v4/entities/organizations/${org.identifier.uuid}?user_key=${apiKey}`\r\n    );\r\n    \r\n    if (!detailsResponse.ok) {\r\n      return {};\r\n    }\r\n    \r\n    const details = await detailsResponse.json();\r\n    const props = details.properties || {};\r\n    \r\n    return {\r\n      description: props.short_description,\r\n      foundedYear: props.founded_on?.year,\r\n      headquarters: {\r\n        city: props.location_identifiers?.[0]?.value,\r\n        country: props.location_identifiers?.[0]?.location_type,\r\n      },\r\n      employeeCount: props.num_employees_enum,\r\n      fundingStage: props.funding_stage,\r\n      revenue: props.revenue_range,\r\n    };\r\n  } catch (error) {\r\n    logger.error('[Crunchbase] Error:', error, { file: 'backup-sources.ts' });\r\n    return {};\r\n  }\r\n}\r\n\r\n/**\r\n * Get company data from Google Knowledge Graph (free)\r\n */\r\nexport async function getGoogleKnowledgeGraph(companyName: string): Promise<Partial<CompanyEnrichmentData>> {\r\n  try {\r\n    const apiKey = process.env.GOOGLE_KNOWLEDGE_GRAPH_API_KEY;\r\n    \r\n    if (!apiKey) {\r\n      logger.warn('[Google KG] API key not configured', { file: 'backup-sources.ts' });\r\n      return {};\r\n    }\r\n    \r\n    logger.info('Google KG Looking up companyName}...', { file: 'backup-sources.ts' });\r\n    \r\n    const response = await fetch(\r\n      `https://kgsearch.googleapis.com/v1/entities:search?query=${encodeURIComponent(companyName)}&types=Organization&key=${apiKey}&limit=1`\r\n    );\r\n    \r\n    if (!response.ok) {\r\n      return {};\r\n    }\r\n    \r\n    const data = await response.json();\r\n    const entity = data.itemListElement?.[0]?.result;\r\n    \r\n    if (!entity) {\r\n      return {};\r\n    }\r\n    \r\n    return {\r\n      name: entity.name,\r\n      description: entity.description || entity.detailedDescription?.articleBody,\r\n      website: entity.url,\r\n    };\r\n  } catch (error) {\r\n    logger.error('[Google KG] Error:', error, { file: 'backup-sources.ts' });\r\n    return {};\r\n  }\r\n}\r\n\r\n/**\r\n * Get company data from Wikipedia API (free)\r\n */\r\nexport async function getWikipediaData(companyName: string): Promise<Partial<CompanyEnrichmentData>> {\r\n  try {\r\n    logger.info('Wikipedia Looking up companyName}...', { file: 'backup-sources.ts' });\r\n    \r\n    // Search for page\r\n    const searchResponse = await fetch(\r\n      `https://en.wikipedia.org/w/api.php?action=query&list=search&srsearch=${encodeURIComponent(companyName)}&format=json&origin=*`\r\n    );\r\n    \r\n    if (!searchResponse.ok) {\r\n      return {};\r\n    }\r\n    \r\n    const searchData = await searchResponse.json();\r\n    const pageTitle = searchData.query?.search?.[0]?.title;\r\n    \r\n    if (!pageTitle) {\r\n      return {};\r\n    }\r\n    \r\n    // Get page extract\r\n    const extractResponse = await fetch(\r\n      `https://en.wikipedia.org/w/api.php?action=query&titles=${encodeURIComponent(pageTitle)}&prop=extracts&exintro=true&format=json&origin=*`\r\n    );\r\n    \r\n    if (!extractResponse.ok) {\r\n      return {};\r\n    }\r\n    \r\n    const extractData = await extractResponse.json();\r\n    const pages = extractData.query?.pages || {};\r\n    const page = Object.values(pages)[0] as any;\r\n    \r\n    if (!page || !page.extract) {\r\n      return {};\r\n    }\r\n    \r\n    // Clean HTML from extract\r\n    const description = page.extract\r\n      .replace(/<[^>]*>/g, '')\r\n      .replace(/\\s+/g, ' ')\r\n      .trim()\r\n      .substring(0, 500);\r\n    \r\n    return {\r\n      description,\r\n    };\r\n  } catch (error) {\r\n    logger.error('[Wikipedia] Error:', error, { file: 'backup-sources.ts' });\r\n    return {};\r\n  }\r\n}\r\n\r\n/**\r\n * Try all free backup sources and merge data\r\n */\r\nexport async function getAllBackupData(\r\n  companyName: string,\r\n  domain: string\r\n): Promise<Partial<CompanyEnrichmentData>> {\r\n  logger.info('[Backup Sources] Fetching from all free sources...', { file: 'backup-sources.ts' });\r\n  \r\n  // Run all in parallel\r\n  const [whois, dns, crunchbase, google, wikipedia] = await Promise.all([\r\n    getWhoisData(domain),\r\n    getTechStackFromDNS(domain),\r\n    getCrunchbaseData(companyName),\r\n    getGoogleKnowledgeGraph(companyName),\r\n    getWikipediaData(companyName),\r\n  ]);\r\n  \r\n  // Merge data (later sources override earlier ones)\r\n  const merged: Partial<CompanyEnrichmentData> = {\r\n    ...whois,\r\n    ...crunchbase,\r\n    ...google,\r\n    ...wikipedia,\r\n  };\r\n  \r\n  // Add tech stack from DNS\r\n  if (dns.length > 0) {\r\n    merged.techStack = [...(merged.techStack || []), ...dns];\r\n  }\r\n  \r\n  logger.info('[Backup Sources] Merged data from backup sources', { file: 'backup-sources.ts' });\r\n  \r\n  return merged;\r\n}\r\n\r\n\r\n\r\n\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\David\\PycharmProjects\\AI Sales Platform\\src\\lib\\enrichment\\validation-service.ts","messages":[{"ruleId":"no-useless-escape","severity":2,"message":"Unnecessary escape character: \\(.","line":158,"column":39,"nodeType":"Literal","messageId":"unnecessaryEscape","endLine":158,"endColumn":40,"suggestions":[{"messageId":"removeEscape","fix":{"range":[4427,4428],"text":""},"desc":"Remove the `\\`. This maintains the current functionality."},{"messageId":"escapeBackslash","fix":{"range":[4427,4427],"text":"\\"},"desc":"Replace the `\\` with `\\\\` to include the actual backslash character."}]},{"ruleId":"no-useless-escape","severity":2,"message":"Unnecessary escape character: \\).","line":158,"column":41,"nodeType":"Literal","messageId":"unnecessaryEscape","endLine":158,"endColumn":42,"suggestions":[{"messageId":"removeEscape","fix":{"range":[4429,4430],"text":""},"desc":"Remove the `\\`. This maintains the current functionality."},{"messageId":"escapeBackslash","fix":{"range":[4429,4429],"text":"\\"},"desc":"Replace the `\\` with `\\\\` to include the actual backslash character."}]},{"ruleId":"no-useless-escape","severity":2,"message":"Unnecessary escape character: \\+.","line":158,"column":43,"nodeType":"Literal","messageId":"unnecessaryEscape","endLine":158,"endColumn":44,"suggestions":[{"messageId":"removeEscape","fix":{"range":[4431,4432],"text":""},"desc":"Remove the `\\`. This maintains the current functionality."},{"messageId":"escapeBackslash","fix":{"range":[4431,4431],"text":"\\"},"desc":"Replace the `\\` with `\\\\` to include the actual backslash character."}]},{"ruleId":"no-useless-escape","severity":2,"message":"Unnecessary escape character: \\..","line":158,"column":45,"nodeType":"Literal","messageId":"unnecessaryEscape","endLine":158,"endColumn":46,"suggestions":[{"messageId":"removeEscape","fix":{"range":[4433,4434],"text":""},"desc":"Remove the `\\`. This maintains the current functionality."},{"messageId":"escapeBackslash","fix":{"range":[4433,4433],"text":"\\"},"desc":"Replace the `\\` with `\\\\` to include the actual backslash character."}]}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Data Validation Service\r\n * Validates enriched data for accuracy and consistency\r\n * Prevents bad/fake data from being stored\r\n */\r\n\r\nimport type { CompanyEnrichmentData } from './types';\r\n\r\nexport interface ValidationResult {\r\n  isValid: boolean;\r\n  confidence: number; // 0-100\r\n  errors: string[];\r\n  warnings: string[];\r\n  checks: {\r\n    domainValid: boolean;\r\n    emailValid: boolean;\r\n    phoneValid: boolean;\r\n    dataConsistent: boolean;\r\n    sourcesReliable: boolean;\r\n  };\r\n}\r\n\r\n/**\r\n * Validate enriched company data\r\n */\r\nexport async function validateEnrichmentData(\r\n  data: CompanyEnrichmentData\r\n): Promise<ValidationResult> {\r\n  const errors: string[] = [];\r\n  const warnings: string[] = [];\r\n  \r\n  // Check 1: Domain validation\r\n  const domainValid = await validateDomain(data.domain);\r\n  if (!domainValid) {\r\n    errors.push(`Domain ${data.domain} does not exist or is unreachable`);\r\n  }\r\n  \r\n  // Check 2: Email validation\r\n  const emailValid = data.contactEmail ? validateEmail(data.contactEmail) : true;\r\n  if (data.contactEmail && !emailValid) {\r\n    warnings.push(`Email ${data.contactEmail} format is invalid`);\r\n  }\r\n  \r\n  // Check 3: Phone validation\r\n  const phoneValid = data.contactPhone ? validatePhone(data.contactPhone) : true;\r\n  if (data.contactPhone && !phoneValid) {\r\n    warnings.push(`Phone ${data.contactPhone} format is invalid`);\r\n  }\r\n  \r\n  // Check 4: Data consistency\r\n  const consistencyChecks = validateConsistency(data);\r\n  consistencyChecks.errors.forEach(e => errors.push(e));\r\n  consistencyChecks.warnings.forEach(w => warnings.push(w));\r\n  \r\n  // Check 5: Required fields\r\n  if (!data.name || data.name === 'Unknown') {\r\n    errors.push('Company name is missing or invalid');\r\n  }\r\n  \r\n  if (!data.website || !data.domain) {\r\n    errors.push('Website/domain is missing');\r\n  }\r\n  \r\n  // Calculate confidence score\r\n  let confidence = 100;\r\n  \r\n  // Deduct points for errors and warnings\r\n  confidence -= errors.length * 20;\r\n  confidence -= warnings.length * 5;\r\n  \r\n  // Deduct for missing data\r\n  if (!data.description || data.description.length < 20) confidence -= 10;\r\n  if (!data.industry || data.industry === 'Unknown') confidence -= 10;\r\n  if (!data.employeeCount && !data.employeeRange) confidence -= 5;\r\n  if (!data.headquarters?.city) confidence -= 5;\r\n  if (!data.socialMedia?.linkedin) confidence -= 5;\r\n  \r\n  // Add points for extra data\r\n  if (data.techStack && data.techStack.length > 0) confidence += 5;\r\n  if (data.recentNews && data.recentNews.length > 0) confidence += 5;\r\n  if (data.fundingStage) confidence += 5;\r\n  if (data.revenue) confidence += 5;\r\n  \r\n  confidence = Math.max(0, Math.min(100, confidence));\r\n  \r\n  const isValid = errors.length === 0;\r\n  \r\n  return {\r\n    isValid,\r\n    confidence,\r\n    errors,\r\n    warnings,\r\n    checks: {\r\n      domainValid,\r\n      emailValid,\r\n      phoneValid,\r\n      dataConsistent: consistencyChecks.errors.length === 0,\r\n      sourcesReliable: data.dataSource === 'hybrid' || data.dataSource === 'search-api',\r\n    },\r\n  };\r\n}\r\n\r\n/**\r\n * Validate domain exists and is reachable\r\n */\r\nasync function validateDomain(domain: string): Promise<boolean> {\r\n  try {\r\n    // Try HTTP request\r\n    const controller = new AbortController();\r\n    const timeoutId = setTimeout(() => controller.abort(), 5000);\r\n    \r\n    const response = await fetch(`https://${domain}`, {\r\n      method: 'HEAD',\r\n      signal: controller.signal,\r\n    });\r\n    \r\n    clearTimeout(timeoutId);\r\n    return response.ok || response.status < 500; // Even 404 means domain exists\r\n  } catch (error: any) {\r\n    // Domain doesn't exist or is unreachable\r\n    return false;\r\n  }\r\n}\r\n\r\n/**\r\n * Validate email format\r\n */\r\nfunction validateEmail(email: string): boolean {\r\n  const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\r\n  \r\n  if (!emailRegex.test(email)) {\r\n    return false;\r\n  }\r\n  \r\n  // Check for common fake/placeholder emails\r\n  const fakeEmails = [\r\n    'test@test.com',\r\n    'admin@admin.com',\r\n    'info@info.com',\r\n    'contact@contact.com',\r\n    'example@example.com',\r\n    'noreply@',\r\n  ];\r\n  \r\n  const lowerEmail = email.toLowerCase();\r\n  if (fakeEmails.some(fake => lowerEmail.includes(fake))) {\r\n    return false;\r\n  }\r\n  \r\n  return true;\r\n}\r\n\r\n/**\r\n * Validate phone number format\r\n */\r\nfunction validatePhone(phone: string): boolean {\r\n  // Remove common formatting characters\r\n  const cleaned = phone.replace(/[\\s\\-\\(\\)\\+\\.]/g, '');\r\n  \r\n  // Should be 10-15 digits\r\n  if (cleaned.length < 10 || cleaned.length > 15) {\r\n    return false;\r\n  }\r\n  \r\n  // Should be all digits\r\n  if (!/^\\d+$/.test(cleaned)) {\r\n    return false;\r\n  }\r\n  \r\n  // Check for obviously fake numbers\r\n  const fakePatterns = [\r\n    '0000000000',\r\n    '1111111111',\r\n    '1234567890',\r\n    '9999999999',\r\n  ];\r\n  \r\n  if (fakePatterns.includes(cleaned)) {\r\n    return false;\r\n  }\r\n  \r\n  return true;\r\n}\r\n\r\n/**\r\n * Validate data consistency\r\n */\r\nfunction validateConsistency(data: CompanyEnrichmentData): {\r\n  errors: string[];\r\n  warnings: string[];\r\n} {\r\n  const errors: string[] = [];\r\n  const warnings: string[] = [];\r\n  \r\n  // Check employee count matches size category\r\n  if (data.employeeCount) {\r\n    const count = data.employeeCount;\r\n    \r\n    if (data.size === 'startup' && count >= 50) {\r\n      warnings.push(`Employee count (${count}) doesn't match size category (startup)`);\r\n    } else if (data.size === 'small' && (count < 50 || count > 200)) {\r\n      warnings.push(`Employee count (${count}) doesn't match size category (small)`);\r\n    } else if (data.size === 'medium' && (count < 200 || count > 1000)) {\r\n      warnings.push(`Employee count (${count}) doesn't match size category (medium)`);\r\n    } else if (data.size === 'enterprise' && count < 1000) {\r\n      warnings.push(`Employee count (${count}) doesn't match size category (enterprise)`);\r\n    }\r\n  }\r\n  \r\n  // Check founded year is reasonable\r\n  if (data.foundedYear) {\r\n    const currentYear = new Date().getFullYear();\r\n    \r\n    if (data.foundedYear < 1800) {\r\n      errors.push(`Founded year (${data.foundedYear}) is unrealistically old`);\r\n    } else if (data.foundedYear > currentYear) {\r\n      errors.push(`Founded year (${data.foundedYear}) is in the future`);\r\n    } else if (data.foundedYear > currentYear - 1) {\r\n      warnings.push(`Company founded very recently (${data.foundedYear})`);\r\n    }\r\n  }\r\n  \r\n  // Check domain matches website\r\n  if (data.website && data.domain) {\r\n    try {\r\n      const websiteHost = new URL(data.website).hostname.replace('www.', '');\r\n      const domain = data.domain.replace('www.', '');\r\n      \r\n      if (websiteHost !== domain) {\r\n        warnings.push(`Website hostname (${websiteHost}) doesn't match domain (${domain})`);\r\n      }\r\n    } catch {\r\n      errors.push(`Website URL (${data.website}) is malformed`);\r\n    }\r\n  }\r\n  \r\n  // Check email domain matches company domain\r\n  if (data.contactEmail && data.domain) {\r\n    const emailDomain = data.contactEmail.split('@')[1];\r\n    \r\n    if (emailDomain !== data.domain) {\r\n      // Could be fine (using Gmail, etc.) but worth noting\r\n      warnings.push(`Email domain (${emailDomain}) doesn't match company domain (${data.domain})`);\r\n    }\r\n  }\r\n  \r\n  // Check description quality\r\n  if (data.description) {\r\n    if (data.description.length < 20) {\r\n      warnings.push('Description is very short');\r\n    }\r\n    \r\n    // Check for placeholder text\r\n    const placeholders = ['lorem ipsum', 'coming soon', 'under construction'];\r\n    if (placeholders.some(p => data.description.toLowerCase().includes(p))) {\r\n      errors.push('Description contains placeholder text');\r\n    }\r\n  }\r\n  \r\n  return { errors, warnings };\r\n}\r\n\r\n/**\r\n * Verify email domain exists (simplified - no DNS dependency)\r\n */\r\nexport async function verifyEmailDomain(email: string): Promise<boolean> {\r\n  try {\r\n    const domain = email.split('@')[1];\r\n    \r\n    // Simple check - verify domain responds to HTTP\r\n    const controller = new AbortController();\r\n    const timeoutId = setTimeout(() => controller.abort(), 3000);\r\n    \r\n    const response = await fetch(`https://${domain}`, {\r\n      method: 'HEAD',\r\n      signal: controller.signal,\r\n    });\r\n    \r\n    clearTimeout(timeoutId);\r\n    return true; // Domain exists\r\n  } catch {\r\n    return false; // Domain doesn't exist\r\n  }\r\n}\r\n\r\n/**\r\n * Check if domain is on a common disposable email list\r\n */\r\nexport function isDisposableEmail(email: string): boolean {\r\n  const domain = email.split('@')[1]?.toLowerCase();\r\n  \r\n  const disposableDomains = [\r\n    'tempmail.com',\r\n    '10minutemail.com',\r\n    'guerrillamail.com',\r\n    'mailinator.com',\r\n    'throwaway.email',\r\n    'temp-mail.org',\r\n  ];\r\n  \r\n  return disposableDomains.includes(domain);\r\n}\r\n\r\n\r\n\r\n\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\David\\PycharmProjects\\AI Sales Platform\\src\\lib\\firebase-admin.ts","messages":[{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":35,"column":24,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":35,"endColumn":39},{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":36,"column":22,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":36,"endColumn":35}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Centralized Firebase Admin SDK Initialization\n * Single source of truth for all Firebase Admin operations\n */\n\nimport * as admin from 'firebase-admin';\nimport { getFirestore } from 'firebase-admin/firestore';\nimport { getAuth } from 'firebase-admin/auth';\n\n// Initialize Firebase Admin SDK once\nif (!admin.apps.length) {\n  try {\n    let credential;\n    \n    // Check for individual environment variables (Vercel format)\n    if (process.env.FIREBASE_ADMIN_PROJECT_ID && \n        process.env.FIREBASE_ADMIN_CLIENT_EMAIL && \n        process.env.FIREBASE_ADMIN_PRIVATE_KEY) {\n      credential = admin.credential.cert({\n        projectId: process.env.FIREBASE_ADMIN_PROJECT_ID,\n        clientEmail: process.env.FIREBASE_ADMIN_CLIENT_EMAIL,\n        privateKey: process.env.FIREBASE_ADMIN_PRIVATE_KEY.replace(/\\\\n/g, '\\n'),\n      });\n    }\n    // In production, use service account from environment (JSON blob)\n    else if (process.env.FIREBASE_SERVICE_ACCOUNT_KEY) {\n      const serviceAccount = JSON.parse(process.env.FIREBASE_SERVICE_ACCOUNT_KEY);\n      credential = admin.credential.cert(serviceAccount);\n    } \n    // In development, use service account file\n    else {\n      try {\n        // Only require in development when file exists\n        if (process.env.NODE_ENV === 'development') {\n          const path = require('path');\n          const fs = require('fs');\n          const keyPath = path.join(process.cwd(), 'serviceAccountKey.json');\n          \n          if (fs.existsSync(keyPath)) {\n            const serviceAccount = JSON.parse(fs.readFileSync(keyPath, 'utf8'));\n            credential = admin.credential.cert(serviceAccount);\n          } else {\n            throw new Error('serviceAccountKey.json not found');\n          }\n        } else {\n          // In production without env var, use application default\n          credential = admin.credential.applicationDefault();\n        }\n      } catch (error) {\n        console.error('[Firebase Admin] Service account error, using application default credentials');\n        credential = admin.credential.applicationDefault();\n      }\n    }\n\n    admin.initializeApp({\n      credential,\n      projectId: process.env.FIREBASE_ADMIN_PROJECT_ID,\n      storageBucket: process.env.FIREBASE_STORAGE_BUCKET,\n    });\n\n    console.log('[Firebase Admin] Initialized successfully');\n    console.log(`[Firebase Admin] ≡ƒÄ» PROJECT ID: ${process.env.FIREBASE_ADMIN_PROJECT_ID || 'NOT SET'}`);\n  } catch (error) {\n    console.error('[Firebase Admin] Initialization failed:', error);\n    throw error;\n  }\n}\n\n// Export commonly used services\nexport const db = getFirestore();\nexport const auth = getAuth();\nexport { admin };\n\n/**\n * Helper to get current user from request\n * TODO: Implement actual user authentication\n */\nexport async function getCurrentUser(request: Request): Promise<{\n  uid: string;\n  email?: string;\n  organizationId?: string;\n} | null> {\n  try {\n    const authHeader = request.headers.get('authorization');\n    if (!authHeader || !authHeader.startsWith('Bearer ')) {\n      return null;\n    }\n\n    const token = authHeader.split('Bearer ')[1];\n    const decodedToken = await auth.verifyIdToken(token);\n\n    // TODO: Fetch user's organizationId from Firestore\n    // For now, return basic user info\n    return {\n      uid: decodedToken.uid,\n      email: decodedToken.email,\n    };\n  } catch (error) {\n    console.error('[Auth] Failed to verify user:', error);\n    return null;\n  }\n}\n\n/**\n * Verify user has access to organization\n */\nexport async function verifyOrgAccess(\n  userId: string,\n  organizationId: string\n): Promise<boolean> {\n  try {\n    // Use environment-aware collection path via helper\n    const { getOrgSubCollection } = await import('./firebase/collections');\n    const membersPath = getOrgSubCollection(organizationId, 'members');\n    const userOrgRef = db.collection(membersPath).doc(userId);\n\n    const doc = await userOrgRef.get();\n    return doc.exists;\n  } catch (error) {\n    console.error('[Auth] Failed to verify org access:', error);\n    return false;\n  }\n}\n\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\David\\PycharmProjects\\AI Sales Platform\\src\\lib\\firebase\\admin.ts","messages":[{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":60,"column":20,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":60,"endColumn":33},{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":61,"column":22,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":61,"endColumn":37}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Firebase Admin SDK Configuration\r\n * Server-side only - for API routes and server actions\r\n */\r\n\r\nimport * as admin from 'firebase-admin'\r\nimport { logger } from '../logger/logger';;\r\n\r\n// Initialize Firebase Admin SDK (singleton)\r\nlet adminApp: admin.app.App | null = null;\r\n\r\nfunction initializeAdmin() {\r\n  // Already initialized\r\n  if (adminApp) {\r\n    return adminApp;\r\n  }\r\n\r\n  // Check if already initialized by another module\r\n  if (admin.apps.length > 0) {\r\n    adminApp = admin.apps[0];\r\n    return adminApp;\r\n  }\r\n\r\n  // Emulator support removed - tests use real dev database with cleanup\r\n\r\n  // For production/development - use service account\r\n  try {\r\n    let serviceAccount: admin.ServiceAccount | undefined;\r\n    \r\n    // Option 1: Full JSON in single env var\r\n    if (process.env.FIREBASE_SERVICE_ACCOUNT_KEY) {\r\n      serviceAccount = JSON.parse(process.env.FIREBASE_SERVICE_ACCOUNT_KEY);\r\n      logger.info('≡ƒöæ Using FIREBASE_SERVICE_ACCOUNT_KEY env var', { file: 'admin.ts' });\r\n    }\r\n    \r\n    // Option 2: Individual env vars (preferred for Vercel)\r\n    if (!serviceAccount && process.env.FIREBASE_ADMIN_PROJECT_ID && process.env.FIREBASE_ADMIN_PRIVATE_KEY) {\r\n      // Clean up private key: remove surrounding quotes and replace \\n with actual newlines\r\n      let privateKey = process.env.FIREBASE_ADMIN_PRIVATE_KEY;\r\n      \r\n      // Remove surrounding quotes if present (common when copying from JSON)\r\n      if (privateKey.startsWith('\"') && privateKey.endsWith('\"')) {\r\n        privateKey = privateKey.slice(1, -1);\r\n      }\r\n      \r\n      // Replace escaped newlines with actual newlines\r\n      privateKey = privateKey.replace(/\\\\n/g, '\\n');\r\n      \r\n      serviceAccount = {\r\n        projectId: process.env.FIREBASE_ADMIN_PROJECT_ID,\r\n        clientEmail: process.env.FIREBASE_ADMIN_CLIENT_EMAIL,\r\n        privateKey: privateKey,\r\n      };\r\n      logger.info('≡ƒöæ Using individual Firebase Admin env vars', { file: 'admin.ts' });\r\n    }\r\n\r\n    // Option 3: Try to load from file (local development)\r\n    if (!serviceAccount) {\r\n      try {\r\n        const fs = require('fs');\r\n        const path = require('path');\r\n        const keyPath = path.join(process.cwd(), 'serviceAccountKey.json');\r\n        logger.info('≡ƒöì Looking for serviceAccountKey.json', { path: keyPath, file: 'admin.ts' });\r\n        if (fs.existsSync(keyPath)) {\r\n          serviceAccount = JSON.parse(fs.readFileSync(keyPath, 'utf8'));\r\n          logger.info('≡ƒöæ Loaded serviceAccountKey.json successfully', { file: 'admin.ts' });\r\n        } else {\r\n          logger.warn('ΓÜá∩╕Å serviceAccountKey.json not found', { path: keyPath, file: 'admin.ts' });\r\n        }\r\n      } catch (e: any) {\r\n        logger.warn('ΓÜá∩╕Å Could not load serviceAccountKey.json', { error: e.message, file: 'admin.ts' });\r\n      }\r\n    }\r\n\r\n    if (serviceAccount) {\r\n      adminApp = admin.initializeApp({\r\n        credential: admin.credential.cert(serviceAccount),\r\n      });\r\n    } else {\r\n      // Use application default credentials (for GCP)\r\n      logger.warn('ΓÜá∩╕Å No Firebase credentials found, using default credentials', { file: 'admin.ts' });\r\n      adminApp = admin.initializeApp();\r\n    }\r\n\r\n    logger.info('≡ƒöÑ Firebase Admin initialized', { file: 'admin.ts' });\r\n    return adminApp;\r\n  } catch (error: any) {\r\n    if (error.code === 'app/duplicate-app') {\r\n      adminApp = admin.app();\r\n      return adminApp;\r\n    }\r\n    logger.error('Γ¥î Firebase Admin initialization failed', error, { file: 'admin.ts' });\r\n    throw error;\r\n  }\r\n}\r\n\r\n// Initialize on import (server-side only)\r\nif (typeof window === 'undefined') {\r\n  try {\r\n    logger.info('[Firebase Admin] Initializing...', { \r\n      projectId: process.env.FIREBASE_ADMIN_PROJECT_ID ? 'SET' : 'MISSING',\r\n      clientEmail: process.env.FIREBASE_ADMIN_CLIENT_EMAIL ? 'SET' : 'MISSING',\r\n      privateKey: process.env.FIREBASE_ADMIN_PRIVATE_KEY ? `SET (length: ${process.env.FIREBASE_ADMIN_PRIVATE_KEY.length})` : 'MISSING',\r\n      file: 'admin.ts' \r\n    });\r\n    initializeAdmin();\r\n    logger.info('[Firebase Admin] Γ£à Initialization complete', { \r\n      adminApp: adminApp ? 'INITIALIZED' : 'NULL',\r\n      file: 'admin.ts' \r\n    });\r\n  } catch (error: any) {\r\n    logger.error('[Firebase Admin] Γ¥î Initialization failed', error, { file: 'admin.ts' });\r\n  }\r\n}\r\n\r\n// Export admin services - only if properly initialized\r\nexport const adminAuth = adminApp ? admin.auth(adminApp) : null;\r\nexport const adminDb = adminApp ? admin.firestore(adminApp) : null;\r\nexport const adminStorage = adminApp ? admin.storage(adminApp) : null;\r\n\r\nexport { admin };\r\nexport default adminApp;\r\n\r\n\r\n\r\n\r\n\r\n\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\David\\PycharmProjects\\AI Sales Platform\\src\\lib\\import\\import-service.ts","messages":[{"ruleId":"no-useless-escape","severity":2,"message":"Unnecessary escape character: \\+.","line":81,"column":35,"nodeType":"Literal","messageId":"unnecessaryEscape","endLine":81,"endColumn":36,"suggestions":[{"messageId":"removeEscape","fix":{"range":[2618,2619],"text":""},"desc":"Remove the `\\`. This maintains the current functionality."},{"messageId":"escapeBackslash","fix":{"range":[2618,2618],"text":"\\"},"desc":"Replace the `\\` with `\\\\` to include the actual backslash character."}]},{"ruleId":"no-useless-escape","severity":2,"message":"Unnecessary escape character: \\(.","line":81,"column":37,"nodeType":"Literal","messageId":"unnecessaryEscape","endLine":81,"endColumn":38,"suggestions":[{"messageId":"removeEscape","fix":{"range":[2620,2621],"text":""},"desc":"Remove the `\\`. This maintains the current functionality."},{"messageId":"escapeBackslash","fix":{"range":[2620,2620],"text":"\\"},"desc":"Replace the `\\` with `\\\\` to include the actual backslash character."}]},{"ruleId":"no-useless-escape","severity":2,"message":"Unnecessary escape character: \\).","line":81,"column":39,"nodeType":"Literal","messageId":"unnecessaryEscape","endLine":81,"endColumn":40,"suggestions":[{"messageId":"removeEscape","fix":{"range":[2622,2623],"text":""},"desc":"Remove the `\\`. This maintains the current functionality."},{"messageId":"escapeBackslash","fix":{"range":[2622,2622],"text":"\\"},"desc":"Replace the `\\` with `\\\\` to include the actual backslash character."}]}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * CSV Import Service\r\n * Handles file parsing, schema detection, and data import\r\n */\r\n\r\nimport type { ImportSession, ColumnMapping, DetectedSchema, DetectedField, FieldTypeDetectionResult } from '@/types/import';\r\n\r\nexport class ImportService {\r\n  /**\r\n   * Parse CSV file\r\n   */\r\n  static parseCSV(file: File): Promise<{ headers: string[]; rows: any[][] }> {\r\n    return new Promise((resolve, reject) => {\r\n      const reader = new FileReader();\r\n      \r\n      reader.onload = (e) => {\r\n        try {\r\n          const text = e.target?.result as string;\r\n          const lines = text.split('\\n').filter(line => line.trim());\r\n          \r\n          if (lines.length === 0) {\r\n            reject(new Error('File is empty'));\r\n            return;\r\n          }\r\n          \r\n          // Parse CSV (basic implementation - in production use Papa Parse library)\r\n          const rows = lines.map(line => {\r\n            const values: string[] = [];\r\n            let current = '';\r\n            let inQuotes = false;\r\n            \r\n            for (let i = 0; i < line.length; i++) {\r\n              const char = line[i];\r\n              \r\n              if (char === '\"') {\r\n                inQuotes = !inQuotes;\r\n              } else if (char === ',' && !inQuotes) {\r\n                values.push(current.trim());\r\n                current = '';\r\n              } else {\r\n                current += char;\r\n              }\r\n            }\r\n            values.push(current.trim());\r\n            \r\n            return values;\r\n          });\r\n          \r\n          const headers = rows[0];\r\n          const dataRows = rows.slice(1);\r\n          \r\n          resolve({ headers, rows: dataRows });\r\n        } catch (error: any) {\r\n          reject(new Error('Failed to parse CSV: ' + error.message));\r\n        }\r\n      };\r\n      \r\n      reader.onerror = () => reject(new Error('Failed to read file'));\r\n      reader.readAsText(file);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Auto-detect field types from sample data\r\n   */\r\n  static detectFieldType(values: any[]): FieldTypeDetectionResult {\r\n    const nonEmptyValues = values.filter(v => v !== null && v !== undefined && v !== '');\r\n    \r\n    if (nonEmptyValues.length === 0) {\r\n      return { type: 'text', confidence: 50 };\r\n    }\r\n\r\n    // Email detection\r\n    const emailPattern = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\r\n    const emailMatches = nonEmptyValues.filter(v => emailPattern.test(String(v))).length;\r\n    if (emailMatches / nonEmptyValues.length > 0.8) {\r\n      return { type: 'email', confidence: 90, pattern: 'email' };\r\n    }\r\n\r\n    // Phone detection\r\n    const phonePattern = /^[\\d\\s\\-\\+\\(\\)]+$/;\r\n    const phoneMatches = nonEmptyValues.filter(v => {\r\n      const str = String(v);\r\n      return phonePattern.test(str) && str.replace(/\\D/g, '').length >= 10;\r\n    }).length;\r\n    if (phoneMatches / nonEmptyValues.length > 0.8) {\r\n      return { type: 'phone', confidence: 85, pattern: 'phone' };\r\n    }\r\n\r\n    // URL detection\r\n    const urlPattern = /^https?:\\/\\//i;\r\n    const urlMatches = nonEmptyValues.filter(v => urlPattern.test(String(v))).length;\r\n    if (urlMatches / nonEmptyValues.length > 0.8) {\r\n      return { type: 'url', confidence: 90, pattern: 'url' };\r\n    }\r\n\r\n    // Boolean detection\r\n    const booleanValues = ['true', 'false', 'yes', 'no', '1', '0', 'y', 'n'];\r\n    const boolMatches = nonEmptyValues.filter(v => \r\n      booleanValues.includes(String(v).toLowerCase())\r\n    ).length;\r\n    if (boolMatches / nonEmptyValues.length > 0.9) {\r\n      return { type: 'boolean', confidence: 95 };\r\n    }\r\n\r\n    // Number detection\r\n    const numberMatches = nonEmptyValues.filter(v => !isNaN(Number(v))).length;\r\n    if (numberMatches / nonEmptyValues.length > 0.9) {\r\n      // Currency detection\r\n      const currencyPattern = /^\\$?[\\d,]+\\.?\\d*$/;\r\n      const currencyMatches = nonEmptyValues.filter(v => currencyPattern.test(String(v))).length;\r\n      if (currencyMatches / nonEmptyValues.length > 0.8) {\r\n        return { type: 'currency', confidence: 85, pattern: 'currency' };\r\n      }\r\n      return { type: 'number', confidence: 90 };\r\n    }\r\n\r\n    // Date detection\r\n    const dateMatches = nonEmptyValues.filter(v => {\r\n      const date = new Date(v);\r\n      return !isNaN(date.getTime());\r\n    }).length;\r\n    if (dateMatches / nonEmptyValues.length > 0.8) {\r\n      return { type: 'date', confidence: 85, pattern: 'date' };\r\n    }\r\n\r\n    // Select detection (if limited unique values)\r\n    const uniqueValues = [...new Set(nonEmptyValues)];\r\n    if (uniqueValues.length <= 10 && uniqueValues.length > 1) {\r\n      return { type: 'select', confidence: 75, uniqueValues };\r\n    }\r\n\r\n    // Default to text\r\n    return { type: 'text', confidence: 70 };\r\n  }\r\n\r\n  /**\r\n   * Auto-detect schema from CSV data\r\n   */\r\n  static detectSchema(headers: string[], rows: any[][], entityName: string): DetectedSchema {\r\n    const fields: DetectedField[] = headers.map((header, index) => {\r\n      const columnValues = rows.map(row => row[index]).slice(0, 100); // Sample first 100 rows\r\n      const detection = this.detectFieldType(columnValues);\r\n      \r\n      // Clean field name\r\n      const fieldName = header\r\n        .toLowerCase()\r\n        .replace(/[^a-z0-9_]/g, '_')\r\n        .replace(/_+/g, '_')\r\n        .replace(/^_|_$/g, '');\r\n      \r\n      // Determine if required (less than 10% empty values)\r\n      const emptyCount = columnValues.filter(v => !v || v === '').length;\r\n      const required = emptyCount / columnValues.length < 0.1;\r\n      \r\n      return {\r\n        name: fieldName,\r\n        type: detection.type,\r\n        required,\r\n        confidence: detection.confidence,\r\n        reasoning: `Detected as ${detection.type} based on ${columnValues.length} sample values`,\r\n        sampleValues: columnValues.slice(0, 5),\r\n      };\r\n    });\r\n\r\n    // Calculate overall confidence\r\n    const avgConfidence = fields.reduce((sum, f) => sum + f.confidence, 0) / fields.length;\r\n\r\n    // Generate suggestions\r\n    const suggestions: string[] = [];\r\n    if (fields.some(f => f.type === 'email')) {\r\n      suggestions.push('Email field detected - can be used for contact lookup');\r\n    }\r\n    if (fields.some(f => f.name.includes('sku') || f.name.includes('id'))) {\r\n      suggestions.push('Unique identifier detected - can be used to update existing records');\r\n    }\r\n    if (fields.some(f => f.type === 'currency')) {\r\n      suggestions.push('Currency fields detected - will be formatted with $ symbol');\r\n    }\r\n\r\n    return {\r\n      entityName,\r\n      fields,\r\n      confidence: avgConfidence,\r\n      suggestions,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Generate column mappings\r\n   */\r\n  static generateMappings(\r\n    headers: string[],\r\n    rows: any[][],\r\n    existingFields: string[] = []\r\n  ): ColumnMapping[] {\r\n    return headers.map((header, index) => {\r\n      const columnValues = rows.map(row => row[index]).slice(0, 100);\r\n      const detection = this.detectFieldType(columnValues);\r\n      \r\n      const fieldName = header\r\n        .toLowerCase()\r\n        .replace(/[^a-z0-9_]/g, '_')\r\n        .replace(/_+/g, '_')\r\n        .replace(/^_|_$/g, '');\r\n\r\n      // Try to match with existing field\r\n      const matchedField = existingFields.find(f => \r\n        f.toLowerCase() === fieldName ||\r\n        f.toLowerCase().includes(fieldName) ||\r\n        fieldName.includes(f.toLowerCase())\r\n      );\r\n\r\n      return {\r\n        csvColumn: header,\r\n        csvColumnIndex: index,\r\n        targetField: matchedField || fieldName,\r\n        fieldType: detection.type,\r\n        isRequired: false,\r\n        sampleValues: columnValues.slice(0, 5),\r\n        detectedType: detection.type,\r\n        confidence: detection.confidence,\r\n      };\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Validate import data\r\n   */\r\n  static validateData(\r\n    rows: any[][],\r\n    mappings: ColumnMapping[]\r\n  ): { valid: boolean; errors: any[] } {\r\n    const errors: any[] = [];\r\n\r\n    rows.forEach((row, rowIndex) => {\r\n      mappings.forEach(mapping => {\r\n        const value = row[mapping.csvColumnIndex];\r\n\r\n        // Check required fields\r\n        if (mapping.isRequired && (!value || value === '')) {\r\n          errors.push({\r\n            row: rowIndex + 2, // +2 for header and 0-index\r\n            column: mapping.csvColumn,\r\n            message: 'Required field is empty',\r\n            severity: 'error',\r\n          });\r\n        }\r\n\r\n        // Validate by type\r\n        if (value && value !== '') {\r\n          if (mapping.fieldType === 'email' && !this.isValidEmail(value)) {\r\n            errors.push({\r\n              row: rowIndex + 2,\r\n              column: mapping.csvColumn,\r\n              message: 'Invalid email format',\r\n              value,\r\n              severity: 'warning',\r\n            });\r\n          }\r\n          \r\n          if (mapping.fieldType === 'number' && isNaN(Number(value))) {\r\n            errors.push({\r\n              row: rowIndex + 2,\r\n              column: mapping.csvColumn,\r\n              message: 'Invalid number format',\r\n              value,\r\n              severity: 'error',\r\n            });\r\n          }\r\n        }\r\n      });\r\n    });\r\n\r\n    return {\r\n      valid: errors.filter(e => e.severity === 'error').length === 0,\r\n      errors,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Transform value based on mapping\r\n   */\r\n  static transformValue(value: any, mapping: ColumnMapping): any {\r\n    if (!value || value === '') return mapping.defaultValue || null;\r\n\r\n    switch (mapping.transform) {\r\n      case 'trim':\r\n        return String(value).trim();\r\n      case 'uppercase':\r\n        return String(value).toUpperCase();\r\n      case 'lowercase':\r\n        return String(value).toLowerCase();\r\n      case 'phone':\r\n        return String(value).replace(/\\D/g, '');\r\n      case 'email':\r\n        return String(value).toLowerCase().trim();\r\n      case 'currency':\r\n        return parseFloat(String(value).replace(/[$,]/g, ''));\r\n      case 'date':\r\n        return new Date(value).toISOString();\r\n      default:\r\n        return value;\r\n    }\r\n  }\r\n\r\n  // Helper methods\r\n  private static isValidEmail(email: string): boolean {\r\n    return /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(email);\r\n  }\r\n}\r\n\r\n\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\David\\PycharmProjects\\AI Sales Platform\\src\\lib\\integrations\\crm\\salesforce.ts","messages":[{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":25,"column":7,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":25,"endColumn":76},{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":26,"column":7,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":26,"endColumn":80}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Salesforce Integration\n * CRM functions for Salesforce\n */\n\nimport type { ConnectedIntegration } from '@/types/integrations';\n\n/**\n * Execute a Salesforce function\n */\nexport async function executeSalesforceFunction(\n  functionName: string,\n  parameters: Record<string, any>,\n  integration: ConnectedIntegration\n): Promise<any> {\n  const { instanceUrl, accessToken } = integration.config;\n  \n  if (!instanceUrl || !accessToken) {\n    throw new Error('Salesforce credentials not configured');\n  }\n  \n  switch (functionName) {\n    case 'createSalesforceLead':\n      // Validate required parameters\n      const requiredFields = ['firstName', 'lastName', 'email', 'company'];\n      const missingFields = requiredFields.filter(field => !parameters[field]);\n      \n      if (missingFields.length > 0) {\n        throw new Error(`Missing required fields for Salesforce lead: ${missingFields.join(', ')}`);\n      }\n      \n      // Validate types\n      if (typeof parameters.firstName !== 'string' || typeof parameters.lastName !== 'string' || \n          typeof parameters.email !== 'string' || typeof parameters.company !== 'string') {\n        throw new Error('firstName, lastName, email, and company must be strings');\n      }\n      \n      // Optional fields validation\n      if (parameters.phone && typeof parameters.phone !== 'string') {\n        throw new Error('phone must be a string');\n      }\n      if (parameters.notes && typeof parameters.notes !== 'string') {\n        throw new Error('notes must be a string');\n      }\n      \n      return await createLead(\n        {\n          firstName: parameters.firstName,\n          lastName: parameters.lastName,\n          email: parameters.email,\n          company: parameters.company,\n          phone: parameters.phone,\n          notes: parameters.notes,\n        },\n        instanceUrl,\n        accessToken\n      );\n      \n    default:\n      throw new Error(`Unknown Salesforce function: ${functionName}`);\n  }\n}\n\n/**\n * Create a lead in Salesforce\n */\nasync function createLead(\n  params: {\n    firstName: string;\n    lastName: string;\n    email: string;\n    company: string;\n    phone?: string;\n    notes?: string;\n  },\n  instanceUrl: string,\n  accessToken: string\n): Promise<{ leadId: string; created: boolean }> {\n  const response = await fetch(`${instanceUrl}/services/data/v58.0/sobjects/Lead`, {\n    method: 'POST',\n    headers: {\n      'Authorization': `Bearer ${accessToken}`,\n      'Content-Type': 'application/json',\n    },\n    body: JSON.stringify({\n      FirstName: params.firstName,\n      LastName: params.lastName,\n      Email: params.email,\n      Company: params.company,\n      Phone: params.phone,\n      Description: params.notes,\n      LeadSource: 'AI Agent',\n    }),\n  });\n  \n  if (!response.ok) {\n    const error = await response.json();\n    throw new Error(`Failed to create lead: ${JSON.stringify(error)}`);\n  }\n  \n  const data = await response.json();\n  \n  return {\n    leadId: data.id,\n    created: data.success,\n  };\n}\n\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\David\\PycharmProjects\\AI Sales Platform\\src\\lib\\integrations\\email\\outlook.ts","messages":[{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":44,"column":7,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":44,"endColumn":54},{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":45,"column":7,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":45,"endColumn":50}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Outlook Function Executor\r\n * Allows AI agent to call Outlook/Microsoft functions\r\n */\r\n\r\nimport type { ConnectedIntegration } from '@/types/integrations';\r\nimport { sendEmail, listCalendarEvents, createCalendarEvent } from '../outlook-service';\r\n\r\n/**\r\n * Execute an Outlook function\r\n */\r\nexport async function executeOutlookFunction(\r\n  functionName: string,\r\n  parameters: Record<string, any>,\r\n  integration: ConnectedIntegration\r\n): Promise<any> {\r\n  const accessToken = integration.accessToken || '';\r\n  \r\n  if (!accessToken) {\r\n    throw new Error('Outlook access token not configured');\r\n  }\r\n  \r\n  switch (functionName) {\r\n    case 'sendEmail':\r\n      // Validate required parameters\r\n      if (!parameters.to || typeof parameters.to !== 'string') {\r\n        throw new Error('to (string) is required for sendEmail');\r\n      }\r\n      if (!parameters.subject || typeof parameters.subject !== 'string') {\r\n        throw new Error('subject (string) is required for sendEmail');\r\n      }\r\n      if (!parameters.body || typeof parameters.body !== 'string') {\r\n        throw new Error('body (string) is required for sendEmail');\r\n      }\r\n      \r\n      return await sendEmail(accessToken, {\r\n        to: parameters.to,\r\n        subject: parameters.subject,\r\n        body: parameters.body,\r\n      });\r\n      \r\n    case 'getCalendar':\r\n      // Optional parameters\r\n      const startDateTime = parameters.startDateTime;\r\n      const endDateTime = parameters.endDateTime;\r\n      \r\n      return await listCalendarEvents(accessToken, {\r\n        startDateTime,\r\n        endDateTime,\r\n      });\r\n      \r\n    case 'createCalendarEvent':\r\n      // Validate required parameters\r\n      if (!parameters.subject || typeof parameters.subject !== 'string') {\r\n        throw new Error('subject (string) is required for createCalendarEvent');\r\n      }\r\n      if (!parameters.start || typeof parameters.start !== 'string') {\r\n        throw new Error('start (string) is required for createCalendarEvent');\r\n      }\r\n      if (!parameters.end || typeof parameters.end !== 'string') {\r\n        throw new Error('end (string) is required for createCalendarEvent');\r\n      }\r\n      \r\n      return await createCalendarEvent(accessToken, {\r\n        subject: parameters.subject,\r\n        body: parameters.body,\r\n        start: parameters.start,\r\n        end: parameters.end,\r\n        attendees: parameters.attendees,\r\n        location: parameters.location,\r\n      });\r\n      \r\n    default:\r\n      throw new Error(`Unknown Outlook function: ${functionName}`);\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\David\\PycharmProjects\\AI Sales Platform\\src\\lib\\integrations\\field-mapper.ts","messages":[{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":463,"column":9,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":463,"endColumn":42},{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":510,"column":11,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":510,"endColumn":48}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Integration Field Mapper\r\n * Manages field mappings between internal CRM fields and external integration fields\r\n */\r\n\r\nimport { logger } from '@/lib/logger/logger';\r\nimport { FieldResolver } from '@/lib/schema/field-resolver';\r\nimport { SchemaChangeEvent } from '@/lib/schema/schema-change-tracker';\r\nimport { executeCustomTransform } from './custom-transforms';\r\n\r\n/**\r\n * Integration Field Mapping\r\n * Maps internal CRM fields to external system fields\r\n */\r\nexport interface IntegrationFieldMapping {\r\n  id: string;\r\n  integrationId: string;\r\n  integrationName: string; // 'salesforce', 'hubspot', 'shopify', etc.\r\n  organizationId: string;\r\n  workspaceId: string;\r\n  \r\n  // Schema this mapping applies to\r\n  schemaId: string;\r\n  schemaName: string;\r\n  \r\n  // Field mappings\r\n  mappings: FieldMappingRule[];\r\n  \r\n  // Settings\r\n  settings: {\r\n    autoSync: boolean;\r\n    syncDirection: 'one-way' | 'two-way' | 'inbound' | 'outbound';\r\n    conflictResolution: 'local_wins' | 'remote_wins' | 'newest_wins' | 'manual';\r\n  };\r\n  \r\n  // Metadata\r\n  createdAt: string;\r\n  updatedAt: string;\r\n  createdBy: string;\r\n  lastSyncedAt?: string;\r\n}\r\n\r\n/**\r\n * Field Mapping Rule\r\n */\r\nexport interface FieldMappingRule {\r\n  id: string;\r\n  \r\n  // Internal field (CRM)\r\n  localField: string; // Field key in schema\r\n  localFieldLabel?: string; // Field label for display\r\n  \r\n  // External field (Integration)\r\n  externalField: string; // Field name in external system\r\n  externalFieldLabel?: string; // Field label for display\r\n  \r\n  // Mapping configuration\r\n  required: boolean;\r\n  readonly: boolean; // Don't sync changes to this field\r\n  \r\n  // Transformation\r\n  transform?: FieldTransform;\r\n  \r\n  // Validation\r\n  validationRules?: ValidationRule[];\r\n}\r\n\r\n/**\r\n * Field Transform\r\n */\r\nexport interface FieldTransform {\r\n  type: 'uppercase' | 'lowercase' | 'trim' | 'phone' | 'currency' | 'date' | 'custom';\r\n  format?: string; // For date/currency formatting\r\n  customFunction?: string; // Custom transform function name\r\n  params?: Record<string, any>; // Parameters for custom transform functions\r\n  direction?: 'inbound' | 'outbound' | 'both'; // When to apply transform\r\n}\r\n\r\n/**\r\n * Validation Rule\r\n */\r\nexport interface ValidationRule {\r\n  type: 'regex' | 'min' | 'max' | 'length' | 'enum';\r\n  value: any;\r\n  message?: string;\r\n}\r\n\r\n/**\r\n * Field Mapping Manager\r\n */\r\nexport class FieldMappingManager {\r\n  /**\r\n   * Create integration field mapping\r\n   */\r\n  static async createFieldMapping(\r\n    mapping: Omit<IntegrationFieldMapping, 'id' | 'createdAt' | 'updatedAt'>\r\n  ): Promise<IntegrationFieldMapping> {\r\n    try {\r\n      const { FirestoreService, COLLECTIONS } = await import('@/lib/db/firestore-service');\r\n      \r\n      const mappingId = `mapping_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\r\n      \r\n      const fullMapping: IntegrationFieldMapping = {\r\n        ...mapping,\r\n        id: mappingId,\r\n        createdAt: new Date().toISOString(),\r\n        updatedAt: new Date().toISOString(),\r\n      };\r\n      \r\n      const mappingsPath = `${COLLECTIONS.ORGANIZATIONS}/${mapping.organizationId}/integrationFieldMappings`;\r\n      \r\n      await FirestoreService.set(mappingsPath, mappingId, fullMapping, false);\r\n      \r\n      logger.info('[Field Mapper] Created field mapping', {\r\n        file: 'field-mapper.ts',\r\n        mappingId,\r\n        integrationName: mapping.integrationName,\r\n      });\r\n      \r\n      return fullMapping;\r\n    } catch (error) {\r\n      logger.error('[Field Mapper] Failed to create field mapping', error, {\r\n        file: 'field-mapper.ts',\r\n      });\r\n      throw error;\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Get field mapping for integration\r\n   */\r\n  static async getFieldMapping(\r\n    organizationId: string,\r\n    integrationId: string,\r\n    schemaId?: string\r\n  ): Promise<IntegrationFieldMapping | null> {\r\n    try {\r\n      const { FirestoreService, COLLECTIONS } = await import('@/lib/db/firestore-service');\r\n      const { where } = await import('firebase/firestore');\r\n      \r\n      const mappingsPath = `${COLLECTIONS.ORGANIZATIONS}/${organizationId}/integrationFieldMappings`;\r\n      \r\n      const filters: any[] = [\r\n        where('integrationId', '==', integrationId),\r\n      ];\r\n      \r\n      if (schemaId) {\r\n        filters.push(where('schemaId', '==', schemaId));\r\n      }\r\n      \r\n      const mappings = await FirestoreService.getAll(mappingsPath, filters);\r\n      \r\n      return mappings.length > 0 ? (mappings[0] as IntegrationFieldMapping) : null;\r\n    } catch (error) {\r\n      logger.error('[Field Mapper] Failed to get field mapping', error, {\r\n        file: 'field-mapper.ts',\r\n        integrationId,\r\n      });\r\n      return null;\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Update field mapping\r\n   */\r\n  static async updateFieldMapping(\r\n    organizationId: string,\r\n    mappingId: string,\r\n    updates: Partial<IntegrationFieldMapping>\r\n  ): Promise<void> {\r\n    try {\r\n      const { FirestoreService, COLLECTIONS } = await import('@/lib/db/firestore-service');\r\n      \r\n      const mappingsPath = `${COLLECTIONS.ORGANIZATIONS}/${organizationId}/integrationFieldMappings`;\r\n      \r\n      const existing = await FirestoreService.get(mappingsPath, mappingId);\r\n      \r\n      if (!existing) {\r\n        throw new Error(`Field mapping ${mappingId} not found`);\r\n      }\r\n      \r\n      await FirestoreService.set(\r\n        mappingsPath,\r\n        mappingId,\r\n        {\r\n          ...existing,\r\n          ...updates,\r\n          updatedAt: new Date().toISOString(),\r\n        },\r\n        false\r\n      );\r\n      \r\n      logger.info('[Field Mapper] Updated field mapping', {\r\n        file: 'field-mapper.ts',\r\n        mappingId,\r\n      });\r\n    } catch (error) {\r\n      logger.error('[Field Mapper] Failed to update field mapping', error, {\r\n        file: 'field-mapper.ts',\r\n        mappingId,\r\n      });\r\n      throw error;\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Adapt field mapping to schema changes\r\n   */\r\n  static async adaptToSchemaChange(\r\n    event: SchemaChangeEvent\r\n  ): Promise<void> {\r\n    try {\r\n      const { FirestoreService, COLLECTIONS } = await import('@/lib/db/firestore-service');\r\n      const { where } = await import('firebase/firestore');\r\n      \r\n      // Get all field mappings for this schema\r\n      const mappingsPath = `${COLLECTIONS.ORGANIZATIONS}/${event.organizationId}/integrationFieldMappings`;\r\n      const mappings = await FirestoreService.getAll(mappingsPath, [\r\n        where('schemaId', '==', event.schemaId),\r\n      ] as any);\r\n      \r\n      if (mappings.length === 0) {\r\n        logger.info('[Field Mapper] No field mappings found for schema', {\r\n          file: 'field-mapper.ts',\r\n          schemaId: event.schemaId,\r\n        });\r\n        return;\r\n      }\r\n      \r\n      // Update each mapping\r\n      for (const mapping of mappings) {\r\n        const fieldMapping = mapping as IntegrationFieldMapping;\r\n        let updated = false;\r\n        \r\n        switch (event.changeType) {\r\n          case 'field_renamed':\r\n          case 'field_key_changed':\r\n            updated = await this.handleFieldRenameInMapping(\r\n              fieldMapping,\r\n              event.oldFieldKey || event.oldFieldName || '',\r\n              event.newFieldKey || event.newFieldName || ''\r\n            );\r\n            break;\r\n          \r\n          case 'field_deleted':\r\n            updated = await this.handleFieldDeletionInMapping(\r\n              fieldMapping,\r\n              event.oldFieldKey || event.oldFieldName || ''\r\n            );\r\n            break;\r\n        }\r\n        \r\n        if (updated) {\r\n          await this.updateFieldMapping(\r\n            event.organizationId,\r\n            fieldMapping.id,\r\n            { mappings: fieldMapping.mappings }\r\n          );\r\n        }\r\n      }\r\n      \r\n    } catch (error) {\r\n      logger.error('[Field Mapper] Failed to adapt to schema change', error, {\r\n        file: 'field-mapper.ts',\r\n        eventId: event.id,\r\n      });\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Handle field rename in mapping\r\n   */\r\n  private static async handleFieldRenameInMapping(\r\n    mapping: IntegrationFieldMapping,\r\n    oldFieldKey: string,\r\n    newFieldKey: string\r\n  ): Promise<boolean> {\r\n    let updated = false;\r\n    \r\n    for (const rule of mapping.mappings) {\r\n      if (rule.localField === oldFieldKey) {\r\n        rule.localField = newFieldKey;\r\n        updated = true;\r\n        \r\n        logger.info('[Field Mapper] Updated field mapping rule', {\r\n          file: 'field-mapper.ts',\r\n          mappingId: mapping.id,\r\n          ruleId: rule.id,\r\n          oldKey: oldFieldKey,\r\n          newKey: newFieldKey,\r\n        });\r\n      }\r\n    }\r\n    \r\n    return updated;\r\n  }\r\n  \r\n  /**\r\n   * Handle field deletion in mapping\r\n   */\r\n  private static async handleFieldDeletionInMapping(\r\n    mapping: IntegrationFieldMapping,\r\n    deletedFieldKey: string\r\n  ): Promise<boolean> {\r\n    let updated = false;\r\n    \r\n    // Find rules using the deleted field\r\n    const affectedRules = mapping.mappings.filter(\r\n      rule => rule.localField === deletedFieldKey\r\n    );\r\n    \r\n    if (affectedRules.length > 0) {\r\n      // Mark as needing user action\r\n      for (const rule of affectedRules) {\r\n        rule.readonly = true; // Disable sync for this field\r\n        updated = true;\r\n        \r\n        logger.warn('[Field Mapper] Field deleted - mapping disabled', {\r\n          file: 'field-mapper.ts',\r\n          mappingId: mapping.id,\r\n          ruleId: rule.id,\r\n          deletedField: deletedFieldKey,\r\n        });\r\n      }\r\n    }\r\n    \r\n    return updated;\r\n  }\r\n  \r\n  /**\r\n   * Map local record to external format\r\n   */\r\n  static async mapLocalToExternal(\r\n    localRecord: any,\r\n    mapping: IntegrationFieldMapping,\r\n    schema: any\r\n  ): Promise<Record<string, any>> {\r\n    const externalRecord: Record<string, any> = {};\r\n    \r\n    for (const rule of mapping.mappings) {\r\n      if (rule.readonly && mapping.settings.syncDirection === 'outbound') {\r\n        continue; // Skip readonly fields for outbound sync\r\n      }\r\n      \r\n      // Get local value using field resolver\r\n      const value = FieldResolver.getFieldValue(localRecord, rule.localField, schema);\r\n      \r\n      if (value === undefined || value === null) {\r\n        if (rule.required) {\r\n          logger.warn('[Field Mapper] Required field missing', {\r\n            file: 'field-mapper.ts',\r\n            field: rule.localField,\r\n          });\r\n        }\r\n        continue;\r\n      }\r\n      \r\n      // Apply transformation\r\n      let transformedValue = value;\r\n      if (rule.transform && this.shouldApplyTransform(rule.transform, 'outbound')) {\r\n        transformedValue = await this.applyTransform(value, rule.transform);\r\n      }\r\n      \r\n      // Validate\r\n      if (rule.validationRules) {\r\n        const valid = await this.validateValue(transformedValue, rule.validationRules);\r\n        if (!valid) {\r\n          logger.warn('[Field Mapper] Validation failed', {\r\n            file: 'field-mapper.ts',\r\n            field: rule.localField,\r\n            value: transformedValue,\r\n          });\r\n          continue;\r\n        }\r\n      }\r\n      \r\n      externalRecord[rule.externalField] = transformedValue;\r\n    }\r\n    \r\n    return externalRecord;\r\n  }\r\n  \r\n  /**\r\n   * Map external record to local format\r\n   */\r\n  static async mapExternalToLocal(\r\n    externalRecord: any,\r\n    mapping: IntegrationFieldMapping,\r\n    schema: any\r\n  ): Promise<Record<string, any>> {\r\n    const localRecord: Record<string, any> = {};\r\n    \r\n    for (const rule of mapping.mappings) {\r\n      if (rule.readonly && mapping.settings.syncDirection === 'inbound') {\r\n        continue; // Skip readonly fields for inbound sync\r\n      }\r\n      \r\n      const value = externalRecord[rule.externalField];\r\n      \r\n      if (value === undefined || value === null) {\r\n        continue;\r\n      }\r\n      \r\n      // Apply transformation\r\n      let transformedValue = value;\r\n      if (rule.transform && this.shouldApplyTransform(rule.transform, 'inbound')) {\r\n        transformedValue = await this.applyTransform(value, rule.transform);\r\n      }\r\n      \r\n      // Resolve local field (in case it was renamed)\r\n      const resolvedField = await FieldResolver.resolveField(schema, rule.localField);\r\n      \r\n      if (!resolvedField) {\r\n        logger.warn('[Field Mapper] Local field not found', {\r\n          file: 'field-mapper.ts',\r\n          field: rule.localField,\r\n        });\r\n        continue;\r\n      }\r\n      \r\n      localRecord[resolvedField.fieldKey] = transformedValue;\r\n    }\r\n    \r\n    return localRecord;\r\n  }\r\n  \r\n  /**\r\n   * Check if transform should be applied for direction\r\n   */\r\n  private static shouldApplyTransform(\r\n    transform: FieldTransform,\r\n    direction: 'inbound' | 'outbound'\r\n  ): boolean {\r\n    if (!transform.direction || transform.direction === 'both') {\r\n      return true;\r\n    }\r\n    return transform.direction === direction;\r\n  }\r\n  \r\n  /**\r\n   * Apply field transformation\r\n   */\r\n  private static async applyTransform(\r\n    value: any,\r\n    transform: FieldTransform\r\n  ): Promise<any> {\r\n    switch (transform.type) {\r\n      case 'uppercase':\r\n        return String(value).toUpperCase();\r\n      \r\n      case 'lowercase':\r\n        return String(value).toLowerCase();\r\n      \r\n      case 'trim':\r\n        return String(value).trim();\r\n      \r\n      case 'phone':\r\n        // Normalize phone number (remove non-digits)\r\n        return String(value).replace(/\\D/g, '');\r\n      \r\n      case 'currency':\r\n        // Format as currency\r\n        const amount = parseFloat(value);\r\n        return isNaN(amount) ? value : amount.toFixed(2);\r\n      \r\n      case 'date':\r\n        // Format date\r\n        if (transform.format) {\r\n          // Apply date formatting (would use date-fns or similar)\r\n          return new Date(value).toISOString();\r\n        }\r\n        return value;\r\n      \r\n      case 'custom':\r\n        // Execute custom transform function from registry\r\n        if (transform.customFunction) {\r\n          const result = executeCustomTransform(\r\n            transform.customFunction,\r\n            value,\r\n            transform.params\r\n          );\r\n          \r\n          if (result.success) {\r\n            return result.value;\r\n          } else {\r\n            logger.warn('[Field Mapper] Custom transform failed', {\r\n              function: transform.customFunction,\r\n              error: result.error,\r\n              file: 'field-mapper.ts',\r\n            });\r\n          }\r\n        }\r\n        return value;\r\n      \r\n      default:\r\n        return value;\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Validate value against rules\r\n   */\r\n  private static async validateValue(\r\n    value: any,\r\n    rules: ValidationRule[]\r\n  ): Promise<boolean> {\r\n    for (const rule of rules) {\r\n      switch (rule.type) {\r\n        case 'regex':\r\n          const regex = new RegExp(rule.value);\r\n          if (!regex.test(String(value))) {\r\n            return false;\r\n          }\r\n          break;\r\n        \r\n        case 'min':\r\n          if (Number(value) < Number(rule.value)) {\r\n            return false;\r\n          }\r\n          break;\r\n        \r\n        case 'max':\r\n          if (Number(value) > Number(rule.value)) {\r\n            return false;\r\n          }\r\n          break;\r\n        \r\n        case 'length':\r\n          if (String(value).length !== Number(rule.value)) {\r\n            return false;\r\n          }\r\n          break;\r\n        \r\n        case 'enum':\r\n          if (!Array.isArray(rule.value) || !rule.value.includes(value)) {\r\n            return false;\r\n          }\r\n          break;\r\n      }\r\n    }\r\n    \r\n    return true;\r\n  }\r\n}\r\n\r\n/**\r\n * Get default field mappings for common integrations\r\n */\r\nexport function getDefaultFieldMappings(\r\n  integrationName: string\r\n): Partial<Record<string, string>> {\r\n  const mappings: Record<string, Partial<Record<string, string>>> = {\r\n    salesforce: {\r\n      'firstName': 'FirstName',\r\n      'lastName': 'LastName',\r\n      'email': 'Email',\r\n      'phone': 'Phone',\r\n      'company': 'Company',\r\n      'title': 'Title',\r\n      'address': 'Street',\r\n      'city': 'City',\r\n      'state': 'State',\r\n      'zip': 'PostalCode',\r\n      'country': 'Country',\r\n    },\r\n    hubspot: {\r\n      'firstName': 'firstname',\r\n      'lastName': 'lastname',\r\n      'email': 'email',\r\n      'phone': 'phone',\r\n      'company': 'company',\r\n      'title': 'jobtitle',\r\n      'website': 'website',\r\n      'address': 'address',\r\n      'city': 'city',\r\n      'state': 'state',\r\n      'zip': 'zip',\r\n    },\r\n    shopify: {\r\n      'name': 'title',\r\n      'price': 'price',\r\n      'description': 'body_html',\r\n      'sku': 'sku',\r\n      'inventory': 'inventory_quantity',\r\n      'weight': 'weight',\r\n      'images': 'images',\r\n    },\r\n  };\r\n  \r\n  return mappings[integrationName.toLowerCase()] || {};\r\n}\r\n\r\n\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\David\\PycharmProjects\\AI Sales Platform\\src\\lib\\integrations\\oauth-service.ts","messages":[{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":236,"column":7,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":236,"endColumn":69},{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":255,"column":7,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":255,"endColumn":69},{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":274,"column":7,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":274,"endColumn":58},{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":294,"column":7,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":294,"endColumn":68},{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":314,"column":7,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":314,"endColumn":56}],"suppressedMessages":[],"errorCount":5,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * OAuth Service\n * Handles OAuth 2.0 authorization flows for integrations\n */\n\nimport { FirestoreService, COLLECTIONS } from '@/lib/db/firestore-service';\nimport { apiKeyService } from '@/lib/api-keys/api-key-service';\nimport crypto from 'crypto';\n\nexport interface OAuthConfig {\n  provider: 'google' | 'microsoft' | 'slack' | 'quickbooks' | 'xero';\n  clientId: string;\n  clientSecret: string;\n  redirectUri: string;\n  scopes: string[];\n  authorizationUrl: string;\n  tokenUrl: string;\n}\n\n// Lightweight config map for tests and fallback defaults\nexport const OAuthConfig: Record<string, Partial<OAuthConfig>> = {\n  google: { provider: 'google', authorizationUrl: 'https://accounts.google.com/o/oauth2/auth', tokenUrl: 'https://oauth2.googleapis.com/token', scopes: [] },\n  microsoft: { provider: 'microsoft', authorizationUrl: 'https://login.microsoftonline.com/common/oauth2/v2.0/authorize', tokenUrl: 'https://login.microsoftonline.com/common/oauth2/v2.0/token', scopes: [] },\n  quickbooks: { provider: 'quickbooks', authorizationUrl: 'https://appcenter.intuit.com/connect/oauth2', tokenUrl: 'https://oauth.platform.intuit.com/oauth2/v1/tokens/bearer', scopes: [] },\n  xero: { provider: 'xero', authorizationUrl: 'https://login.xero.com/identity/connect/authorize', tokenUrl: 'https://identity.xero.com/connect/token', scopes: [] },\n};\n\nexport interface OAuthState {\n  state: string;\n  organizationId: string;\n  workspaceId?: string;\n  integrationId: string;\n  provider: string;\n  createdAt: Date;\n}\n\n/**\n * Generate OAuth authorization URL\n */\nexport async function generateAuthUrl(\n  organizationId: string,\n  workspaceId: string | undefined,\n  integrationId: string,\n  provider: 'google' | 'microsoft' | 'slack' | 'quickbooks' | 'xero'\n): Promise<string> {\n  // Get OAuth config\n  const config = await getOAuthConfig(organizationId, provider);\n  \n  // Generate state token\n  const state = crypto.randomBytes(32).toString('hex');\n  \n  // Save state to Firestore\n  await FirestoreService.set(\n    `${COLLECTIONS.ORGANIZATIONS}/${organizationId}/oauthStates`,\n    state,\n    {\n      state,\n      organizationId,\n      workspaceId,\n      integrationId,\n      provider,\n      createdAt: new Date().toISOString(),\n    },\n    false\n  );\n  \n  // Build authorization URL\n  const params = new URLSearchParams({\n    client_id: config.clientId,\n    redirect_uri: config.redirectUri,\n    response_type: 'code',\n    scope: config.scopes.join(' '),\n    state,\n    access_type: 'offline', // For refresh tokens\n    prompt: 'consent', // Force consent to get refresh token\n  });\n  \n  return `${config.authorizationUrl}?${params.toString()}`;\n}\n\n/**\n * Exchange authorization code for tokens\n */\nexport async function exchangeCodeForTokens(\n  code: string,\n  state: string\n): Promise<{\n  accessToken: string;\n  refreshToken?: string;\n  expiresIn?: number;\n  tokenType?: string;\n  [key: string]: any;\n}> {\n  // Verify state\n  const stateData = await FirestoreService.get<OAuthState>(\n    `${COLLECTIONS.ORGANIZATIONS}/*/oauthStates`,\n    state\n  );\n  \n  if (!stateData) {\n    throw new Error('Invalid state token');\n  }\n  \n  // Check if state is expired (5 minutes)\n  const createdAt = new Date(stateData.createdAt);\n  const now = new Date();\n  if (now.getTime() - createdAt.getTime() > 5 * 60 * 1000) {\n    throw new Error('State token expired');\n  }\n  \n  // Get OAuth config\n  const config = await getOAuthConfig(stateData.organizationId, stateData.provider as any);\n  \n  // Exchange code for tokens\n  const tokenResponse = await fetch(config.tokenUrl, {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/x-www-form-urlencoded',\n    },\n    body: new URLSearchParams({\n      client_id: config.clientId,\n      client_secret: config.clientSecret,\n      code,\n      grant_type: 'authorization_code',\n      redirect_uri: config.redirectUri,\n    }),\n  });\n  \n  if (!tokenResponse.ok) {\n    const error = await tokenResponse.text();\n    throw new Error(`Token exchange failed: ${error}`);\n  }\n  \n  const tokens = await tokenResponse.json();\n  \n  // Save tokens to integration\n  await saveIntegrationTokens(\n    stateData.organizationId,\n    stateData.workspaceId,\n    stateData.integrationId,\n    stateData.provider,\n    tokens\n  );\n  \n  // Delete state token\n  await FirestoreService.delete(\n    `${COLLECTIONS.ORGANIZATIONS}/${stateData.organizationId}/oauthStates`,\n    state\n  );\n  \n  return tokens;\n}\n\n/**\n * Refresh access token\n */\nexport async function refreshAccessToken(\n  organizationId: string,\n  integrationId: string,\n  provider: string\n): Promise<string> {\n  // Get integration\n  const integration = await FirestoreService.get(\n    `${COLLECTIONS.ORGANIZATIONS}/${organizationId}/integrations`,\n    integrationId\n  );\n  \n  if (!integration) {\n    throw new Error('Integration not found');\n  }\n  \n  const refreshToken = (integration as any).refreshToken;\n  if (!refreshToken) {\n    throw new Error('No refresh token available');\n  }\n  \n  // Get OAuth config\n  const config = await getOAuthConfig(organizationId, provider as any);\n  \n  // Refresh token\n  const tokenResponse = await fetch(config.tokenUrl, {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/x-www-form-urlencoded',\n    },\n    body: new URLSearchParams({\n      client_id: config.clientId,\n      client_secret: config.clientSecret,\n      refresh_token: refreshToken,\n      grant_type: 'refresh_token',\n    }),\n  });\n  \n  if (!tokenResponse.ok) {\n    throw new Error('Token refresh failed');\n  }\n  \n  const tokens = await tokenResponse.json();\n  \n  // Update integration with new tokens\n  await FirestoreService.set(\n    `${COLLECTIONS.ORGANIZATIONS}/${organizationId}/integrations`,\n    integrationId,\n    {\n      ...integration,\n      accessToken: tokens.access_token,\n      refreshToken: tokens.refresh_token || refreshToken, // Keep old refresh token if new one not provided\n      tokenExpiresAt: tokens.expires_in\n        ? new Date(Date.now() + tokens.expires_in * 1000).toISOString()\n        : undefined,\n      updatedAt: new Date().toISOString(),\n    },\n    true // Update only\n  );\n  \n  return tokens.access_token;\n}\n\n/**\n * Get OAuth config for provider\n */\nasync function getOAuthConfig(\n  organizationId: string,\n  provider: 'google' | 'microsoft' | 'slack' | 'quickbooks' | 'xero'\n): Promise<OAuthConfig> {\n  const apiKeys = await apiKeyService.getServiceKey(organizationId, 'integrations');\n  \n  if (!apiKeys) {\n    throw new Error('Integration API keys not configured');\n  }\n  \n  const baseUrl = process.env.NEXT_PUBLIC_APP_URL || 'https://app.example.com';\n  \n  switch (provider) {\n    case 'google':\n      const google = (apiKeys as any).integrations?.googleWorkspace;\n      if (!google?.clientId || !google?.clientSecret) {\n        throw new Error('Google OAuth credentials not configured');\n      }\n      return {\n        provider: 'google',\n        clientId: google.clientId,\n        clientSecret: google.clientSecret,\n        redirectUri: `${baseUrl}/api/integrations/oauth/callback/google`,\n        scopes: [\n          'https://www.googleapis.com/auth/gmail.readonly',\n          'https://www.googleapis.com/auth/calendar',\n          'https://www.googleapis.com/auth/drive.readonly',\n        ],\n        authorizationUrl: 'https://accounts.google.com/o/oauth2/v2/auth',\n        tokenUrl: 'https://oauth2.googleapis.com/token',\n      };\n    \n    case 'microsoft':\n      const microsoft = (apiKeys as any).integrations?.microsoft365;\n      if (!microsoft?.clientId || !microsoft?.clientSecret) {\n        throw new Error('Microsoft OAuth credentials not configured');\n      }\n      return {\n        provider: 'microsoft',\n        clientId: microsoft.clientId,\n        clientSecret: microsoft.clientSecret,\n        redirectUri: `${baseUrl}/api/integrations/oauth/callback/microsoft`,\n        scopes: [\n          'https://graph.microsoft.com/Mail.Read',\n          'https://graph.microsoft.com/Calendars.ReadWrite',\n          'https://graph.microsoft.com/User.Read',\n        ],\n        authorizationUrl: `https://login.microsoftonline.com/${microsoft.tenantId || 'common'}/oauth2/v2.0/authorize`,\n        tokenUrl: `https://login.microsoftonline.com/${microsoft.tenantId || 'common'}/oauth2/v2.0/token`,\n      };\n    \n    case 'slack':\n      const slack = (apiKeys as any).integrations?.slack;\n      if (!slack?.clientId || !slack?.clientSecret) {\n        throw new Error('Slack OAuth credentials not configured');\n      }\n      return {\n        provider: 'slack',\n        clientId: slack.clientId,\n        clientSecret: slack.clientSecret,\n        redirectUri: `${baseUrl}/api/integrations/oauth/callback/slack`,\n        scopes: [\n          'channels:read',\n          'chat:write',\n          'users:read',\n          'team:read',\n        ],\n        authorizationUrl: 'https://slack.com/oauth/v2/authorize',\n        tokenUrl: 'https://slack.com/api/oauth.v2.access',\n      };\n    \n    case 'quickbooks':\n      const quickbooks = (apiKeys as any).integrations?.quickbooks;\n      if (!quickbooks?.clientId || !quickbooks?.clientSecret) {\n        throw new Error('QuickBooks OAuth credentials not configured');\n      }\n      return {\n        provider: 'quickbooks',\n        clientId: quickbooks.clientId,\n        clientSecret: quickbooks.clientSecret,\n        redirectUri: `${baseUrl}/api/integrations/oauth/callback/quickbooks`,\n        scopes: [\n          'com.intuit.quickbooks.accounting',\n          'com.intuit.quickbooks.payment',\n        ],\n        authorizationUrl: quickbooks.environment === 'production'\n          ? 'https://appcenter.intuit.com/connect/oauth2'\n          : 'https://appcenter.intuit.com/connect/oauth2', // Same for both\n        tokenUrl: 'https://oauth.platform.intuit.com/oauth2/v1/tokens/bearer',\n      };\n    \n    case 'xero':\n      const xero = (apiKeys as any).integrations?.xero;\n      if (!xero?.clientId || !xero?.clientSecret) {\n        throw new Error('Xero OAuth credentials not configured');\n      }\n      return {\n        provider: 'xero',\n        clientId: xero.clientId,\n        clientSecret: xero.clientSecret,\n        redirectUri: `${baseUrl}/api/integrations/oauth/callback/xero`,\n        scopes: [\n          'offline_access',\n          'accounting.transactions',\n          'accounting.contacts',\n          'accounting.settings',\n        ],\n        authorizationUrl: 'https://login.xero.com/identity/connect/authorize',\n        tokenUrl: 'https://identity.xero.com/connect/token',\n      };\n    \n    default:\n      throw new Error(`Unsupported provider: ${provider}`);\n  }\n}\n\n/**\n * Save integration tokens\n */\nasync function saveIntegrationTokens(\n  organizationId: string,\n  workspaceId: string | undefined,\n  integrationId: string,\n  provider: string,\n  tokens: any\n): Promise<void> {\n  // Get or create integration\n  let integration = await FirestoreService.get(\n    `${COLLECTIONS.ORGANIZATIONS}/${organizationId}/integrations`,\n    integrationId\n  );\n  \n  const integrationData: any = {\n    id: integrationId,\n    organizationId,\n    workspaceId,\n    provider,\n    accessToken: tokens.access_token,\n    refreshToken: tokens.refresh_token,\n    tokenExpiresAt: tokens.expires_in\n      ? new Date(Date.now() + tokens.expires_in * 1000).toISOString()\n      : undefined,\n    status: 'connected',\n    connectedAt: new Date().toISOString(),\n    updatedAt: new Date().toISOString(),\n  };\n  \n  // Provider-specific data\n  if (provider === 'google') {\n    // Get user info\n    const userInfo = await fetch('https://www.googleapis.com/oauth2/v2/userinfo', {\n      headers: {\n        Authorization: `Bearer ${tokens.access_token}`,\n      },\n    }).then(r => r.json());\n    \n    integrationData.email = userInfo.email;\n    integrationData.name = userInfo.name;\n  } else if (provider === 'microsoft') {\n    const userInfo = await fetch('https://graph.microsoft.com/v1.0/me', {\n      headers: {\n        Authorization: `Bearer ${tokens.access_token}`,\n      },\n    }).then(r => r.json());\n    \n    integrationData.email = userInfo.mail || userInfo.userPrincipalName;\n    integrationData.name = userInfo.displayName;\n    integrationData.tenantId = userInfo.tenantId;\n  } else if (provider === 'slack') {\n    integrationData.teamId = tokens.team?.id;\n    integrationData.teamName = tokens.team?.name;\n    integrationData.botUserId = tokens.bot_user_id;\n  }\n  \n  await FirestoreService.set(\n    `${COLLECTIONS.ORGANIZATIONS}/${organizationId}/integrations`,\n    integrationId,\n    integration ? { ...integration, ...integrationData } : integrationData,\n    false\n  );\n}\n\n/**\n * Get valid access token (refresh if needed)\n */\nexport async function getValidAccessToken(\n  organizationId: string,\n  integrationId: string\n): Promise<string> {\n  const integration = await FirestoreService.get(\n    `${COLLECTIONS.ORGANIZATIONS}/${organizationId}/integrations`,\n    integrationId\n  );\n  \n  if (!integration) {\n    throw new Error('Integration not found');\n  }\n  \n  const accessToken = (integration as any).accessToken;\n  const tokenExpiresAt = (integration as any).tokenExpiresAt;\n  const provider = (integration as any).provider;\n  \n  // Check if token is expired or about to expire (within 5 minutes)\n  if (tokenExpiresAt) {\n    const expiresAt = new Date(tokenExpiresAt);\n    const now = new Date();\n    const fiveMinutesFromNow = new Date(now.getTime() + 5 * 60 * 1000);\n    \n    if (expiresAt <= fiveMinutesFromNow) {\n      // Refresh token\n      return await refreshAccessToken(organizationId, integrationId, provider);\n    }\n  }\n  \n  return accessToken;\n}\n\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\David\\PycharmProjects\\AI Sales Platform\\src\\lib\\integrations\\payment\\paypal.ts","messages":[{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":30,"column":7,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":34,"endColumn":9}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * PayPal Function Executor\r\n * Allows AI agent to call PayPal functions\r\n */\r\n\r\nimport type { ConnectedIntegration } from '@/types/integrations';\r\nimport { createOrder, getOrderDetails, captureOrder } from '../paypal-service';\r\n\r\n/**\r\n * Execute a PayPal function\r\n */\r\nexport async function executePayPalFunction(\r\n  functionName: string,\r\n  parameters: Record<string, any>,\r\n  integration: ConnectedIntegration\r\n): Promise<any> {\r\n  const organizationId = integration.organizationId || '';\r\n  \r\n  if (!organizationId) {\r\n    throw new Error('Organization ID not configured');\r\n  }\r\n  \r\n  switch (functionName) {\r\n    case 'createPayment':\r\n      // Validate required parameters\r\n      if (typeof parameters.amount !== 'number') {\r\n        throw new Error('amount (number) is required for createPayment');\r\n      }\r\n      \r\n      const order = await createOrder(\r\n        organizationId,\r\n        parameters.amount,\r\n        parameters.currency || 'USD'\r\n      );\r\n      \r\n      return {\r\n        orderId: order.id,\r\n        approvalUrl: order.links?.find((l: any) => l.rel === 'approve')?.href,\r\n        status: order.status,\r\n      };\r\n      \r\n    case 'getTransaction':\r\n      // Validate required parameters\r\n      if (!parameters.orderId || typeof parameters.orderId !== 'string') {\r\n        throw new Error('orderId (string) is required for getTransaction');\r\n      }\r\n      \r\n      return await getOrderDetails(organizationId, parameters.orderId);\r\n      \r\n    case 'capturePayment':\r\n      // Validate required parameters\r\n      if (!parameters.orderId || typeof parameters.orderId !== 'string') {\r\n        throw new Error('orderId (string) is required for capturePayment');\r\n      }\r\n      \r\n      return await captureOrder(organizationId, parameters.orderId);\r\n      \r\n    default:\r\n      throw new Error(`Unknown PayPal function: ${functionName}`);\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\David\\PycharmProjects\\AI Sales Platform\\src\\lib\\integrations\\payment\\square.ts","messages":[{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":49,"column":7,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":65,"endColumn":10},{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":72,"column":7,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":72,"endColumn":42},{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":85,"column":7,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":99,"endColumn":10},{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":106,"column":7,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":106,"endColumn":58}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Square Function Executor\r\n * Allows AI agent to call Square functions\r\n */\r\n\r\nimport type { ConnectedIntegration } from '@/types/integrations';\r\nimport { apiKeyService } from '@/lib/api-keys/api-key-service';\r\n\r\n/**\r\n * Execute a Square function\r\n */\r\nexport async function executeSquareFunction(\r\n  functionName: string,\r\n  parameters: Record<string, any>,\r\n  integration: ConnectedIntegration\r\n): Promise<any> {\r\n  const organizationId = integration.organizationId || '';\r\n  \r\n  if (!organizationId) {\r\n    throw new Error('Organization ID not configured');\r\n  }\r\n  \r\n  // Get Square API keys from organization settings\r\n  const keys = await apiKeyService.getKeys(organizationId);\r\n  const squareConfig = keys?.payments?.square as any;\r\n  const squareAccessToken = squareConfig?.accessToken;\r\n  \r\n  if (!squareAccessToken) {\r\n    throw new Error('Square not configured. Please add your Square access token in Settings > API Keys');\r\n  }\r\n  \r\n  // Check if production mode based on access token prefix or explicit mode setting\r\n  const isProduction = squareAccessToken.startsWith('sq0atp-') || squareConfig?.environment === 'production';\r\n  const baseUrl = isProduction\r\n    ? 'https://connect.squareup.com'\r\n    : 'https://connect.squareupsandbox.com';\r\n  \r\n  switch (functionName) {\r\n    case 'processPayment':\r\n      // Validate required parameters\r\n      if (typeof parameters.amount !== 'number') {\r\n        throw new Error('amount (number) is required for processPayment');\r\n      }\r\n      if (!parameters.sourceId || typeof parameters.sourceId !== 'string') {\r\n        throw new Error('sourceId (string) is required for processPayment');\r\n      }\r\n      \r\n      // Create payment\r\n      const response = await fetch(`${baseUrl}/v2/payments`, {\r\n        method: 'POST',\r\n        headers: {\r\n          'Authorization': `Bearer ${squareAccessToken}`,\r\n          'Content-Type': 'application/json',\r\n          'Square-Version': '2023-10-18',\r\n        },\r\n        body: JSON.stringify({\r\n          source_id: parameters.sourceId,\r\n          idempotency_key: `${Date.now()}-${Math.random()}`,\r\n          amount_money: {\r\n            amount: parameters.amount,\r\n            currency: parameters.currency || 'USD',\r\n          },\r\n          autocomplete: true,\r\n        }),\r\n      });\r\n      \r\n      if (!response.ok) {\r\n        const error = await response.json();\r\n        throw new Error(`Square API error: ${error.errors?.[0]?.detail || response.statusText}`);\r\n      }\r\n      \r\n      const data = await response.json();\r\n      return {\r\n        paymentId: data.payment.id,\r\n        status: data.payment.status,\r\n        receiptUrl: data.payment.receipt_url,\r\n      };\r\n      \r\n    case 'createCustomer':\r\n      // Validate required parameters\r\n      if (!parameters.email || typeof parameters.email !== 'string') {\r\n        throw new Error('email (string) is required for createCustomer');\r\n      }\r\n      \r\n      const customerResponse = await fetch(`${baseUrl}/v2/customers`, {\r\n        method: 'POST',\r\n        headers: {\r\n          'Authorization': `Bearer ${squareAccessToken}`,\r\n          'Content-Type': 'application/json',\r\n          'Square-Version': '2023-10-18',\r\n        },\r\n        body: JSON.stringify({\r\n          idempotency_key: `${Date.now()}-${Math.random()}`,\r\n          email_address: parameters.email,\r\n          given_name: parameters.givenName,\r\n          family_name: parameters.familyName,\r\n          phone_number: parameters.phoneNumber,\r\n        }),\r\n      });\r\n      \r\n      if (!customerResponse.ok) {\r\n        const error = await customerResponse.json();\r\n        throw new Error(`Square API error: ${error.errors?.[0]?.detail || customerResponse.statusText}`);\r\n      }\r\n      \r\n      const customerData = await customerResponse.json();\r\n      return customerData.customer;\r\n      \r\n    default:\r\n      throw new Error(`Unknown Square function: ${functionName}`);\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\David\\PycharmProjects\\AI Sales Platform\\src\\lib\\integrations\\video\\zoom.ts","messages":[{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":52,"column":7,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":59,"endColumn":9},{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":65,"column":7,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":65,"endColumn":62}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Zoom Function Executor\r\n * Allows AI agent to call Zoom functions\r\n */\r\n\r\nimport type { ConnectedIntegration } from '@/types/integrations';\r\nimport { createZoomMeeting, cancelZoomMeeting } from '../zoom';\r\n\r\n/**\r\n * Execute a Zoom function\r\n */\r\nexport async function executeZoomFunction(\r\n  functionName: string,\r\n  parameters: Record<string, any>,\r\n  integration: ConnectedIntegration\r\n): Promise<any> {\r\n  const organizationId = integration.organizationId || '';\r\n  const accessToken = integration.accessToken || '';\r\n  \r\n  if (!organizationId) {\r\n    throw new Error('Organization ID not configured');\r\n  }\r\n  \r\n  if (!accessToken) {\r\n    throw new Error('Zoom access token not configured');\r\n  }\r\n  \r\n  switch (functionName) {\r\n    case 'createMeeting':\r\n      // Validate required parameters\r\n      if (!parameters.topic || typeof parameters.topic !== 'string') {\r\n        throw new Error('topic (string) is required for createMeeting');\r\n      }\r\n      if (!parameters.startTime || typeof parameters.startTime !== 'string') {\r\n        throw new Error('startTime (string) is required for createMeeting');\r\n      }\r\n      if (typeof parameters.duration !== 'number') {\r\n        throw new Error('duration (number) is required for createMeeting');\r\n      }\r\n      \r\n      return await createZoomMeeting(organizationId, {\r\n        topic: parameters.topic,\r\n        startTime: new Date(parameters.startTime),\r\n        duration: parameters.duration,\r\n        timezone: parameters.timezone,\r\n        agenda: parameters.agenda,\r\n        attendees: parameters.attendees,\r\n      });\r\n      \r\n    case 'getRecordings':\r\n      // Get recordings using Zoom API\r\n      const recordingsResponse = await fetch(\r\n        `https://api.zoom.us/v2/users/me/recordings?from=${parameters.from || new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString().split('T')[0]}`,\r\n        {\r\n          headers: {\r\n            'Authorization': `Bearer ${accessToken}`,\r\n          },\r\n        }\r\n      );\r\n      \r\n      if (!recordingsResponse.ok) {\r\n        throw new Error('Failed to fetch Zoom recordings');\r\n      }\r\n      \r\n      const recordingsData = await recordingsResponse.json();\r\n      return recordingsData.meetings || [];\r\n      \r\n    case 'cancelMeeting':\r\n      // Validate required parameters\r\n      if (!parameters.meetingId || typeof parameters.meetingId !== 'string') {\r\n        throw new Error('meetingId (string) is required for cancelMeeting');\r\n      }\r\n      \r\n      return await cancelZoomMeeting(organizationId, parameters.meetingId);\r\n      \r\n    default:\r\n      throw new Error(`Unknown Zoom function: ${functionName}`);\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\David\\PycharmProjects\\AI Sales Platform\\src\\lib\\middleware\\rate-limiter.ts","messages":[{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":210,"column":7,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":210,"endColumn":63},{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":221,"column":7,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":222,"endColumn":72}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Rate Limiter Middleware\r\n * \r\n * Prevents API abuse by limiting request rates per user/organization.\r\n * \r\n * Features:\r\n * - In-memory rate limiting with TTL\r\n * - Multiple rate limit strategies (per user, per org, per IP)\r\n * - Sliding window algorithm\r\n * - Configurable limits and windows\r\n * \r\n * Usage:\r\n * ```typescript\r\n * export async function POST(request: NextRequest) {\r\n *   const rateLimit = await checkRateLimit(request, {\r\n *     limit: 10,\r\n *     windowMs: 60000 // 10 requests per minute\r\n *   });\r\n *   \r\n *   if (!rateLimit.allowed) {\r\n *     return NextResponse.json({ error: 'Too many requests' }, { status: 429 });\r\n *   }\r\n *   \r\n *   // ... continue with request\r\n * }\r\n * ```\r\n */\r\n\r\nimport { NextRequest } from 'next/server';\r\nimport { logger } from '@/lib/logger/logger';\r\n\r\n// ============================================================================\r\n// TYPES\r\n// ============================================================================\r\n\r\nexport interface RateLimitConfig {\r\n  /** Maximum number of requests allowed within the window */\r\n  limit: number;\r\n  \r\n  /** Time window in milliseconds (default: 60000 = 1 minute) */\r\n  windowMs?: number;\r\n  \r\n  /** Identifier strategy (default: 'ip') */\r\n  strategy?: 'ip' | 'user' | 'org' | 'custom';\r\n  \r\n  /** Custom identifier (required if strategy is 'custom') */\r\n  identifier?: string;\r\n  \r\n  /** Skip rate limiting for certain conditions */\r\n  skip?: (request: NextRequest) => boolean | Promise<boolean>;\r\n}\r\n\r\nexport interface RateLimitResult {\r\n  /** Whether the request is allowed */\r\n  allowed: boolean;\r\n  \r\n  /** Current request count */\r\n  current: number;\r\n  \r\n  /** Maximum requests allowed */\r\n  limit: number;\r\n  \r\n  /** Time until limit resets (ms) */\r\n  resetMs: number;\r\n  \r\n  /** Number of remaining requests */\r\n  remaining: number;\r\n}\r\n\r\ninterface RateLimitEntry {\r\n  count: number;\r\n  resetAt: number;\r\n}\r\n\r\n// ============================================================================\r\n// IN-MEMORY STORE\r\n// ============================================================================\r\n\r\n/**\r\n * Simple in-memory rate limit store\r\n * Note: For production with multiple instances, use Redis or similar\r\n */\r\nclass RateLimitStore {\r\n  private store: Map<string, RateLimitEntry> = new Map();\r\n  private cleanupInterval: NodeJS.Timeout;\r\n  \r\n  constructor() {\r\n    // Clean up expired entries every minute\r\n    this.cleanupInterval = setInterval(() => {\r\n      this.cleanup();\r\n    }, 60000);\r\n  }\r\n  \r\n  /**\r\n   * Increment counter for identifier\r\n   */\r\n  increment(identifier: string, windowMs: number): RateLimitEntry {\r\n    const now = Date.now();\r\n    const existing = this.store.get(identifier);\r\n    \r\n    // If entry exists and hasn't expired, increment\r\n    if (existing && existing.resetAt > now) {\r\n      existing.count++;\r\n      return existing;\r\n    }\r\n    \r\n    // Create new entry\r\n    const entry: RateLimitEntry = {\r\n      count: 1,\r\n      resetAt: now + windowMs\r\n    };\r\n    \r\n    this.store.set(identifier, entry);\r\n    return entry;\r\n  }\r\n  \r\n  /**\r\n   * Get current entry for identifier\r\n   */\r\n  get(identifier: string): RateLimitEntry | null {\r\n    const entry = this.store.get(identifier);\r\n    \r\n    if (!entry) {\r\n      return null;\r\n    }\r\n    \r\n    // Check if expired\r\n    if (entry.resetAt <= Date.now()) {\r\n      this.store.delete(identifier);\r\n      return null;\r\n    }\r\n    \r\n    return entry;\r\n  }\r\n  \r\n  /**\r\n   * Reset counter for identifier\r\n   */\r\n  reset(identifier: string): void {\r\n    this.store.delete(identifier);\r\n  }\r\n  \r\n  /**\r\n   * Clean up expired entries\r\n   */\r\n  private cleanup(): void {\r\n    const now = Date.now();\r\n    let cleaned = 0;\r\n    \r\n    for (const [key, entry] of this.store.entries()) {\r\n      if (entry.resetAt <= now) {\r\n        this.store.delete(key);\r\n        cleaned++;\r\n      }\r\n    }\r\n    \r\n    if (cleaned > 0) {\r\n      logger.info(`Rate limiter cleaned up ${cleaned} expired entries`);\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Get store size (for monitoring)\r\n   */\r\n  size(): number {\r\n    return this.store.size;\r\n  }\r\n  \r\n  /**\r\n   * Clear all entries (for testing)\r\n   */\r\n  clear(): void {\r\n    this.store.clear();\r\n  }\r\n  \r\n  /**\r\n   * Stop cleanup interval\r\n   */\r\n  destroy(): void {\r\n    if (this.cleanupInterval) {\r\n      clearInterval(this.cleanupInterval);\r\n    }\r\n  }\r\n}\r\n\r\n// Global store instance\r\nconst store = new RateLimitStore();\r\n\r\n// ============================================================================\r\n// RATE LIMITING FUNCTIONS\r\n// ============================================================================\r\n\r\n/**\r\n * Get identifier for rate limiting based on strategy\r\n */\r\nasync function getIdentifier(\r\n  request: NextRequest,\r\n  strategy: RateLimitConfig['strategy'],\r\n  customIdentifier?: string\r\n): Promise<string> {\r\n  switch (strategy) {\r\n    case 'custom':\r\n      if (!customIdentifier) {\r\n        throw new Error('Custom identifier required for custom strategy');\r\n      }\r\n      return customIdentifier;\r\n      \r\n    case 'user':\r\n      // Extract user ID from request (e.g., from auth header)\r\n      const authHeader = request.headers.get('authorization');\r\n      if (authHeader) {\r\n        // Parse user ID from JWT or session\r\n        // This is a placeholder - implement based on your auth system\r\n        return `user:${authHeader}`;\r\n      }\r\n      // Fallback to IP if no auth\r\n      return `ip:${getClientIp(request)}`;\r\n      \r\n    case 'org':\r\n      // Extract organization ID from request\r\n      const orgId = request.headers.get('x-organization-id') || \r\n                    request.nextUrl.searchParams.get('organizationId');\r\n      if (orgId) {\r\n        return `org:${orgId}`;\r\n      }\r\n      // Fallback to IP if no org ID\r\n      return `ip:${getClientIp(request)}`;\r\n      \r\n    case 'ip':\r\n    default:\r\n      return `ip:${getClientIp(request)}`;\r\n  }\r\n}\r\n\r\n/**\r\n * Get client IP address from request\r\n */\r\nfunction getClientIp(request: NextRequest): string {\r\n  // Check for forwarded IP (behind proxy)\r\n  const forwarded = request.headers.get('x-forwarded-for');\r\n  if (forwarded) {\r\n    return forwarded.split(',')[0].trim();\r\n  }\r\n  \r\n  const realIp = request.headers.get('x-real-ip');\r\n  if (realIp) {\r\n    return realIp;\r\n  }\r\n  \r\n  // Fallback (may not work in all environments)\r\n  return 'unknown';\r\n}\r\n\r\n/**\r\n * Check if request is rate limited\r\n * \r\n * @param request - Next.js request object\r\n * @param config - Rate limit configuration\r\n * @returns Rate limit result\r\n */\r\nexport async function checkRateLimit(\r\n  request: NextRequest,\r\n  config: RateLimitConfig\r\n): Promise<RateLimitResult> {\r\n  const {\r\n    limit,\r\n    windowMs = 60000, // Default: 1 minute\r\n    strategy = 'ip',\r\n    identifier: customIdentifier,\r\n    skip\r\n  } = config;\r\n  \r\n  try {\r\n    // Check if rate limiting should be skipped\r\n    if (skip && await skip(request)) {\r\n      return {\r\n        allowed: true,\r\n        current: 0,\r\n        limit,\r\n        resetMs: 0,\r\n        remaining: limit\r\n      };\r\n    }\r\n    \r\n    // Get identifier based on strategy\r\n    const identifier = await getIdentifier(request, strategy, customIdentifier);\r\n    \r\n    // Increment counter\r\n    const entry = store.increment(identifier, windowMs);\r\n    \r\n    // Calculate result\r\n    const allowed = entry.count <= limit;\r\n    const resetMs = entry.resetAt - Date.now();\r\n    const remaining = Math.max(0, limit - entry.count);\r\n    \r\n    // Log if rate limit exceeded\r\n    if (!allowed) {\r\n      logger.warn('Rate limit exceeded', {\r\n        identifier,\r\n        current: entry.count,\r\n        limit,\r\n        strategy\r\n      });\r\n    }\r\n    \r\n    return {\r\n      allowed,\r\n      current: entry.count,\r\n      limit,\r\n      resetMs,\r\n      remaining\r\n    };\r\n    \r\n  } catch (error) {\r\n    // On error, allow request but log\r\n    logger.error('Rate limiter error', error as Error);\r\n    \r\n    return {\r\n      allowed: true,\r\n      current: 0,\r\n      limit,\r\n      resetMs: 0,\r\n      remaining: limit\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Rate limit middleware helper\r\n * Returns a 429 response if rate limit exceeded\r\n */\r\nexport async function rateLimitMiddleware(\r\n  request: NextRequest,\r\n  config: RateLimitConfig\r\n): Promise<Response | null> {\r\n  const result = await checkRateLimit(request, config);\r\n  \r\n  if (!result.allowed) {\r\n    return new Response(\r\n      JSON.stringify({\r\n        success: false,\r\n        error: 'Too many requests',\r\n        message: `Rate limit exceeded. Try again in ${Math.ceil(result.resetMs / 1000)} seconds.`,\r\n        rateLimit: {\r\n          limit: result.limit,\r\n          current: result.current,\r\n          remaining: result.remaining,\r\n          resetMs: result.resetMs\r\n        }\r\n      }),\r\n      {\r\n        status: 429,\r\n        headers: {\r\n          'Content-Type': 'application/json',\r\n          'X-RateLimit-Limit': result.limit.toString(),\r\n          'X-RateLimit-Remaining': result.remaining.toString(),\r\n          'X-RateLimit-Reset': new Date(Date.now() + result.resetMs).toISOString(),\r\n          'Retry-After': Math.ceil(result.resetMs / 1000).toString()\r\n        }\r\n      }\r\n    );\r\n  }\r\n  \r\n  return null; // Allow request to proceed\r\n}\r\n\r\n/**\r\n * Reset rate limit for identifier (useful for testing)\r\n */\r\nexport function resetRateLimit(identifier: string): void {\r\n  store.reset(identifier);\r\n}\r\n\r\n/**\r\n * Get store statistics (for monitoring)\r\n */\r\nexport function getRateLimitStats() {\r\n  return {\r\n    activeEntries: store.size()\r\n  };\r\n}\r\n\r\n// ============================================================================\r\n// PRESET CONFIGURATIONS\r\n// ============================================================================\r\n\r\n/**\r\n * Preset rate limits for common use cases\r\n */\r\nexport const RateLimitPresets = {\r\n  /** Strict: 10 requests per minute */\r\n  STRICT: {\r\n    limit: 10,\r\n    windowMs: 60000\r\n  },\r\n  \r\n  /** Standard: 60 requests per minute */\r\n  STANDARD: {\r\n    limit: 60,\r\n    windowMs: 60000\r\n  },\r\n  \r\n  /** Generous: 300 requests per minute */\r\n  GENEROUS: {\r\n    limit: 300,\r\n    windowMs: 60000\r\n  },\r\n  \r\n  /** AI endpoints: 20 requests per minute (expensive operations) */\r\n  AI_OPERATIONS: {\r\n    limit: 20,\r\n    windowMs: 60000\r\n  },\r\n  \r\n  /** Data mutations: 30 requests per minute */\r\n  MUTATIONS: {\r\n    limit: 30,\r\n    windowMs: 60000\r\n  },\r\n  \r\n  /** Read operations: 120 requests per minute */\r\n  READS: {\r\n    limit: 120,\r\n    windowMs: 60000\r\n  }\r\n} as const;\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\David\\PycharmProjects\\AI Sales Platform\\src\\lib\\monitoring\\health-check.ts","messages":[{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":253,"column":63,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":253,"endColumn":76}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Health Check & Monitoring Service\r\n * System health monitoring and alerting\r\n */\r\n\r\nimport { logger } from '@/lib/logger/logger';\r\n\r\nexport interface HealthCheckResult {\r\n  status: 'healthy' | 'degraded' | 'unhealthy';\r\n  timestamp: string;\r\n  uptime: number;\r\n  checks: {\r\n    database: HealthStatus;\r\n    cache: HealthStatus;\r\n    ai: HealthStatus;\r\n    payments: HealthStatus;\r\n    integrations: HealthStatus;\r\n  };\r\n  metrics: {\r\n    memory: MemoryMetrics;\r\n    cpu: CPUMetrics;\r\n    requests: RequestMetrics;\r\n  };\r\n}\r\n\r\nexport interface HealthStatus {\r\n  status: 'pass' | 'warn' | 'fail';\r\n  message?: string;\r\n  responseTime?: number;\r\n  lastChecked: string;\r\n}\r\n\r\nexport interface MemoryMetrics {\r\n  used: number;\r\n  total: number;\r\n  percentage: number;\r\n}\r\n\r\nexport interface CPUMetrics {\r\n  usage: number;\r\n  loadAverage: number[];\r\n}\r\n\r\nexport interface RequestMetrics {\r\n  total: number;\r\n  errorsLast24h: number;\r\n  avgResponseTime: number;\r\n}\r\n\r\n/**\r\n * Perform comprehensive health check\r\n */\r\nexport async function performHealthCheck(): Promise<HealthCheckResult> {\r\n  const startTime = Date.now();\r\n  \r\n  const [\r\n    databaseHealth,\r\n    cacheHealth,\r\n    aiHealth,\r\n    paymentsHealth,\r\n    integrationsHealth,\r\n  ] = await Promise.all([\r\n    checkDatabase(),\r\n    checkCache(),\r\n    checkAI(),\r\n    checkPayments(),\r\n    checkIntegrations(),\r\n  ]);\r\n  \r\n  const metrics = await gatherMetrics();\r\n  \r\n  // Determine overall status\r\n  const allChecks = [\r\n    databaseHealth,\r\n    cacheHealth,\r\n    aiHealth,\r\n    paymentsHealth,\r\n    integrationsHealth,\r\n  ];\r\n  \r\n  let status: 'healthy' | 'degraded' | 'unhealthy' = 'healthy';\r\n  \r\n  if (allChecks.some(check => check.status === 'fail')) {\r\n    status = 'unhealthy';\r\n  } else if (allChecks.some(check => check.status === 'warn')) {\r\n    status = 'degraded';\r\n  }\r\n  \r\n  return {\r\n    status,\r\n    timestamp: new Date().toISOString(),\r\n    uptime: process.uptime(),\r\n    checks: {\r\n      database: databaseHealth,\r\n      cache: cacheHealth,\r\n      ai: aiHealth,\r\n      payments: paymentsHealth,\r\n      integrations: integrationsHealth,\r\n    },\r\n    metrics,\r\n  };\r\n}\r\n\r\n/**\r\n * Check database connectivity\r\n */\r\nasync function checkDatabase(): Promise<HealthStatus> {\r\n  const startTime = Date.now();\r\n  \r\n  try {\r\n    const { FirestoreService } = await import('@/lib/db/firestore-service');\r\n    \r\n    // Simple ping query\r\n    await FirestoreService.get('_health', 'check');\r\n    \r\n    const responseTime = Date.now() - startTime;\r\n    \r\n    return {\r\n      status: responseTime < 100 ? 'pass' : responseTime < 500 ? 'warn' : 'fail',\r\n      message: `Database responding in ${responseTime}ms`,\r\n      responseTime,\r\n      lastChecked: new Date().toISOString(),\r\n    };\r\n  } catch (error: any) {\r\n    return {\r\n      status: 'fail',\r\n      message: `Database error: ${error.message}`,\r\n      lastChecked: new Date().toISOString(),\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Check cache connectivity\r\n */\r\nasync function checkCache(): Promise<HealthStatus> {\r\n  const startTime = Date.now();\r\n  \r\n  try {\r\n    const { cacheService } = await import('@/lib/cache/redis-service');\r\n    \r\n    // Test cache operation\r\n    await cacheService.set('_health_check', Date.now(), { ttl: 10 });\r\n    await cacheService.get('_health_check');\r\n    \r\n    const responseTime = Date.now() - startTime;\r\n    \r\n    return {\r\n      status: 'pass',\r\n      message: `Cache responding in ${responseTime}ms`,\r\n      responseTime,\r\n      lastChecked: new Date().toISOString(),\r\n    };\r\n  } catch (error: any) {\r\n    return {\r\n      status: 'warn',\r\n      message: `Cache unavailable (using fallback): ${error.message}`,\r\n      lastChecked: new Date().toISOString(),\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Check AI services\r\n */\r\nasync function checkAI(): Promise<HealthStatus> {\r\n  try {\r\n    // Check if AI services are configured\r\n    const hasGemini = !!process.env.GEMINI_API_KEY;\r\n    const hasOpenAI = !!process.env.OPENAI_API_KEY;\r\n    const hasAnthropic = !!process.env.ANTHROPIC_API_KEY;\r\n    \r\n    if (!hasGemini && !hasOpenAI && !hasAnthropic) {\r\n      return {\r\n        status: 'fail',\r\n        message: 'No AI providers configured',\r\n        lastChecked: new Date().toISOString(),\r\n      };\r\n    }\r\n    \r\n    return {\r\n      status: 'pass',\r\n      message: `AI providers configured: ${[hasGemini && 'Gemini', hasOpenAI && 'OpenAI', hasAnthropic && 'Anthropic'].filter(Boolean).join(', ')}`,\r\n      lastChecked: new Date().toISOString(),\r\n    };\r\n  } catch (error: any) {\r\n    return {\r\n      status: 'fail',\r\n      message: `AI check error: ${error.message}`,\r\n      lastChecked: new Date().toISOString(),\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Check payment services\r\n */\r\nasync function checkPayments(): Promise<HealthStatus> {\r\n  try {\r\n    const hasStripe = !!process.env.STRIPE_SECRET_KEY;\r\n    \r\n    return {\r\n      status: hasStripe ? 'pass' : 'warn',\r\n      message: hasStripe ? 'Payment providers configured' : 'No payment providers configured',\r\n      lastChecked: new Date().toISOString(),\r\n    };\r\n  } catch (error: any) {\r\n    return {\r\n      status: 'warn',\r\n      message: `Payment check error: ${error.message}`,\r\n      lastChecked: new Date().toISOString(),\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Check integrations\r\n */\r\nasync function checkIntegrations(): Promise<HealthStatus> {\r\n  try {\r\n    return {\r\n      status: 'pass',\r\n      message: 'Integrations operational',\r\n      lastChecked: new Date().toISOString(),\r\n    };\r\n  } catch (error: any) {\r\n    return {\r\n      status: 'warn',\r\n      message: `Integration check error: ${error.message}`,\r\n      lastChecked: new Date().toISOString(),\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Gather system metrics\r\n */\r\nasync function gatherMetrics(): Promise<{\r\n  memory: MemoryMetrics;\r\n  cpu: CPUMetrics;\r\n  requests: RequestMetrics;\r\n}> {\r\n  const memUsage = process.memoryUsage();\r\n  \r\n  return {\r\n    memory: {\r\n      used: memUsage.heapUsed,\r\n      total: memUsage.heapTotal,\r\n      percentage: (memUsage.heapUsed / memUsage.heapTotal) * 100,\r\n    },\r\n    cpu: {\r\n      usage: process.cpuUsage().user / 1000000, // Convert to seconds\r\n      loadAverage: process.platform === 'win32' ? [0, 0, 0] : require('os').loadavg(),\r\n    },\r\n    requests: {\r\n      total: 0, // Would be tracked by middleware\r\n      errorsLast24h: 0, // Would be tracked by error handler\r\n      avgResponseTime: 0, // Would be tracked by middleware\r\n    },\r\n  };\r\n}\r\n\r\n/**\r\n * Send alert if system is unhealthy\r\n */\r\nexport async function sendAlert(health: HealthCheckResult): Promise<void> {\r\n  if (health.status === 'healthy') return;\r\n  \r\n  logger.error('[Health Check] System is unhealthy', new Error(`System status: ${health.status}`), { \r\n    status: health.status, \r\n    health,\r\n    file: 'health-check.ts' \r\n  });\r\n  \r\n  // In production, send to Slack/PagerDuty/Email\r\n  if (process.env.SLACK_WEBHOOK_URL) {\r\n    try {\r\n      await fetch(process.env.SLACK_WEBHOOK_URL, {\r\n        method: 'POST',\r\n        headers: { 'Content-Type': 'application/json' },\r\n        body: JSON.stringify({\r\n          text: `≡ƒÜ¿ System Health Alert: ${health.status.toUpperCase()}`,\r\n          attachments: [{\r\n            color: health.status === 'unhealthy' ? 'danger' : 'warning',\r\n            fields: Object.entries(health.checks).map(([name, check]) => ({\r\n              title: name,\r\n              value: `${check.status}: ${check.message || 'N/A'}`,\r\n              short: true,\r\n            })),\r\n          }],\r\n        }),\r\n      });\r\n    } catch (error) {\r\n      logger.error('[Health Check] Failed to send Slack alert:', error, { file: 'health-check.ts' });\r\n    }\r\n  }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\David\\PycharmProjects\\AI Sales Platform\\src\\lib\\orchestration\\coordinator-factory-server.ts","messages":[{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":34,"column":20,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":34,"endColumn":51},{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":35,"column":26,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":35,"endColumn":61}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * SignalCoordinator Factory - SERVER ONLY\r\n * \r\n * This file is for server-side (Node.js) contexts only.\r\n * Uses firebase-admin and admin-dal.\r\n * \r\n * USAGE:\r\n * ```typescript\r\n * import { getServerSignalCoordinator } from '@/lib/orchestration/coordinator-factory-server';\r\n * \r\n * const coordinator = getServerSignalCoordinator();\r\n * await coordinator.emitSignal({...});\r\n * ```\r\n */\r\n\r\nimport 'server-only';\r\n\r\nimport { SignalCoordinator, SignalCoordinatorConfig } from './SignalCoordinator';\r\n\r\n// Lazy-loaded instance to avoid circular dependencies\r\nlet serverCoordinator: SignalCoordinator | null = null;\r\n\r\n/**\r\n * Get SignalCoordinator for server-side (admin) context\r\n * Uses firebase-admin and admin-dal\r\n */\r\nexport function getServerSignalCoordinator(config?: SignalCoordinatorConfig): SignalCoordinator {\r\n  if (serverCoordinator) {\r\n    return serverCoordinator;\r\n  }\r\n\r\n  try {\r\n    // Import server-side dependencies\r\n    const { db } = require('@/lib/firebase-admin');\r\n    const { adminDal } = require('@/lib/firebase/admin-dal');\r\n    \r\n    if (!db) {\r\n      throw new Error('Firebase Admin DB not initialized');\r\n    }\r\n    \r\n    if (!adminDal) {\r\n      throw new Error('Admin DAL not initialized');\r\n    }\r\n\r\n    // Create server coordinator\r\n    serverCoordinator = new SignalCoordinator(db, adminDal, config);\r\n    \r\n    return serverCoordinator;\r\n  } catch (error) {\r\n    throw new Error(`Failed to create server SignalCoordinator: ${error instanceof Error ? error.message : 'Unknown error'}`);\r\n  }\r\n}\r\n\r\n/**\r\n * Reset coordinator instance (useful for testing)\r\n */\r\nexport function resetServerCoordinator(): void {\r\n  serverCoordinator = null;\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\David\\PycharmProjects\\AI Sales Platform\\src\\lib\\outbound\\sequence-engine.ts","messages":[{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":597,"column":11,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":599,"endColumn":13},{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":604,"column":11,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":606,"endColumn":13},{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":611,"column":11,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":611,"endColumn":76},{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":616,"column":11,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":616,"endColumn":80}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Sequence Engine\r\n * Core logic for managing and executing email sequences\r\n */\r\n\r\nimport { \r\n  OutboundSequence,\r\n  ProspectEnrollment,\r\n  SequenceStep,\r\n  StepAction,\r\n  EnrollmentStatus,\r\n  StepActionStatus \r\n} from '@/types/outbound-sequence';\r\nimport { FirestoreService, COLLECTIONS } from '@/lib/db/firestore-service'\r\nimport { logger } from '@/lib/logger/logger';;\r\n\r\nexport class SequenceEngine {\r\n  /**\r\n   * Enroll a prospect in a sequence\r\n   */\r\n  static async enrollProspect(\r\n    prospectId: string,\r\n    sequenceId: string,\r\n    organizationId: string\r\n  ): Promise<ProspectEnrollment> {\r\n    \r\n\r\n    // Load sequence\r\n    const sequence = await this.getSequence(sequenceId, organizationId);\r\n    if (!sequence) {\r\n      throw new Error('Sequence not found');\r\n    }\r\n\r\n    if (sequence.status !== 'active') {\r\n      throw new Error('Cannot enroll in inactive sequence');\r\n    }\r\n\r\n    // Check if already enrolled\r\n    const existing = await this.getEnrollment(prospectId, sequenceId, organizationId);\r\n    if (existing && existing.status === 'active') {\r\n      throw new Error('Prospect already enrolled in this sequence');\r\n    }\r\n\r\n    // Create enrollment\r\n    const enrollment: ProspectEnrollment = {\r\n      id: `enrollment_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\r\n      sequenceId,\r\n      prospectId,\r\n      organizationId,\r\n      status: 'active',\r\n      currentStep: 0,\r\n      enrolledAt: new Date().toISOString(),\r\n      nextStepAt: this.calculateNextStepTime(sequence.steps[0]),\r\n      stepActions: [],\r\n      createdAt: new Date().toISOString(),\r\n      updatedAt: new Date().toISOString(),\r\n    };\r\n\r\n    // Save enrollment\r\n    await this.saveEnrollment(enrollment);\r\n\r\n    // Schedule first step\r\n    await this.scheduleStep(enrollment, sequence.steps[0]);\r\n\r\n    // Update sequence analytics\r\n    await this.updateSequenceAnalytics(sequenceId, organizationId, {\r\n      totalEnrolled: 1,\r\n      activeProspects: 1,\r\n    });\r\n\r\n    \r\n\r\n    return enrollment;\r\n  }\r\n\r\n  /**\r\n   * Unenroll a prospect from a sequence\r\n   */\r\n  static async unenrollProspect(\r\n    prospectId: string,\r\n    sequenceId: string,\r\n    organizationId: string,\r\n    reason: 'manual' | 'replied' | 'converted' | 'unsubscribed' | 'bounced'\r\n  ): Promise<void> {\r\n    \r\n\r\n    const enrollment = await this.getEnrollment(prospectId, sequenceId, organizationId);\r\n    if (!enrollment) {\r\n      throw new Error('Enrollment not found');\r\n    }\r\n\r\n    enrollment.status = reason === 'unsubscribed' ? 'unsubscribed' : \r\n                         reason === 'bounced' ? 'bounced' : 'removed';\r\n    enrollment.outcome = reason === 'manual' ? 'removed' : reason;\r\n    enrollment.outcomeDate = new Date().toISOString();\r\n    enrollment.completedAt = new Date().toISOString();\r\n    enrollment.updatedAt = new Date().toISOString();\r\n\r\n    await this.saveEnrollment(enrollment);\r\n\r\n    // Update sequence analytics\r\n    await this.updateSequenceAnalytics(sequenceId, organizationId, {\r\n      activeProspects: -1,\r\n      completedProspects: 1,\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Process next step for a prospect\r\n   */\r\n  static async processNextStep(\r\n    enrollmentId: string,\r\n    organizationId: string\r\n  ): Promise<void> {\r\n    const enrollment = await this.getEnrollmentById(enrollmentId, organizationId);\r\n    if (!enrollment || enrollment.status !== 'active') {\r\n      return; // Nothing to process\r\n    }\r\n\r\n    const sequence = await this.getSequence(enrollment.sequenceId, organizationId);\r\n    if (!sequence || sequence.status !== 'active') {\r\n      return;\r\n    }\r\n\r\n    const currentStepIndex = enrollment.currentStep;\r\n    const currentStep = sequence.steps[currentStepIndex];\r\n\r\n    if (!currentStep) {\r\n      // Sequence completed\r\n      await this.completeEnrollment(enrollment, organizationId);\r\n      return;\r\n    }\r\n\r\n    // Check if it's time to send\r\n    const now = new Date();\r\n    const nextStepTime = enrollment.nextStepAt ? new Date(enrollment.nextStepAt) : now;\r\n\r\n    if (now < nextStepTime) {\r\n      return; // Not time yet\r\n    }\r\n\r\n    // Check step conditions\r\n    if (!(await this.checkStepConditions(enrollment, currentStep))) {\r\n      \r\n      await this.skipStep(enrollment, currentStep, organizationId);\r\n      return;\r\n    }\r\n\r\n    // Execute step\r\n    await this.executeStep(enrollment, currentStep, sequence, organizationId);\r\n  }\r\n\r\n  /**\r\n   * Execute a sequence step (send email, create task, etc.)\r\n   */\r\n  private static async executeStep(\r\n    enrollment: ProspectEnrollment,\r\n    step: SequenceStep,\r\n    sequence: OutboundSequence,\r\n    organizationId: string\r\n  ): Promise<void> {\r\n    \r\n\r\n    try {\r\n      // Create step action\r\n      const action: StepAction = {\r\n        stepId: step.id,\r\n        stepOrder: step.order,\r\n        scheduledFor: enrollment.nextStepAt || new Date().toISOString(),\r\n        status: 'sent',\r\n        subject: step.subject,\r\n        body: step.body,\r\n        createdAt: new Date().toISOString(),\r\n      };\r\n\r\n      // Execute based on step type\r\n      switch (step.type) {\r\n        case 'email':\r\n          await this.sendEmail(enrollment, step, organizationId);\r\n          action.sentAt = new Date().toISOString();\r\n          break;\r\n\r\n        case 'linkedin_message':\r\n          await this.sendLinkedInMessage(enrollment, step, organizationId);\r\n          action.sentAt = new Date().toISOString();\r\n          break;\r\n\r\n        case 'sms':\r\n          await this.sendSMS(enrollment, step, organizationId);\r\n          action.sentAt = new Date().toISOString();\r\n          break;\r\n\r\n        case 'call_task':\r\n        case 'manual_task':\r\n          await this.createTask(enrollment, step, organizationId);\r\n          action.status = 'scheduled';\r\n          break;\r\n      }\r\n\r\n      // Add action to enrollment\r\n      enrollment.stepActions.push(action);\r\n\r\n      // Move to next step\r\n      enrollment.currentStep += 1;\r\n\r\n      // Schedule next step\r\n      const nextStep = sequence.steps[enrollment.currentStep];\r\n      if (nextStep) {\r\n        enrollment.nextStepAt = this.calculateNextStepTime(nextStep, new Date());\r\n      } else {\r\n        // No more steps - mark as completed\r\n        enrollment.nextStepAt = undefined;\r\n      }\r\n\r\n      enrollment.updatedAt = new Date().toISOString();\r\n\r\n      await this.saveEnrollment(enrollment);\r\n\r\n      // Update step analytics\r\n      await this.updateStepAnalytics(step.id, organizationId, {\r\n        sent: 1,\r\n      });\r\n\r\n      // Update sequence analytics\r\n      await this.updateSequenceAnalytics(sequence.id, organizationId, {\r\n        totalSent: 1,\r\n      });\r\n\r\n      \r\n    } catch (error: any) {\r\n      logger.error('[Sequence Engine] Error executing step:', error, { file: 'sequence-engine.ts' });\r\n\r\n      // Record failed action\r\n      const failedAction: StepAction = {\r\n        stepId: step.id,\r\n        stepOrder: step.order,\r\n        scheduledFor: enrollment.nextStepAt || new Date().toISOString(),\r\n        status: 'failed',\r\n        error: error.message,\r\n        retryCount: 0,\r\n        createdAt: new Date().toISOString(),\r\n      };\r\n\r\n      enrollment.stepActions.push(failedAction);\r\n      enrollment.updatedAt = new Date().toISOString();\r\n\r\n      await this.saveEnrollment(enrollment);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Send email for a step\r\n   */\r\n  private static async sendEmail(\r\n    enrollment: ProspectEnrollment,\r\n    step: SequenceStep,\r\n    organizationId: string\r\n  ): Promise<void> {\r\n    const { FirestoreService, COLLECTIONS } = await import('@/lib/db/firestore-service');\r\n    \r\n    // Get prospect email from CRM\r\n    const prospect = await FirestoreService.get(\r\n      `${COLLECTIONS.ORGANIZATIONS}/${organizationId}/leads`,\r\n      enrollment.prospectId\r\n    );\r\n\r\n    if (!prospect || !prospect.email) {\r\n      throw new Error('Prospect email not found');\r\n    }\r\n\r\n    // Get organization settings to determine email provider\r\n    const org = await FirestoreService.get(COLLECTIONS.ORGANIZATIONS, organizationId);\r\n    const emailProvider = org?.emailProvider || 'gmail'; // Default to Gmail\r\n    const fromEmail = org?.fromEmail || process.env.FROM_EMAIL;\r\n\r\n    if (!fromEmail) {\r\n      throw new Error('FROM_EMAIL not configured for this organization');\r\n    }\r\n\r\n    // Try Gmail API first (free, integrated)\r\n    try {\r\n      const { sendEmailViaGmail } = await import('@/lib/integrations/gmail-service');\r\n      \r\n      await sendEmailViaGmail({\r\n        to: prospect.email,\r\n        from: fromEmail,\r\n        subject: step.subject || 'Follow-up',\r\n        body: step.body,\r\n        organizationId,\r\n        metadata: {\r\n          enrollmentId: enrollment.id,\r\n          stepId: step.id,\r\n          prospectId: enrollment.prospectId,\r\n        },\r\n      });\r\n\r\n      logger.info('Sequence Engine Email sent via Gmail to prospect.email}', { file: 'sequence-engine.ts' });\r\n      return;\r\n    } catch (gmailError: any) {\r\n      logger.warn('[Sequence Engine] Gmail send failed, trying fallback', { error: gmailError.message, file: 'sequence-engine.ts' });\r\n      \r\n      // Fallback to SendGrid if Gmail fails\r\n      if (emailProvider === 'sendgrid') {\r\n        const { getAPIKey } = await import('@/lib/config/api-keys');\r\n        const sendgridKey = await getAPIKey(organizationId, 'sendgrid');\r\n        \r\n        if (!sendgridKey) {\r\n          throw new Error('Gmail failed and SendGrid not configured. Cannot send email.');\r\n        }\r\n\r\n        const { sendEmail } = await import('@/lib/email/sendgrid-service');\r\n        const result = await sendEmail({\r\n          to: prospect.email,\r\n          subject: step.subject || 'Follow-up',\r\n          html: step.body,\r\n          tracking: {\r\n            trackOpens: true,\r\n            trackClicks: true,\r\n          },\r\n          metadata: {\r\n            enrollmentId: enrollment.id,\r\n            stepId: step.id,\r\n            organizationId,\r\n            prospectId: enrollment.prospectId,\r\n          },\r\n        }, sendgridKey);\r\n\r\n        if (!result.success) {\r\n          throw new Error(result.error || 'Failed to send email via SendGrid');\r\n        }\r\n\r\n        logger.info('Sequence Engine Email sent via SendGrid to prospect.email}', { file: 'sequence-engine.ts' });\r\n      } else {\r\n        throw gmailError;\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Send LinkedIn message\r\n   */\r\n  private static async sendLinkedInMessage(\r\n    enrollment: ProspectEnrollment,\r\n    step: SequenceStep,\r\n    organizationId: string\r\n  ): Promise<void> {\r\n    \r\n    \r\n    // Get prospect details\r\n    const prospect = await FirestoreService.get(\r\n      `${COLLECTIONS.ORGANIZATIONS}/${organizationId}/prospects`,\r\n      enrollment.prospectId\r\n    );\r\n    \r\n    if (!prospect) {\r\n      throw new Error(`Prospect ${enrollment.prospectId} not found`);\r\n    }\r\n    \r\n    // Get LinkedIn integration credentials\r\n    const integrations = await FirestoreService.getAll(\r\n      `${COLLECTIONS.ORGANIZATIONS}/${organizationId}/integrations`\r\n    );\r\n    const integration = integrations.filter((i: any) => i.service === 'linkedin');\r\n    \r\n    if (!integration || integration.length === 0) {\r\n      throw new Error('LinkedIn integration not configured');\r\n    }\r\n    \r\n    const linkedInToken = integration[0].accessToken;\r\n    \r\n    // Send LinkedIn message via RapidAPI or LinkedIn API\r\n    const { sendLinkedInMessage } = await import('@/lib/integrations/linkedin-messaging');\r\n    \r\n    await sendLinkedInMessage(\r\n      linkedInToken,\r\n      prospect.linkedInUrl || prospect.email,\r\n      step.content,\r\n      organizationId\r\n    );\r\n    \r\n    // Track step execution\r\n    await this.trackStepExecution(enrollment.id, step.id, organizationId, 'success');\r\n  }\r\n\r\n  /**\r\n   * Send SMS\r\n   */\r\n  private static async sendSMS(\r\n    enrollment: ProspectEnrollment,\r\n    step: SequenceStep,\r\n    organizationId: string\r\n  ): Promise<void> {\r\n    \r\n    \r\n    // Get prospect details\r\n    const prospect = await FirestoreService.get(\r\n      `${COLLECTIONS.ORGANIZATIONS}/${organizationId}/prospects`,\r\n      enrollment.prospectId\r\n    );\r\n    \r\n    if (!prospect || !prospect.phone) {\r\n      throw new Error(`Prospect ${enrollment.prospectId} has no phone number`);\r\n    }\r\n    \r\n    // Send SMS via Twilio\r\n    const { sendSMS } = await import('@/lib/sms/sms-service');\r\n    \r\n    const result = await sendSMS({\r\n      to: prospect.phone,\r\n      message: step.content,\r\n      organizationId,\r\n    });\r\n    \r\n    if (!result.success) {\r\n      throw new Error(result.error || 'Failed to send SMS');\r\n    }\r\n    \r\n    // Save SMS record with Twilio message ID for webhook tracking\r\n    const smsRecordId = result.messageId || `${Date.now()}-${enrollment.prospectId}`;\r\n    await FirestoreService.set(\r\n      `${COLLECTIONS.ORGANIZATIONS}/${organizationId}/smsMessages`,\r\n      smsRecordId,\r\n      {\r\n        id: smsRecordId,\r\n        messageId: result.messageId, // Twilio SID for webhook matching\r\n        prospectId: enrollment.prospectId,\r\n        sequenceId: enrollment.sequenceId,\r\n        enrollmentId: enrollment.id,\r\n        stepId: step.id,\r\n        to: prospect.phone,\r\n        message: step.content,\r\n        status: 'sent',\r\n        sentAt: new Date().toISOString(),\r\n        provider: result.provider || 'twilio',\r\n        createdAt: new Date().toISOString(),\r\n        updatedAt: new Date().toISOString(),\r\n      }\r\n    );\r\n    \r\n    // Track step execution\r\n    await this.trackStepExecution(enrollment.id, step.id, organizationId, 'success');\r\n  }\r\n\r\n  /**\r\n   * Create task\r\n   */\r\n  private static async createTask(\r\n    enrollment: ProspectEnrollment,\r\n    step: SequenceStep,\r\n    organizationId: string\r\n  ): Promise<void> {\r\n    \r\n    \r\n    // Get prospect details\r\n    const prospect = await FirestoreService.get(\r\n      `${COLLECTIONS.ORGANIZATIONS}/${organizationId}/prospects`,\r\n      enrollment.prospectId\r\n    );\r\n    \r\n    if (!prospect) {\r\n      throw new Error(`Prospect ${enrollment.prospectId} not found`);\r\n    }\r\n    \r\n    // Calculate task due date\r\n    const dueDate = new Date();\r\n    dueDate.setDate(dueDate.getDate() + (step.taskDueDays || 1));\r\n    \r\n    // Create task in CRM\r\n    const taskId = `task-${Date.now()}-${enrollment.prospectId}`;\r\n    const task = {\r\n      id: taskId,\r\n      organizationId,\r\n      title: step.taskTitle || `Follow up with ${prospect.name}`,\r\n      description: step.content || `Automated task from sequence: ${enrollment.sequenceId}`,\r\n      type: 'follow-up',\r\n      status: 'pending',\r\n      priority: step.taskPriority || 'medium',\r\n      dueDate,\r\n      relatedTo: {\r\n        type: 'prospect',\r\n        id: enrollment.prospectId,\r\n        name: prospect.name,\r\n      },\r\n      sequenceId: enrollment.sequenceId,\r\n      stepId: step.id,\r\n      assignedTo: step.taskAssignee || 'unassigned',\r\n      createdBy: 'sequence-engine',\r\n      createdAt: new Date(),\r\n      updatedAt: new Date(),\r\n    };\r\n    \r\n    await FirestoreService.set(\r\n      `${COLLECTIONS.ORGANIZATIONS}/${organizationId}/tasks`,\r\n      taskId,\r\n      task\r\n    );\r\n    \r\n    // Track step execution\r\n    await this.trackStepExecution(enrollment.id, step.id, organizationId, 'success');\r\n  }\r\n  \r\n  /**\r\n   * Track step execution for analytics\r\n   */\r\n  private static async trackStepExecution(\r\n    enrollmentId: string,\r\n    stepId: string,\r\n    organizationId: string,\r\n    status: 'success' | 'failed' | 'skipped',\r\n    error?: string\r\n  ): Promise<void> {\r\n    try {\r\n      const analyticsId = `${enrollmentId}-${stepId}-${Date.now()}`;\r\n      \r\n      await FirestoreService.set(\r\n        `${COLLECTIONS.ORGANIZATIONS}/${organizationId}/sequenceAnalytics`,\r\n        analyticsId,\r\n        {\r\n          enrollmentId,\r\n          stepId,\r\n          status,\r\n          error,\r\n          executedAt: new Date(),\r\n          createdAt: new Date(),\r\n        }\r\n      );\r\n      \r\n      // Update step statistics\r\n      const statsId = `step-${stepId}`;\r\n      const currentStats = await FirestoreService.get(\r\n        `${COLLECTIONS.ORGANIZATIONS}/${organizationId}/sequenceStepStats`,\r\n        statsId\r\n      );\r\n      \r\n      const stats = currentStats || {\r\n        stepId,\r\n        totalExecutions: 0,\r\n        successCount: 0,\r\n        failedCount: 0,\r\n        skippedCount: 0,\r\n      };\r\n      \r\n      stats.totalExecutions += 1;\r\n      if (status === 'success') stats.successCount += 1;\r\n      if (status === 'failed') stats.failedCount += 1;\r\n      if (status === 'skipped') stats.skippedCount += 1;\r\n      stats.successRate = (stats.successCount / stats.totalExecutions) * 100;\r\n      stats.updatedAt = new Date();\r\n      \r\n      await FirestoreService.set(\r\n        `${COLLECTIONS.ORGANIZATIONS}/${organizationId}/sequenceStepStats`,\r\n        statsId,\r\n        stats\r\n      );\r\n    } catch (error) {\r\n      logger.error('[Sequence Engine] Error tracking step execution:', error, { file: 'sequence-engine.ts' });\r\n      // Don't throw - analytics failure shouldn't stop execution\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate when next step should execute\r\n   */\r\n  private static calculateNextStepTime(\r\n    step: SequenceStep,\r\n    fromDate: Date = new Date()\r\n  ): string {\r\n    const nextTime = new Date(fromDate);\r\n    nextTime.setDate(nextTime.getDate() + step.delayDays);\r\n    \r\n    if (step.delayHours) {\r\n      nextTime.setHours(nextTime.getHours() + step.delayHours);\r\n    }\r\n\r\n    // Apply send time if specified\r\n    if (step.sendTime) {\r\n      nextTime.setHours(step.sendTime.hour, step.sendTime.minute, 0, 0);\r\n    }\r\n\r\n    return nextTime.toISOString();\r\n  }\r\n\r\n  /**\r\n   * Check if step conditions are met\r\n   */\r\n  private static async checkStepConditions(\r\n    enrollment: ProspectEnrollment,\r\n    step: SequenceStep\r\n  ): Promise<boolean> {\r\n    if (!step.conditions || step.conditions.length === 0) {\r\n      return true; // No conditions, always proceed\r\n    }\r\n\r\n    for (const condition of step.conditions) {\r\n      switch (condition.type) {\r\n        case 'opened_previous':\r\n          const previousOpened = enrollment.stepActions.some(\r\n            a => a.stepOrder === step.order - 1 && a.openedAt\r\n          );\r\n          if (!previousOpened) return false;\r\n          break;\r\n\r\n        case 'not_opened_previous':\r\n          const previousNotOpened = !enrollment.stepActions.some(\r\n            a => a.stepOrder === step.order - 1 && a.openedAt\r\n          );\r\n          if (!previousNotOpened) return false;\r\n          break;\r\n\r\n        case 'replied':\r\n          const hasReplied = enrollment.stepActions.some(a => a.repliedAt);\r\n          if (!hasReplied) return false;\r\n          break;\r\n\r\n        case 'not_replied':\r\n          const hasNotReplied = !enrollment.stepActions.some(a => a.repliedAt);\r\n          if (!hasNotReplied) return false;\r\n          break;\r\n      }\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Skip a step\r\n   */\r\n  private static async skipStep(\r\n    enrollment: ProspectEnrollment,\r\n    step: SequenceStep,\r\n    organizationId: string\r\n  ): Promise<void> {\r\n    const skippedAction: StepAction = {\r\n      stepId: step.id,\r\n      stepOrder: step.order,\r\n      scheduledFor: enrollment.nextStepAt || new Date().toISOString(),\r\n      status: 'skipped',\r\n      createdAt: new Date().toISOString(),\r\n    };\r\n\r\n    enrollment.stepActions.push(skippedAction);\r\n    enrollment.currentStep += 1;\r\n    enrollment.updatedAt = new Date().toISOString();\r\n\r\n    await this.saveEnrollment(enrollment);\r\n  }\r\n\r\n  /**\r\n   * Complete enrollment\r\n   */\r\n  private static async completeEnrollment(\r\n    enrollment: ProspectEnrollment,\r\n    organizationId: string\r\n  ): Promise<void> {\r\n    enrollment.status = 'completed';\r\n    enrollment.outcome = 'completed';\r\n    enrollment.completedAt = new Date().toISOString();\r\n    enrollment.outcomeDate = new Date().toISOString();\r\n    enrollment.updatedAt = new Date().toISOString();\r\n\r\n    await this.saveEnrollment(enrollment);\r\n\r\n    await this.updateSequenceAnalytics(enrollment.sequenceId, organizationId, {\r\n      activeProspects: -1,\r\n      completedProspects: 1,\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Get sequence from Firestore\r\n   */\r\n  private static async getSequence(\r\n    sequenceId: string,\r\n    organizationId: string\r\n  ): Promise<OutboundSequence | null> {\r\n    return await FirestoreService.get(\r\n      `${COLLECTIONS.ORGANIZATIONS}/${organizationId}/sequences`,\r\n      sequenceId\r\n    ) as OutboundSequence | null;\r\n  }\r\n\r\n  /**\r\n   * Get enrollment\r\n   */\r\n  private static async getEnrollment(\r\n    prospectId: string,\r\n    sequenceId: string,\r\n    organizationId: string\r\n  ): Promise<ProspectEnrollment | null> {\r\n    try {\r\n      const { where, limit } = await import('firebase/firestore');\r\n      \r\n      const enrollments = await FirestoreService.getAll<ProspectEnrollment>(\r\n        `${COLLECTIONS.ORGANIZATIONS}/${organizationId}/enrollments`,\r\n        [\r\n          where('prospectId', '==', prospectId),\r\n          where('sequenceId', '==', sequenceId),\r\n          limit(1)\r\n        ]\r\n      );\r\n      \r\n      return enrollments.length > 0 ? enrollments[0] : null;\r\n    } catch (error) {\r\n      logger.error('[SequenceEngine] Error getting enrollment:', error, { file: 'sequence-engine.ts' });\r\n    return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get enrollment by ID\r\n   */\r\n  private static async getEnrollmentById(\r\n    enrollmentId: string,\r\n    organizationId: string\r\n  ): Promise<ProspectEnrollment | null> {\r\n    return await FirestoreService.get(\r\n      `${COLLECTIONS.ORGANIZATIONS}/${organizationId}/enrollments`,\r\n      enrollmentId\r\n    ) as ProspectEnrollment | null;\r\n  }\r\n\r\n  /**\r\n   * Save enrollment\r\n   */\r\n  private static async saveEnrollment(enrollment: ProspectEnrollment): Promise<void> {\r\n    await FirestoreService.set(\r\n      `${COLLECTIONS.ORGANIZATIONS}/${enrollment.organizationId}/enrollments`,\r\n      enrollment.id,\r\n      enrollment,\r\n      false\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Update sequence analytics\r\n   */\r\n  private static async updateSequenceAnalytics(\r\n    sequenceId: string,\r\n    organizationId: string,\r\n    updates: Partial<OutboundSequence['analytics']>\r\n  ): Promise<void> {\r\n    const sequence = await this.getSequence(sequenceId, organizationId);\r\n    if (!sequence) return;\r\n\r\n    // Increment analytics\r\n    Object.keys(updates).forEach((key) => {\r\n      const value = updates[key as keyof typeof updates];\r\n      if (typeof value === 'number') {\r\n        (sequence.analytics as any)[key] = ((sequence.analytics as any)[key] || 0) + value;\r\n      }\r\n    });\r\n\r\n    // Recalculate rates\r\n    sequence.analytics.deliveryRate = sequence.analytics.totalSent > 0\r\n      ? (sequence.analytics.totalDelivered / sequence.analytics.totalSent) * 100\r\n      : 0;\r\n\r\n    sequence.analytics.openRate = sequence.analytics.totalDelivered > 0\r\n      ? (sequence.analytics.totalOpened / sequence.analytics.totalDelivered) * 100\r\n      : 0;\r\n\r\n    sequence.analytics.clickRate = sequence.analytics.totalDelivered > 0\r\n      ? (sequence.analytics.totalClicked / sequence.analytics.totalDelivered) * 100\r\n      : 0;\r\n\r\n    sequence.analytics.replyRate = sequence.analytics.totalDelivered > 0\r\n      ? (sequence.analytics.totalReplied / sequence.analytics.totalDelivered) * 100\r\n      : 0;\r\n\r\n    sequence.analytics.conversionRate = sequence.analytics.totalEnrolled > 0\r\n      ? (sequence.analytics.meetingsBooked / sequence.analytics.totalEnrolled) * 100\r\n      : 0;\r\n\r\n    sequence.analytics.lastRun = new Date().toISOString();\r\n\r\n    await FirestoreService.set(\r\n      `${COLLECTIONS.ORGANIZATIONS}/${organizationId}/sequences`,\r\n      sequenceId,\r\n      sequence,\r\n      false\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Update step analytics\r\n   */\r\n  private static async updateStepAnalytics(\r\n    stepId: string,\r\n    organizationId: string,\r\n    updates: Partial<SequenceStep>\r\n  ): Promise<void> {\r\n    try {\r\n      // Find the sequence that contains this step\r\n      const sequencesPath = `organizations/${organizationId}/sequences`;\r\n      const sequences = await FirestoreService.getAll<OutboundSequence>(sequencesPath);\r\n      \r\n      let targetSequence: OutboundSequence | null = null;\r\n      let targetStepIndex = -1;\r\n      \r\n      for (const sequence of sequences) {\r\n        const stepIndex = sequence.steps.findIndex(s => s.id === stepId);\r\n        if (stepIndex !== -1) {\r\n          targetSequence = sequence;\r\n          targetStepIndex = stepIndex;\r\n          break;\r\n        }\r\n      }\r\n      \r\n      if (!targetSequence || targetStepIndex === -1) {\r\n        logger.warn('Step not found for analytics update', { stepId, organizationId });\r\n        return;\r\n      }\r\n      \r\n      // Get the current step\r\n      const step = targetSequence.steps[targetStepIndex];\r\n      \r\n      // Update analytics fields with increments\r\n      const updatedStep = {\r\n        ...step,\r\n        sent: (step.sent || 0) + (updates.sent || 0),\r\n        delivered: (step.delivered || 0) + (updates.delivered || 0),\r\n        opened: (step.opened || 0) + (updates.opened || 0),\r\n        clicked: (step.clicked || 0) + (updates.clicked || 0),\r\n        replied: (step.replied || 0) + (updates.replied || 0),\r\n        updatedAt: new Date().toISOString(),\r\n      };\r\n      \r\n      // Update the step in the sequence\r\n      targetSequence.steps[targetStepIndex] = updatedStep;\r\n      \r\n      // Save the updated sequence\r\n      const sequencePath = `organizations/${organizationId}/sequences`;\r\n      await FirestoreService.update(sequencePath, targetSequence.id, {\r\n        steps: targetSequence.steps,\r\n        updatedAt: new Date().toISOString(),\r\n      });\r\n      \r\n      logger.info('Step analytics updated', {\r\n        stepId,\r\n        organizationId,\r\n        updates,\r\n        newValues: {\r\n          sent: updatedStep.sent,\r\n          delivered: updatedStep.delivered,\r\n          opened: updatedStep.opened,\r\n          clicked: updatedStep.clicked,\r\n          replied: updatedStep.replied,\r\n        },\r\n      });\r\n    } catch (error) {\r\n      logger.error('Failed to update step analytics', error as Error, {\r\n        stepId,\r\n        organizationId,\r\n        updates,\r\n      });\r\n      // Don't throw - analytics updates shouldn't break the main flow\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Schedule a step for execution\r\n   */\r\n  private static async scheduleStep(\r\n    enrollment: ProspectEnrollment,\r\n    step: SequenceStep\r\n  ): Promise<void> {\r\n    // In production, this would add to a job queue\r\n    \r\n  }\r\n}\r\n\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\David\\PycharmProjects\\AI Sales Platform\\src\\lib\\persona\\templates\\real-estate.ts","messages":[{"ruleId":"no-useless-escape","severity":2,"message":"Unnecessary escape character: \\'.","line":88,"column":156,"nodeType":"Literal","messageId":"unnecessaryEscape","endLine":88,"endColumn":157,"suggestions":[{"messageId":"removeEscape","fix":{"range":[7206,7207],"text":""},"desc":"Remove the `\\`. This maintains the current functionality."},{"messageId":"escapeBackslash","fix":{"range":[7206,7206],"text":"\\"},"desc":"Replace the `\\` with `\\\\` to include the actual backslash character."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { IndustryTemplate } from './types';\n\nexport const realEstateTemplates: Record<string, IndustryTemplate> = {\n  // REAL ESTATE SECTOR (Templates 1-5)\n  // ============================================\n  \n  'residential-real-estate': {\n    id: 'residential-real-estate',\n    name: 'Residential Real Estate',\n    description: 'For agents selling homes - emotional + financial approach',\n    category: 'Real Estate',\n    \n    coreIdentity: {\n      title: 'The High-Status Neighborhood Authority',\n      positioning: 'Professional, protective of equity, and hyper-local',\n      tone: 'Confident authority with protective advisor undertones'\n    },\n    \n    cognitiveLogic: {\n      framework: 'The Lifestyle-to-Asset Pivot',\n      reasoning: 'Logic that connects emotional desires (e.g., \"big yard\") to financial security (e.g., \"high-resale zip code\")',\n      decisionProcess: 'Emotion ΓåÆ Financial Validation ΓåÆ Action'\n    },\n    \n    knowledgeRAG: {\n      static: [\n        'Escrow milestones',\n        'Zoning basics',\n        'Fair Housing laws',\n        'Standard contract terms',\n        'Inspection protocols'\n      ],\n      dynamic: [\n        'MLS listings (real-time)',\n        'School ratings',\n        'Neighborhood trends',\n        'Client\\'s \"Sold\" history',\n        'Comparable sales data',\n        'Interest rate updates'\n      ]\n    },\n    \n    learningLoops: {\n      patternRecognition: 'Identifies \"Feature Trends\" (e.g., high demand for home offices, outdoor spaces, smart home tech)',\n      adaptation: 'Alerts client to update marketing copy to reflect current trends and buyer preferences',\n      feedbackIntegration: 'Tracks which property features drive most viewings and adjusts emphasis accordingly'\n    },\n    \n    tacticalExecution: {\n      primaryAction: 'Tour Booking',\n      conversionRhythm: 'Every 3rd message pushes for a physical viewing or custom \"Market Report\" for their specific zip code',\n      secondaryActions: [\n        'Custom zip code Market Report',\n        'Comparative Market Analysis (CMA)',\n        'Pre-approval referral',\n        'Home valuation request'\n      ]\n    },\n\n    research: {\n      scrapingStrategy: {\n        primarySource: 'website',\n        secondarySources: ['linkedin-company', 'google-business'],\n        frequency: 'per-lead',\n        timeoutMs: 30000,\n        enableCaching: true,\n        cacheTtlSeconds: 300\n      },\n\n      highValueSignals: [\n        {id: 'hiring_agents', label: 'Hiring Real Estate Agents', description: 'Recruiting new agents', keywords: [\"hiring agents\", \"join our team\", \"agent positions\", \"real estate careers\", \"agent recruitment\"], priority: 'HIGH', action: 'increase-score', scoreBoost: 30, platform: 'any'},\n        {id: 'top_producer', label: 'Top Producer', description: 'High sales volume or awards', keywords: [\"top producer\", \"top agent\", \"million dollar\", \"sales leader\", \"award winning\"], priority: 'CRITICAL', action: 'increase-score', scoreBoost: 40, platform: 'website'},\n        {id: 'new_listings', label: 'New Listings', description: 'Recently added properties', keywords: [\"new listing\", \"just listed\", \"coming soon\", \"recently added\"], priority: 'MEDIUM', action: 'increase-score', scoreBoost: 15, platform: 'website'},\n        {id: 'luxury_homes', label: 'Luxury Market', description: 'Specializes in luxury real estate', keywords: [\"luxury homes\", \"luxury real estate\", \"high-end\", \"estates\", \"million dollar homes\"], priority: 'HIGH', action: 'add-to-segment', scoreBoost: 25, platform: 'website'},\n        {id: 'first_time_buyers', label: 'First-Time Buyers', description: 'Focuses on first-time homebuyers', keywords: [\"first time\", \"first-time buyers\", \"first home\", \"buyer assistance\"], priority: 'MEDIUM', action: 'add-to-segment', scoreBoost: 12, platform: 'website'},\n        {id: 'virtual_tours', label: 'Virtual Tours', description: 'Offers 3D or virtual property tours', keywords: [\"virtual tour\", \"3d tour\", \"matterport\", \"video walkthrough\"], priority: 'MEDIUM', action: 'increase-score', scoreBoost: 10, platform: 'website'},\n        {id: 'buyer_representation', label: 'Buyer Representation', description: 'Represents buyers', keywords: [\"buyer agent\", \"buyer representation\", \"helping buyers\", \"buyer services\"], priority: 'MEDIUM', action: 'add-to-segment', scoreBoost: 10, platform: 'website'},\n        {id: 'seller_representation', label: 'Seller Representation', description: 'Represents sellers', keywords: [\"listing agent\", \"seller representation\", \"selling your home\", \"list your property\"], priority: 'MEDIUM', action: 'add-to-segment', scoreBoost: 10, platform: 'website'},\n        {id: 'relocation_specialist', label: 'Relocation Services', description: 'Assists with relocations', keywords: [\"relocation\", \"moving to\", \"relocating\", \"corporate relocation\"], priority: 'LOW', action: 'add-to-segment', scoreBoost: 8, platform: 'website'},\n        {id: 'investment_properties', label: 'Investment Properties', description: 'Specializes in investment real estate', keywords: [\"investment properties\", \"rental properties\", \"fix and flip\", \"investor friendly\"], priority: 'HIGH', action: 'add-to-segment', scoreBoost: 20, platform: 'website'},\n        {id: 'team_size', label: 'Large Team', description: 'Multiple agents on team', keywords: [\"team of\", \"agents\", \"real estate team\"], regexPattern: '(\\\\d+)\\\\s*(agents?|realtors?)', priority: 'MEDIUM', action: 'increase-score', scoreBoost: 15, platform: 'website'},\n        {id: 'areas_served', label: 'Multiple Service Areas', description: 'Serves multiple cities/neighborhoods', keywords: [\"serving\", \"areas served\", \"neighborhoods\", \"communities\"], priority: 'MEDIUM', action: 'increase-score', scoreBoost: 12, platform: 'website'},\n        {id: 'years_experience', label: 'Experience Level', description: 'Years in real estate', keywords: [\"years of experience\", \"since\", \"established\"], regexPattern: '(\\\\d+)\\\\+?\\\\s*years?', priority: 'LOW', action: 'increase-score', scoreBoost: 8, platform: 'website'},\n        {id: 'certifications', label: 'Professional Designations', description: 'Has certifications (CRS, ABR, etc)', keywords: [\"crs\", \"abr\", \"gri\", \"srs\", \"certified\", \"accredited\"], priority: 'LOW', action: 'increase-score', scoreBoost: 5, platform: 'website'},\n        {id: 'sold_count', label: 'Sales Volume', description: 'Number of homes sold', keywords: [\"homes sold\", \"sales\", \"transactions\"], regexPattern: '(\\\\d+)\\\\s*(homes?|properties)\\\\s*sold', priority: 'HIGH', action: 'increase-score', scoreBoost: 20, platform: 'website'},\n        {id: 'mls_access', label: 'MLS Access', description: 'Has MLS search capability', keywords: [\"mls\", \"multiple listing\", \"search homes\", \"property search\"], priority: 'LOW', action: 'increase-score', scoreBoost: 5, platform: 'website'},\n        {id: 'market_reports', label: 'Market Reports', description: 'Provides market analysis', keywords: [\"market report\", \"market analysis\", \"market trends\", \"neighborhood stats\"], priority: 'LOW', action: 'increase-score', scoreBoost: 5, platform: 'website'},\n        {id: 'home_valuation', label: 'Home Valuation Tool', description: 'Offers property valuation', keywords: [\"home value\", \"property valuation\", \"what\\'s my home worth\", \"cma\"], priority: 'LOW', action: 'increase-score', scoreBoost: 5, platform: 'website'}\n      ],\n\n      fluffPatterns: [\n        {id: 'copyright', pattern: '┬⌐\\\\s*\\\\d{4}', description: 'Copyright notices', context: 'footer'},\n        {id: 'all_rights', pattern: 'all rights reserved', description: 'Rights statement', context: 'footer'},\n        {id: 'equal_housing', pattern: 'equal housing opportunity', description: 'Fair housing logo', context: 'footer'},\n        {id: 'realtor_logo', pattern: 'realtor┬«|realtors┬«', description: 'REALTOR trademark', context: 'all'},\n        {id: 'mls_disclaimer', pattern: 'mls.*disclaimer|data.*deemed reliable', description: 'MLS disclaimers', context: 'footer'},\n        {id: 'privacy_policy', pattern: 'privacy policy', description: 'Privacy link', context: 'footer'},\n        {id: 'terms', pattern: 'terms (of use|and conditions)', description: 'Terms link', context: 'footer'},\n        {id: 'cookie_notice', pattern: 'we use cookies', description: 'Cookie banner', context: 'all'},\n        {id: 'social_media', pattern: 'follow (us|me) on', description: 'Social links', context: 'footer'},\n        {id: 'contact_us', pattern: '^contact( us)?$', description: 'Contact link', context: 'header'},\n        {id: 'about_us', pattern: '^about( us| me)?$', description: 'About link', context: 'header'},\n        {id: 'testimonials', pattern: '^testimonials$|^reviews$', description: 'Testimonials link', context: 'header'},\n        {id: 'blog', pattern: '^blog$', description: 'Blog link', context: 'header'},\n        {id: 'search_homes', pattern: '^search homes$|^listings$', description: 'Search link', context: 'header'},\n        {id: 'back_to_top', pattern: 'back to top', description: 'Back to top link', context: 'footer'},\n        {id: 'site_map', pattern: 'site ?map', description: 'Sitemap link', context: 'footer'},\n        {id: 'accessibility', pattern: 'accessibility', description: 'Accessibility link', context: 'footer'},\n        {id: 'dmca', pattern: 'dmca', description: 'DMCA notice', context: 'footer'},\n        {id: 'idx_disclaimer', pattern: 'idx|internet data exchange', description: 'IDX disclaimer', context: 'footer'},\n        {id: 'powered_by', pattern: 'powered by|website by', description: 'Attribution', context: 'footer'}\n      ],\n\n      scoringRules: [\n        {id: 'top_producer_hiring', name: 'Growing Top Team', description: 'Top producer hiring agents', condition: 'signals.some(s => s.signalId === \"top_producer\") && signals.some(s => s.signalId === \"hiring_agents\")', scoreBoost: 25, priority: 1, enabled: true},\n        {id: 'luxury_investment', name: 'Luxury & Investment', description: 'Serves luxury and investment markets', condition: 'signals.some(s => s.signalId === \"luxury_homes\") && signals.some(s => s.signalId === \"investment_properties\")', scoreBoost: 20, priority: 2, enabled: true},\n        {id: 'full_service_agent', name: 'Full Service', description: 'Represents both buyers and sellers', condition: 'signals.some(s => s.signalId === \"buyer_representation\") && signals.some(s => s.signalId === \"seller_representation\")', scoreBoost: 15, priority: 3, enabled: true},\n        {id: 'tech_forward', name: 'Tech-Forward Agent', description: 'Uses virtual tours and modern tools', condition: 'signals.some(s => s.signalId === \"virtual_tours\") && signals.some(s => s.signalId === \"mls_access\")', scoreBoost: 10, priority: 4, enabled: true},\n        {id: 'established_team', name: 'Established Team', description: 'Large team with experience', condition: 'signals.some(s => s.signalId === \"team_size\") && signals.some(s => s.signalId === \"years_experience\")', scoreBoost: 15, priority: 5, enabled: true},\n        {id: 'high_volume', name: 'High Volume Producer', description: 'High sales count with multiple areas', condition: 'signals.some(s => s.signalId === \"sold_count\") && signals.some(s => s.signalId === \"areas_served\")', scoreBoost: 20, priority: 6, enabled: true},\n        {id: 'certified_professional', name: 'Certified Professional', description: 'Has certifications and experience', condition: 'signals.some(s => s.signalId === \"certifications\") && signals.some(s => s.signalId === \"years_experience\")', scoreBoost: 10, priority: 7, enabled: true}\n      ],\n\n      customFields: [\n        {key: 'team_size', label: 'Number of Agents', type: 'number', description: 'Size of agent team', extractionHints: ['agents', 'team of', 'realtors'], required: false, defaultValue: 1},\n        {key: 'areas_served', label: 'Service Areas', type: 'array', description: 'Cities/neighborhoods served', extractionHints: ['serving', 'areas', 'neighborhoods'], required: false, defaultValue: []},\n        {key: 'years_experience', label: 'Years in Business', type: 'number', description: 'Years of experience', extractionHints: ['years', 'since', 'established'], required: false, defaultValue: 0},\n        {key: 'specialization', label: 'Market Specialization', type: 'string', description: 'Luxury, first-time, investment, etc', extractionHints: ['specialize', 'focus', 'expert in'], required: false, defaultValue: 'general'},\n        {key: 'homes_sold_annual', label: 'Annual Sales Volume', type: 'number', description: 'Homes sold per year', extractionHints: ['homes sold', 'transactions', 'sales'], required: false, defaultValue: 0},\n        {key: 'has_virtual_tours', label: 'Offers Virtual Tours', type: 'boolean', description: 'Whether 3D/virtual tours available', extractionHints: ['virtual', '3d tour', 'matterport'], required: false, defaultValue: false},\n        {key: 'certifications', label: 'Professional Certifications', type: 'array', description: 'CRS, ABR, GRI, etc', extractionHints: ['certified', 'designation', 'accredited'], required: false, defaultValue: []},\n        {key: 'buyer_or_seller', label: 'Buyer/Seller Focus', type: 'string', description: 'Buyer, seller, or both', extractionHints: ['buyer agent', 'listing agent', 'both'], required: false, defaultValue: 'both'}\n      ],\n\n      metadata: {\n        lastUpdated: '2025-12-28',\n        version: 1,\n        updatedBy: 'system',\n        notes: 'Residential real estate intelligence - focuses on team growth, sales volume, market specialization, and tech capabilities'\n      }\n    }\n  },\n  \n  'commercial-real-estate': {\n    id: 'commercial-real-estate',\n    name: 'Commercial Property',\n    description: 'For commercial brokers - data-driven investment focus',\n    category: 'Real Estate',\n    \n    coreIdentity: {\n      title: 'The Strategic Asset Advisor',\n      positioning: 'Data-obsessed, efficient, and objective. Minimalist \"no-fluff\" communication',\n      tone: 'Analytical, sophisticated, financial metric vocabulary'\n    },\n    \n    cognitiveLogic: {\n      framework: 'The Yield-First Model',\n      reasoning: 'Logic that filters every query through Cap Rates, Cash-on-Cash Return, and NOI (Net Operating Income)',\n      decisionProcess: 'Financial Metrics ΓåÆ Strategic Fit ΓåÆ Exclusivity Hook'\n    },\n    \n    knowledgeRAG: {\n      static: [\n        'NNN (Triple Net) lease structures',\n        '1031 Exchange rules',\n        'Cap Rate calculations',\n        'NOI formulas',\n        'Zoning classifications',\n        'Commercial lease terms'\n      ],\n      dynamic: [\n        'Current market Cap Rates',\n        'Rent rolls',\n        'Vacancy rates',\n        'Industrial zoning data',\n        'Offering Memorandums (OMs)',\n        'Market absorption rates'\n      ]\n    },\n    \n    learningLoops: {\n      patternRecognition: 'Tracks lead preference for \"Value-Add\" vs. \"Core\" assets based on risk tolerance and investment horizon',\n      adaptation: 'Automatically re-weights the agent\\'s property recommendations based on investor profile (income vs appreciation focus)',\n      feedbackIntegration: 'Learns which financial metrics (Cap Rate, IRR, Cash-on-Cash) resonate most with each investor type'\n    },\n    \n    tacticalExecution: {\n      primaryAction: 'NDA/OM Request',\n      conversionRhythm: 'Focuses on moving the lead to the \"Financial Disclosure\" phase as the primary conversion milestone',\n      secondaryActions: [\n        'Schedule site tour',\n        'Request Offering Memorandum',\n        'Zoning feasibility analysis',\n        '1031 Exchange consultation',\n        'Tenant credit analysis'\n      ]\n    },\n\n    research: {\n      scrapingStrategy: {\n        primarySource: 'website',\n        secondarySources: ['linkedin-company', 'news'],\n        frequency: 'weekly',\n        timeoutMs: 30000,\n        enableCaching: true,\n        cacheTtlSeconds: 600\n      },\n\n      highValueSignals: [\n        {id: 'active_listings', label: 'Active Commercial Listings', description: 'Has available properties', keywords: [\"for sale\", \"for lease\", \"available\", \"listing\", \"commercial property\"], priority: 'HIGH', action: 'increase-score', scoreBoost: 25, platform: 'website'},\n        {id: 'portfolio_size', label: 'Large Portfolio', description: 'Manages many properties', keywords: [\"portfolio\", \"properties managed\", \"square feet\"], regexPattern: '([\\\\d,]+)\\\\s*(sf|square feet|properties)', priority: 'HIGH', action: 'increase-score', scoreBoost: 30, platform: 'website'},\n        {id: 'tenant_representation', label: 'Tenant Rep Services', description: 'Represents tenants', keywords: [\"tenant representation\", \"tenant rep\", \"helping tenants\", \"lease negotiation\"], priority: 'MEDIUM', action: 'add-to-segment', scoreBoost: 15, platform: 'website'},\n        {id: 'landlord_representation', label: 'Landlord Rep', description: 'Represents property owners', keywords: [\"landlord representation\", \"property owner\", \"leasing services\", \"asset management\"], priority: 'MEDIUM', action: 'add-to-segment', scoreBoost: 15, platform: 'website'},\n        {id: 'investment_sales', label: 'Investment Sales', description: 'Specializes in sales transactions', keywords: [\"investment sales\", \"acquisition\", \"disposition\", \"cap rate\", \"roi\"], priority: 'CRITICAL', action: 'increase-score', scoreBoost: 40, platform: 'website'},\n        {id: 'property_types', label: 'Multi-Property Type', description: 'Handles multiple asset classes', keywords: [\"office\", \"retail\", \"industrial\", \"multifamily\", \"mixed-use\"], priority: 'MEDIUM', action: 'increase-score', scoreBoost: 20, platform: 'website'},\n        {id: 'market_reports', label: 'Market Analytics', description: 'Provides market research', keywords: [\"market report\", \"market analysis\", \"trends\", \"vacancy rate\", \"absorption\"], priority: 'MEDIUM', action: 'increase-score', scoreBoost: 12, platform: 'website'},\n        {id: 'site_selection', label: 'Site Selection Services', description: 'Helps with location strategy', keywords: [\"site selection\", \"location strategy\", \"demographics\", \"traffic counts\"], priority: 'MEDIUM', action: 'add-to-segment', scoreBoost: 15, platform: 'website'},\n        {id: '1031_exchange', label: '1031 Exchange Expertise', description: 'Facilitates tax-deferred exchanges', keywords: [\"1031 exchange\", \"tax-deferred\", \"like-kind exchange\"], priority: 'HIGH', action: 'add-to-segment', scoreBoost: 20, platform: 'website'},\n        {id: 'nnn_lease', label: 'Triple Net Lease', description: 'NNN lease specialization', keywords: [\"triple net\", \"nnn lease\", \"net lease\", \"absolute net\"], priority: 'MEDIUM', action: 'add-to-segment', scoreBoost: 15, platform: 'website'},\n        {id: 'build_to_suit', label: 'Build-to-Suit', description: 'Custom construction services', keywords: [\"build to suit\", \"ground lease\", \"development\"], priority: 'HIGH', action: 'add-to-segment', scoreBoost: 18, platform: 'website'},\n        {id: 'property_valuation', label: 'Valuation Services', description: 'Appraisal and valuation', keywords: [\"valuation\", \"appraisal\", \"property value\", \"market value\"], priority: 'LOW', action: 'increase-score', scoreBoost: 8, platform: 'website'},\n        {id: 'hiring', label: 'Hiring Brokers', description: 'Growing team', keywords: [\"hiring\", \"join our team\", \"careers\", \"broker positions\"], priority: 'HIGH', action: 'increase-score', scoreBoost: 25, platform: 'any'},\n        {id: 'awards', label: 'Industry Recognition', description: 'Awards or top broker status', keywords: [\"top broker\", \"award\", \"costar\", \"dealmaker\"], priority: 'MEDIUM', action: 'increase-score', scoreBoost: 15, platform: 'website'},\n        {id: 'recent_transactions', label: 'Recent Deals', description: 'Recently closed transactions', keywords: [\"just sold\", \"recently sold\", \"closed\", \"transaction\"], priority: 'HIGH', action: 'increase-score', scoreBoost: 20, platform: 'website'}\n      ],\n\n      fluffPatterns: [\n        {id: 'copyright', pattern: '┬⌐\\\\s*\\\\d{4}', description: 'Copyright notices', context: 'footer'},\n        {id: 'all_rights', pattern: 'all rights reserved', description: 'Rights statement', context: 'footer'},\n        {id: 'equal_housing', pattern: 'equal (housing|opportunity)', description: 'Fair housing', context: 'footer'},\n        {id: 'privacy', pattern: 'privacy policy', description: 'Privacy link', context: 'footer'},\n        {id: 'terms', pattern: 'terms (of use|and conditions)', description: 'Terms link', context: 'footer'},\n        {id: 'cookie', pattern: 'we use cookies', description: 'Cookie banner', context: 'all'},\n        {id: 'disclaimer', pattern: 'disclaimer|information deemed reliable', description: 'Legal disclaimer', context: 'footer'},\n        {id: 'social', pattern: 'follow (us|me)', description: 'Social links', context: 'footer'},\n        {id: 'contact', pattern: '^contact( us)?$', description: 'Contact link', context: 'header'},\n        {id: 'about', pattern: '^about( us)?$', description: 'About link', context: 'header'},\n        {id: 'services', pattern: '^services$', description: 'Services link', context: 'header'},\n        {id: 'team', pattern: '^(our )?team$', description: 'Team link', context: 'header'},\n        {id: 'listings', pattern: '^listings$|^properties$', description: 'Listings link', context: 'header'},\n        {id: 'back_top', pattern: 'back to top', description: 'Back to top', context: 'footer'},\n        {id: 'sitemap', pattern: 'site ?map', description: 'Sitemap', context: 'footer'},\n        {id: 'accessibility', pattern: 'accessibility', description: 'Accessibility', context: 'footer'},\n        {id: 'powered_by', pattern: 'powered by|website by', description: 'Attribution', context: 'footer'},\n        {id: 'login', pattern: '^(client )?login$', description: 'Login link', context: 'header'},\n        {id: 'search', pattern: '^search$', description: 'Search', context: 'header'},\n        {id: 'news', pattern: '^news$|^blog$', description: 'News/blog link', context: 'header'}\n      ],\n\n      scoringRules: [\n        {id: 'full_service', name: 'Full-Service Firm', description: 'Offers both tenant and landlord rep', condition: 'signals.some(s => s.signalId === \"tenant_representation\") && signals.some(s => s.signalId === \"landlord_representation\")', scoreBoost: 20, priority: 1, enabled: true},\n        {id: 'investment_specialist', name: 'Investment Specialist', description: 'Investment sales with 1031 exchange', condition: 'signals.some(s => s.signalId === \"investment_sales\") && signals.some(s => s.signalId === \"1031_exchange\")', scoreBoost: 25, priority: 2, enabled: true},\n        {id: 'growing_firm', name: 'Growing Firm', description: 'Hiring with recent transactions', condition: 'signals.some(s => s.signalId === \"hiring\") && signals.some(s => s.signalId === \"recent_transactions\")', scoreBoost: 30, priority: 3, enabled: true},\n        {id: 'diversified_portfolio', name: 'Diversified', description: 'Multiple property types', condition: 'signals.some(s => s.signalId === \"property_types\")', scoreBoost: 15, priority: 4, enabled: true},\n        {id: 'development_capable', name: 'Development Services', description: 'Build-to-suit and site selection', condition: 'signals.some(s => s.signalId === \"build_to_suit\") && signals.some(s => s.signalId === \"site_selection\")', scoreBoost: 20, priority: 5, enabled: true},\n        {id: 'market_leader', name: 'Market Leader', description: 'Awards with large portfolio', condition: 'signals.some(s => s.signalId === \"awards\") && signals.some(s => s.signalId === \"portfolio_size\")', scoreBoost: 25, priority: 6, enabled: true},\n        {id: 'data_driven', name: 'Analytics-Focused', description: 'Provides market reports and valuations', condition: 'signals.some(s => s.signalId === \"market_reports\") && signals.some(s => s.signalId === \"property_valuation\")', scoreBoost: 15, priority: 7, enabled: true},\n        {id: 'active_pipeline', name: 'Active Pipeline', description: 'Has listings and recent deals', condition: 'signals.some(s => s.signalId === \"active_listings\") && signals.some(s => s.signalId === \"recent_transactions\")', scoreBoost: 20, priority: 8, enabled: true},\n        {id: 'specialist_knowledge', name: 'NNN Specialist', description: 'NNN lease expert with investment sales', condition: 'signals.some(s => s.signalId === \"nnn_lease\") && signals.some(s => s.signalId === \"investment_sales\")', scoreBoost: 18, priority: 9, enabled: true},\n        {id: 'comprehensive_services', name: 'Comprehensive', description: 'Multiple services offered', condition: 'signals.filter(s => [\"tenant_representation\", \"landlord_representation\", \"investment_sales\", \"site_selection\"].includes(s.signalId)).length >= 3', scoreBoost: 25, priority: 10, enabled: true}\n      ],\n\n      customFields: [\n        {key: 'portfolio_square_feet', label: 'Portfolio Size (SF)', type: 'number', description: 'Total square footage managed', extractionHints: ['square feet', 'sf', 'portfolio'], required: false, defaultValue: 0},\n        {key: 'property_types_served', label: 'Property Types', type: 'array', description: 'Asset classes handled', extractionHints: ['office', 'retail', 'industrial', 'multifamily'], required: false, defaultValue: []},\n        {key: 'service_areas', label: 'Markets Served', type: 'array', description: 'Geographic markets', extractionHints: ['serving', 'markets', 'cities'], required: false, defaultValue: []},\n        {key: 'specialization', label: 'Primary Specialization', type: 'string', description: 'Main service focus', extractionHints: ['specialize', 'focus', 'expert in'], required: false, defaultValue: 'general'},\n        {key: 'broker_count', label: 'Number of Brokers', type: 'number', description: 'Team size', extractionHints: ['brokers', 'team', 'professionals'], required: false, defaultValue: 1},\n        {key: 'has_1031_services', label: 'Offers 1031 Exchange', type: 'boolean', description: 'Whether 1031 exchange available', extractionHints: ['1031', 'exchange', 'tax-deferred'], required: false, defaultValue: false},\n        {key: 'years_in_business', label: 'Years Established', type: 'number', description: 'Years in operation', extractionHints: ['years', 'since', 'established'], required: false, defaultValue: 0},\n        {key: 'avg_transaction_size', label: 'Average Deal Size', type: 'string', description: 'Typical transaction value', extractionHints: ['million', 'average', 'transaction'], required: false, defaultValue: 'unknown'}\n      ],\n\n      metadata: {\n        lastUpdated: '2025-12-29',\n        version: 1,\n        updatedBy: 'system',\n        notes: 'Commercial real estate intelligence - focuses on portfolio size, transaction types, property specialization, and service breadth'\n      }\n    }\n  },\n  \n  'property-management': {\n    id: 'property-management',\n    name: 'Property Management',\n    description: 'For property managers - stress relief and systems focus',\n    category: 'Real Estate',\n    \n    coreIdentity: {\n      title: 'The Shield & Maximizer',\n      positioning: 'Diligent, risk-averse, and highly organized. Framed as a \"fiduciary for your free time\"',\n      tone: 'Protective, systematic, detail-oriented'\n    },\n    \n    cognitiveLogic: {\n      framework: 'The Stress-Relief Framework',\n      reasoning: 'Logic that identifies landlord \"headaches\" (maintenance calls, late rent, tenant turnover) and counters them with \"Systems\"',\n      decisionProcess: 'Pain Point ΓåÆ System Solution ΓåÆ Time Liberation'\n    },\n    \n    knowledgeRAG: {\n      static: [\n        'Fair Housing Act compliance',\n        'Eviction protocols by state',\n        'Landlord-tenant law',\n        'Security deposit regulations',\n        'Lease agreement standards'\n      ],\n      dynamic: [\n        'Management fee structures',\n        'Tenant vetting criteria',\n        'Local vendor lists (plumbers, electricians)',\n        'Rental market rates',\n        'Maintenance request logs',\n        'Tenant payment history'\n      ]\n    },\n    \n    learningLoops: {\n      patternRecognition: 'Flags common tenant complaints (HVAC issues, plumbing) to suggest proactive maintenance schedules',\n      adaptation: 'Alerts owner to preventive maintenance opportunities, reducing long-term churn and emergency costs',\n      feedbackIntegration: 'Tracks seasonal maintenance patterns (e.g., AC failures in summer) and proactively schedules service'\n    },\n    \n    tacticalExecution: {\n      primaryAction: 'Rental Analysis Request',\n      conversionRhythm: 'Offers a free \"Profit Optimization\" report to capture the landlord\\'s contact info and demonstrate value',\n      secondaryActions: [\n        'Property inspection scheduling',\n        'Tenant placement guarantee details',\n        'Maintenance coordination demo',\n        'Rent collection system walkthrough',\n        'Financial reporting sample'\n      ]\n    },\n\n    research: {\n      scrapingStrategy: {\n        primarySource: 'website',\n        secondarySources: ['google-business'],\n        frequency: 'per-lead',\n        timeoutMs: 30000,\n        enableCaching: true,\n        cacheTtlSeconds: 300\n      },\n\n      highValueSignals: [\n        {id: 'units_managed', label: 'Large Portfolio', description: 'High unit count', keywords: [\"units managed\", \"properties managed\", \"doors\"], regexPattern: '([\\\\d,]+)\\\\s*(units?|doors?|properties)', priority: 'CRITICAL', action: 'increase-score', scoreBoost: 35, platform: 'website'},\n        {id: 'hiring', label: 'Hiring Staff', description: 'Growing team', keywords: [\"hiring\", \"join our team\", \"careers\", \"now hiring\"], priority: 'HIGH', action: 'increase-score', scoreBoost: 30, platform: 'any'},\n        {id: 'maintenance_team', label: 'In-House Maintenance', description: 'Own maintenance crew', keywords: [\"maintenance team\", \"in-house maintenance\", \"24/7 maintenance\", \"emergency maintenance\"], priority: 'HIGH', action: 'increase-score', scoreBoost: 25, platform: 'website'},\n        {id: 'tenant_portal', label: 'Online Tenant Portal', description: 'Digital tenant access', keywords: [\"tenant portal\", \"online portal\", \"pay rent online\", \"maintenance request online\"], priority: 'MEDIUM', action: 'increase-score', scoreBoost: 15, platform: 'website'},\n        {id: 'financial_reporting', label: 'Owner Reporting', description: 'Financial reporting system', keywords: [\"owner reporting\", \"financial reports\", \"monthly statements\", \"profit and loss\"], priority: 'MEDIUM', action: 'increase-score', scoreBoost: 12, platform: 'website'},\n        {id: 'tenant_screening', label: 'Tenant Screening', description: 'Background checks', keywords: [\"tenant screening\", \"background check\", \"credit check\", \"tenant vetting\"], priority: 'MEDIUM', action: 'increase-score', scoreBoost: 10, platform: 'website'},\n        {id: 'rent_collection', label: 'Rent Collection', description: 'Collection services', keywords: [\"rent collection\", \"guaranteed rent\", \"rent payment\", \"late fees\"], priority: 'MEDIUM', action: 'increase-score', scoreBoost: 12, platform: 'website'},\n        {id: 'eviction_services', label: 'Eviction Assistance', description: 'Legal eviction support', keywords: [\"eviction\", \"legal services\", \"tenant removal\", \"eviction process\"], priority: 'LOW', action: 'add-to-segment', scoreBoost: 8, platform: 'website'},\n        {id: 'property_types', label: 'Multiple Property Types', description: 'Diverse portfolio', keywords: [\"residential\", \"commercial\", \"multifamily\", \"single family\"], priority: 'MEDIUM', action: 'increase-score', scoreBoost: 15, platform: 'website'},\n        {id: 'leasing_services', label: 'Full Leasing', description: 'Complete leasing service', keywords: [\"leasing\", \"tenant placement\", \"marketing\", \"showings\"], priority: 'MEDIUM', action: 'increase-score', scoreBoost: 12, platform: 'website'},\n        {id: 'hoa_management', label: 'HOA Management', description: 'Homeowner association services', keywords: [\"hoa\", \"homeowner association\", \"condo association\", \"community management\"], priority: 'MEDIUM', action: 'add-to-segment', scoreBoost: 15, platform: 'website'},\n        {id: 'vacancy_guarantee', label: 'Vacancy Guarantee', description: 'Rent guarantee program', keywords: [\"vacancy guarantee\", \"guaranteed rent\", \"rent insurance\"], priority: 'HIGH', action: 'add-to-segment', scoreBoost: 20, platform: 'website'},\n        {id: 'expansion', label: 'Market Expansion', description: 'New markets or locations', keywords: [\"expanding\", \"new office\", \"now serving\", \"new market\"], priority: 'HIGH', action: 'increase-score', scoreBoost: 25, platform: 'any'},\n        {id: 'certifications', label: 'Professional Certifications', description: 'Industry credentials', keywords: [\"cpm\", \"arm\", \"narpm\", \"certified\"], priority: 'LOW', action: 'increase-score', scoreBoost: 8, platform: 'website'},\n        {id: 'software_platform', label: 'PM Software', description: 'Uses modern PM software', keywords: [\"appfolio\", \"buildium\", \"propertyware\", \"rent manager\"], priority: 'MEDIUM', action: 'increase-score', scoreBoost: 10, platform: 'website'}\n      ],\n\n      fluffPatterns: [\n        {id: 'copyright', pattern: '┬⌐\\\\s*\\\\d{4}', description: 'Copyright', context: 'footer'},\n        {id: 'rights', pattern: 'all rights reserved', description: 'Rights', context: 'footer'},\n        {id: 'equal_housing', pattern: 'equal housing', description: 'Fair housing', context: 'footer'},\n        {id: 'privacy', pattern: 'privacy policy', description: 'Privacy', context: 'footer'},\n        {id: 'terms', pattern: 'terms (of|and)', description: 'Terms', context: 'footer'},\n        {id: 'cookies', pattern: 'cookies', description: 'Cookie notice', context: 'all'},\n        {id: 'social', pattern: 'follow us', description: 'Social media', context: 'footer'},\n        {id: 'contact', pattern: '^contact$', description: 'Contact link', context: 'header'},\n        {id: 'about', pattern: '^about$', description: 'About link', context: 'header'},\n        {id: 'services', pattern: '^services$', description: 'Services', context: 'header'},\n        {id: 'properties', pattern: '^properties$', description: 'Properties', context: 'header'},\n        {id: 'owners', pattern: '^owners$', description: 'Owners link', context: 'header'},\n        {id: 'tenants', pattern: '^tenants$', description: 'Tenants link', context: 'header'},\n        {id: 'back_top', pattern: 'back to top', description: 'Back to top', context: 'footer'},\n        {id: 'sitemap', pattern: 'sitemap', description: 'Sitemap', context: 'footer'},\n        {id: 'powered', pattern: 'powered by', description: 'Attribution', context: 'footer'},\n        {id: 'login', pattern: 'login', description: 'Login', context: 'header'},\n        {id: 'portal', pattern: 'portal', description: 'Portal link', context: 'header'},\n        {id: 'careers', pattern: '^careers$', description: 'Careers', context: 'header'},\n        {id: 'blog', pattern: '^blog$', description: 'Blog', context: 'header'}\n      ],\n\n      scoringRules: [\n        {id: 'large_operator', name: 'Large Operator', description: 'High unit count', condition: 'signals.some(s => s.signalId === \"units_managed\")', scoreBoost: 25, priority: 1, enabled: true},\n        {id: 'full_service', name: 'Full Service PM', description: 'Maintenance and tenant portal', condition: 'signals.some(s => s.signalId === \"maintenance_team\") && signals.some(s => s.signalId === \"tenant_portal\")', scoreBoost: 20, priority: 2, enabled: true},\n        {id: 'growing_company', name: 'Growing', description: 'Hiring with expansion', condition: 'signals.some(s => s.signalId === \"hiring\") && signals.some(s => s.signalId === \"expansion\")', scoreBoost: 30, priority: 3, enabled: true},\n        {id: 'tech_enabled', name: 'Technology-Forward', description: 'Portal and PM software', condition: 'signals.some(s => s.signalId === \"tenant_portal\") && signals.some(s => s.signalId === \"software_platform\")', scoreBoost: 15, priority: 4, enabled: true},\n        {id: 'professional', name: 'Professional PM', description: 'Certifications and experience', condition: 'signals.some(s => s.signalId === \"certifications\")', scoreBoost: 10, priority: 5, enabled: true},\n        {id: 'comprehensive', name: 'Comprehensive Services', description: 'Multiple core services', condition: 'signals.filter(s => [\"maintenance_team\", \"tenant_screening\", \"rent_collection\", \"leasing_services\"].includes(s.signalId)).length >= 3', scoreBoost: 20, priority: 6, enabled: true},\n        {id: 'guaranteed_income', name: 'Income Guarantee', description: 'Vacancy guarantee with rent collection', condition: 'signals.some(s => s.signalId === \"vacancy_guarantee\") && signals.some(s => s.signalId === \"rent_collection\")', scoreBoost: 18, priority: 7, enabled: true},\n        {id: 'diversified', name: 'Diversified Portfolio', description: 'Multiple property types', condition: 'signals.some(s => s.signalId === \"property_types\")', scoreBoost: 15, priority: 8, enabled: true},\n        {id: 'hoa_specialist', name: 'HOA Specialist', description: 'HOA management with multiple properties', condition: 'signals.some(s => s.signalId === \"hoa_management\") && signals.some(s => s.signalId === \"units_managed\")', scoreBoost: 20, priority: 9, enabled: true},\n        {id: 'transparent', name: 'Transparent Reporting', description: 'Financial reporting with portal access', condition: 'signals.some(s => s.signalId === \"financial_reporting\") && signals.some(s => s.signalId === \"tenant_portal\")', scoreBoost: 12, priority: 10, enabled: true}\n      ],\n\n      customFields: [\n        {key: 'units_managed', label: 'Units/Doors Managed', type: 'number', description: 'Total units under management', extractionHints: ['units', 'doors', 'properties managed'], required: false, defaultValue: 0},\n        {key: 'property_types', label: 'Property Types', type: 'array', description: 'Types managed', extractionHints: ['residential', 'commercial', 'multifamily'], required: false, defaultValue: []},\n        {key: 'service_areas', label: 'Service Areas', type: 'array', description: 'Geographic coverage', extractionHints: ['serving', 'areas', 'cities'], required: false, defaultValue: []},\n        {key: 'has_maintenance_team', label: 'In-House Maintenance', type: 'boolean', description: 'Own maintenance crew', extractionHints: ['maintenance team', 'in-house'], required: false, defaultValue: false},\n        {key: 'has_tenant_portal', label: 'Online Portal', type: 'boolean', description: 'Digital tenant access', extractionHints: ['portal', 'online'], required: false, defaultValue: false},\n        {key: 'management_fee_percent', label: 'Management Fee %', type: 'string', description: 'Fee structure', extractionHints: ['fee', 'percent', '%'], required: false, defaultValue: 'unknown'},\n        {key: 'specialization', label: 'Specialization', type: 'string', description: 'Primary focus area', extractionHints: ['specialize', 'focus', 'expert'], required: false, defaultValue: 'general'}\n      ],\n\n      metadata: {\n        lastUpdated: '2025-12-29',\n        version: 1,\n        updatedBy: 'system',\n        notes: 'Property management intelligence - focuses on portfolio size, service breadth, technology adoption, and growth indicators'\n      }\n    }\n  },\n  \n  'short-term-rentals': {\n    id: 'short-term-rentals',\n    name: 'Short-Term Rentals (Airbnb/Vacation)',\n    description: 'For STR hosts - revenue optimization and guest experience',\n    category: 'Real Estate',\n    \n    coreIdentity: {\n      title: 'The Revenue & Guest Experience Expert',\n      positioning: 'Upbeat, hospitality-focused, and tech-savvy',\n      tone: 'Enthusiastic, data-driven, service-oriented'\n    },\n    \n    cognitiveLogic: {\n      framework: 'The Algorithmic Edge',\n      reasoning: 'Logic that emphasizes beating the \"average\" host through dynamic pricing, Superhost-level response times, and 5-star reviews',\n      decisionProcess: 'Market Data ΓåÆ Optimization Strategy ΓåÆ Revenue Maximization'\n    },\n    \n    knowledgeRAG: {\n      static: [\n        'OTA (Airbnb/VRBO) best practices',\n        'Superhost requirements',\n        'Short-term rental regulations',\n        'Guest communication templates',\n        'Cleaning protocols'\n      ],\n      dynamic: [\n        'Seasonal occupancy data',\n        'Dynamic pricing algorithms',\n        'Cleaning schedules',\n        'Regional tourism drivers (events, seasons)',\n        'Competitor pricing',\n        'Guest review analytics'\n      ]\n    },\n    \n    learningLoops: {\n      patternRecognition: 'Analyzes guest inquiries to suggest \"Missing Amenities\" (e.g., \"3 people asked if you have a hot tub this week\")',\n      adaptation: 'Recommends pricing adjustments based on local events, seasonality, and booking velocity',\n      feedbackIntegration: 'Tracks which amenities mentioned in reviews correlate with 5-star ratings and premium pricing'\n    },\n    \n    tacticalExecution: {\n      primaryAction: 'Revenue Projection',\n      conversionRhythm: 'Prompts owners to see a \"Potential Earnings\" calendar for their property with seasonal breakdown',\n      secondaryActions: [\n        'Amenity gap analysis',\n        'Superhost roadmap',\n        'Dynamic pricing setup',\n        'Guest automation demo',\n        'Cleaning service recommendations'\n      ]\n    },\n\n    research: {\n      scrapingStrategy: {\n        primarySource: 'website',\n        secondarySources: ['google-business'],\n        frequency: 'per-lead',\n        timeoutMs: 30000,\n        enableCaching: true,\n        cacheTtlSeconds: 300\n      },\n\n      highValueSignals: [\n        {id: 'property_count', label: 'Multiple Properties', description: 'Manages multiple STRs', keywords: [\"properties\", \"listings\", \"portfolio\"], regexPattern: '(\\\\d+)\\\\s*(properties|listings|homes)', priority: 'CRITICAL', action: 'increase-score', scoreBoost: 40, platform: 'website'},\n        {id: 'superhost_status', label: 'Superhost', description: 'Airbnb Superhost status', keywords: [\"superhost\", \"super host\", \"top rated\", \"premier host\"], priority: 'HIGH', action: 'increase-score', scoreBoost: 25, platform: 'website'},\n        {id: 'property_management', label: 'Full-Service Management', description: 'Offers complete STR management', keywords: [\"property management\", \"full service\", \"turnkey\", \"we handle everything\"], priority: 'HIGH', action: 'increase-score', scoreBoost: 30, platform: 'website'},\n        {id: 'dynamic_pricing', label: 'Dynamic Pricing', description: 'Uses algorithmic pricing', keywords: [\"dynamic pricing\", \"revenue management\", \"pricelabs\", \"wheelhouse\", \"beyond pricing\"], priority: 'MEDIUM', action: 'increase-score', scoreBoost: 15, platform: 'website'},\n        {id: 'cleaning_service', label: 'Cleaning Services', description: 'Professional cleaning team', keywords: [\"cleaning\", \"housekeeping\", \"cleaning team\", \"turnover service\"], priority: 'MEDIUM', action: 'increase-score', scoreBoost: 12, platform: 'website'},\n        {id: 'guest_communication', label: 'Guest Communication', description: 'Automated guest messaging', keywords: [\"guest communication\", \"automated messaging\", \"24/7 support\", \"instant response\"], priority: 'MEDIUM', action: 'increase-score', scoreBoost: 12, platform: 'website'},\n        {id: 'amenities_premium', label: 'Premium Amenities', description: 'High-end amenities offered', keywords: [\"hot tub\", \"pool\", \"luxury\", \"premium amenities\", \"high-end\"], priority: 'HIGH', action: 'add-to-segment', scoreBoost: 20, platform: 'website'},\n        {id: 'revenue_guarantee', label: 'Revenue Guarantee', description: 'Guaranteed income program', keywords: [\"revenue guarantee\", \"guaranteed income\", \"minimum revenue\", \"income protection\"], priority: 'CRITICAL', action: 'add-to-segment', scoreBoost: 35, platform: 'website'},\n        {id: 'expansion', label: 'Expanding Portfolio', description: 'Adding new properties', keywords: [\"expanding\", \"new property\", \"adding listings\", \"growing portfolio\"], priority: 'HIGH', action: 'increase-score', scoreBoost: 25, platform: 'any'},\n        {id: 'hiring', label: 'Hiring Staff', description: 'Growing team', keywords: [\"hiring\", \"join our team\", \"now hiring\", \"careers\"], priority: 'HIGH', action: 'increase-score', scoreBoost: 25, platform: 'any'},\n        {id: 'guest_vetting', label: 'Guest Screening', description: 'Screens guests', keywords: [\"guest screening\", \"background check\", \"verified guests\", \"id verification\"], priority: 'LOW', action: 'increase-score', scoreBoost: 8, platform: 'website'},\n        {id: 'maintenance_team', label: 'Maintenance Services', description: 'In-house maintenance', keywords: [\"maintenance\", \"handyman\", \"repairs\", \"maintenance team\"], priority: 'MEDIUM', action: 'increase-score', scoreBoost: 12, platform: 'website'},\n        {id: 'occupancy_rate', label: 'High Occupancy', description: 'Strong booking rate', keywords: [\"occupancy\", \"booked\", \"high demand\"], regexPattern: '(\\\\d+)%\\\\s*occupancy', priority: 'HIGH', action: 'increase-score', scoreBoost: 20, platform: 'website'},\n        {id: 'review_score', label: 'High Review Score', description: 'Excellent guest reviews', keywords: [\"5 star\", \"five star\", \"excellent reviews\", \"top rated\"], regexPattern: '(4\\\\.[89]|5\\\\.0)\\\\s*(stars?|rating)', priority: 'MEDIUM', action: 'increase-score', scoreBoost: 15, platform: 'website'},\n        {id: 'insurance', label: 'STR Insurance', description: 'Specialized insurance', keywords: [\"str insurance\", \"short term rental insurance\", \"vacation rental insurance\", \"liability coverage\"], priority: 'LOW', action: 'increase-score', scoreBoost: 8, platform: 'website'}\n      ],\n\n      fluffPatterns: [\n        {id: 'copyright', pattern: '┬⌐\\\\s*\\\\d{4}', description: 'Copyright', context: 'footer'},\n        {id: 'rights', pattern: 'all rights reserved', description: 'Rights', context: 'footer'},\n        {id: 'privacy', pattern: 'privacy policy', description: 'Privacy', context: 'footer'},\n        {id: 'terms', pattern: 'terms (of|and)', description: 'Terms', context: 'footer'},\n        {id: 'cookies', pattern: 'cookies', description: 'Cookie notice', context: 'all'},\n        {id: 'social', pattern: 'follow us', description: 'Social media', context: 'footer'},\n        {id: 'contact', pattern: '^contact$', description: 'Contact link', context: 'header'},\n        {id: 'about', pattern: '^about$', description: 'About link', context: 'header'},\n        {id: 'properties', pattern: '^properties$|^listings$', description: 'Properties', context: 'header'},\n        {id: 'amenities', pattern: '^amenities$', description: 'Amenities link', context: 'header'},\n        {id: 'booking', pattern: '^book now$', description: 'Booking', context: 'header'},\n        {id: 'back_top', pattern: 'back to top', description: 'Back to top', context: 'footer'},\n        {id: 'sitemap', pattern: 'sitemap', description: 'Sitemap', context: 'footer'},\n        {id: 'powered', pattern: 'powered by', description: 'Attribution', context: 'footer'},\n        {id: 'login', pattern: 'login', description: 'Login', context: 'header'},\n        {id: 'owners', pattern: '^owners$', description: 'Owners link', context: 'header'},\n        {id: 'guests', pattern: '^guests$', description: 'Guests link', context: 'header'},\n        {id: 'reviews', pattern: '^reviews$', description: 'Reviews link', context: 'header'},\n        {id: 'blog', pattern: '^blog$', description: 'Blog', context: 'header'},\n        {id: 'faq', pattern: '^faq$', description: 'FAQ', context: 'header'}\n      ],\n\n      scoringRules: [\n        {id: 'large_operator', name: 'Large Portfolio', description: 'Multiple properties with high occupancy', condition: 'signals.some(s => s.signalId === \"property_count\") && signals.some(s => s.signalId === \"occupancy_rate\")', scoreBoost: 30, priority: 1, enabled: true},\n        {id: 'professional_host', name: 'Professional Host', description: 'Superhost with premium amenities', condition: 'signals.some(s => s.signalId === \"superhost_status\") && signals.some(s => s.signalId === \"amenities_premium\")', scoreBoost: 25, priority: 2, enabled: true},\n        {id: 'full_service', name: 'Full-Service Provider', description: 'Complete management services', condition: 'signals.some(s => s.signalId === \"property_management\") && signals.some(s => s.signalId === \"cleaning_service\")', scoreBoost: 20, priority: 3, enabled: true},\n        {id: 'tech_enabled', name: 'Technology-Forward', description: 'Dynamic pricing and automation', condition: 'signals.some(s => s.signalId === \"dynamic_pricing\") && signals.some(s => s.signalId === \"guest_communication\")', scoreBoost: 18, priority: 4, enabled: true},\n        {id: 'growing_business', name: 'Growing Business', description: 'Expanding with hiring', condition: 'signals.some(s => s.signalId === \"expansion\") && signals.some(s => s.signalId === \"hiring\")', scoreBoost: 30, priority: 5, enabled: true},\n        {id: 'premium_service', name: 'Premium Operator', description: 'Revenue guarantee with high reviews', condition: 'signals.some(s => s.signalId === \"revenue_guarantee\") && signals.some(s => s.signalId === \"review_score\")', scoreBoost: 35, priority: 6, enabled: true},\n        {id: 'comprehensive', name: 'Comprehensive Services', description: 'Multiple service offerings', condition: 'signals.filter(s => [\"cleaning_service\", \"maintenance_team\", \"guest_communication\", \"guest_vetting\"].includes(s.signalId)).length >= 3', scoreBoost: 22, priority: 7, enabled: true},\n        {id: 'quality_focused', name: 'Quality-Focused', description: 'High reviews with vetting', condition: 'signals.some(s => s.signalId === \"review_score\") && signals.some(s => s.signalId === \"guest_vetting\")', scoreBoost: 15, priority: 8, enabled: true},\n        {id: 'insured_professional', name: 'Insured Professional', description: 'Insurance with property management', condition: 'signals.some(s => s.signalId === \"insurance\") && signals.some(s => s.signalId === \"property_management\")', scoreBoost: 12, priority: 9, enabled: true},\n        {id: 'established_host', name: 'Established Host', description: 'Superhost with multiple properties', condition: 'signals.some(s => s.signalId === \"superhost_status\") && signals.some(s => s.signalId === \"property_count\")', scoreBoost: 28, priority: 10, enabled: true}\n      ],\n\n      customFields: [\n        {key: 'property_count', label: 'Number of Properties', type: 'number', description: 'STR properties managed', extractionHints: ['properties', 'listings', 'portfolio'], required: false, defaultValue: 1},\n        {key: 'avg_nightly_rate', label: 'Average Nightly Rate', type: 'string', description: 'Typical rate per night', extractionHints: ['per night', 'nightly', 'rate'], required: false, defaultValue: 'unknown'},\n        {key: 'occupancy_rate', label: 'Occupancy Rate %', type: 'number', description: 'Booking percentage', extractionHints: ['occupancy', 'booked'], required: false, defaultValue: 0},\n        {key: 'is_superhost', label: 'Superhost Status', type: 'boolean', description: 'Airbnb Superhost', extractionHints: ['superhost'], required: false, defaultValue: false},\n        {key: 'has_dynamic_pricing', label: 'Uses Dynamic Pricing', type: 'boolean', description: 'Algorithmic pricing', extractionHints: ['dynamic pricing', 'revenue management'], required: false, defaultValue: false},\n        {key: 'service_areas', label: 'Service Areas', type: 'array', description: 'Geographic coverage', extractionHints: ['serving', 'locations', 'cities'], required: false, defaultValue: []},\n        {key: 'specialization', label: 'Property Type Focus', type: 'string', description: 'Primary property type', extractionHints: ['specialize', 'focus', 'luxury', 'beach'], required: false, defaultValue: 'general'}\n      ],\n\n      metadata: {\n        lastUpdated: '2025-12-29',\n        version: 1,\n        updatedBy: 'system',\n        notes: 'Short-term rental intelligence - focuses on portfolio size, revenue optimization, guest experience, and professional management services'\n      }\n    }\n  },\n  \n  'mortgage-lending': {\n    id: 'mortgage-lending',\n    name: 'Mortgage & Lending',\n    description: 'For mortgage brokers - compliant and advisory focused',\n    category: 'Real Estate',\n    \n    coreIdentity: {\n      title: 'The Financial Architect',\n      positioning: 'Precise, reassuring, and highly compliant. Avoids \"salesy\" pressure in favor of \"advisory\" clarity',\n      tone: 'Professional, educational, trustworthy'\n    },\n    \n    cognitiveLogic: {\n      framework: 'Scenario-Based Comparison',\n      reasoning: 'Logic that avoids quoting one rate and instead compares the total \"Cost of Capital\" over 5, 10, and 30 years across different loan products',\n      decisionProcess: 'Financial Situation ΓåÆ Loan Product Comparison ΓåÆ Total Cost Analysis'\n    },\n    \n    knowledgeRAG: {\n      static: [\n        'FHA/VA/Conventional guidelines',\n        'DTI (Debt-to-Income) calculations',\n        'Loan-to-Value (LTV) ratios',\n        'TRID compliance',\n        'Credit score requirements',\n        'Private Mortgage Insurance (PMI) rules'\n      ],\n      dynamic: [\n        'Daily rate sheets',\n        'Lender overlays',\n        'State-specific licensing requirements',\n        'Points vs. rate trade-offs',\n        'Lock period options',\n        'Real-time rate updates'\n      ]\n    },\n    \n    learningLoops: {\n      patternRecognition: 'Detects when leads are \"Rate Shopping\" and triggers the \"Total Cost Analysis\" logic to compete on service and certainty rather than just 0.1% rate difference',\n      adaptation: 'Shifts from rate-focused to value-focused conversation (faster closing, better service, refinance strategy)',\n      feedbackIntegration: 'Learns which loan features (low down payment, no PMI, rate locks) matter most to different borrower segments'\n    },\n    \n    tacticalExecution: {\n      primaryAction: 'Soft Pull/Pre-Application',\n      conversionRhythm: 'Directs users to a secure portal for a \"5-minute pre-qualification\" to capture verified contact info and financial snapshot',\n      secondaryActions: [\n        'Total cost comparison calculator',\n        'Pre-approval letter request',\n        'Refinance analysis',\n        'Debt consolidation review',\n        'First-time buyer education'\n      ]\n    },\n\n    research: {\n      scrapingStrategy: {\n        primarySource: 'website',\n        secondarySources: ['linkedin-company'],\n        frequency: 'per-lead',\n        timeoutMs: 30000,\n        enableCaching: true,\n        cacheTtlSeconds: 300\n      },\n\n      highValueSignals: [\n        {id: 'loan_officers', label: 'Multiple Loan Officers', description: 'Large team of LOs', keywords: [\"loan officers\", \"mortgage team\", \"lending team\"], regexPattern: '(\\\\d+)\\\\s*(loan officers?|los?)', priority: 'HIGH', action: 'increase-score', scoreBoost: 30, platform: 'website'},\n        {id: 'hiring', label: 'Hiring Loan Officers', description: 'Growing team', keywords: [\"hiring\", \"join our team\", \"loan officer careers\", \"now hiring\"], priority: 'HIGH', action: 'increase-score', scoreBoost: 30, platform: 'any'},\n        {id: 'loan_types', label: 'Multiple Loan Products', description: 'Diverse loan offerings', keywords: [\"conventional\", \"fha\", \"va\", \"jumbo\", \"usda\", \"renovation\"], priority: 'MEDIUM', action: 'increase-score', scoreBoost: 15, platform: 'website'},\n        {id: 'rate_guarantee', label: 'Rate Lock Guarantee', description: 'Extended rate lock', keywords: [\"rate lock\", \"lock guarantee\", \"rate protection\", \"extended lock\"], priority: 'HIGH', action: 'add-to-segment', scoreBoost: 20, platform: 'website'},\n        {id: 'same_day_preapproval', label: 'Fast Pre-Approval', description: 'Quick pre-approval process', keywords: [\"same day\", \"fast approval\", \"quick preapproval\", \"instant approval\"], priority: 'MEDIUM', action: 'increase-score', scoreBoost: 15, platform: 'website'},\n        {id: 'low_down_payment', label: 'Low Down Payment Options', description: 'Minimal down payment programs', keywords: [\"low down\", \"3% down\", \"zero down\", \"no money down\"], priority: 'MEDIUM', action: 'add-to-segment', scoreBoost: 12, platform: 'website'},\n        {id: 'refinance_specialist', label: 'Refinance Specialist', description: 'Strong refinance focus', keywords: [\"refinance\", \"refi\", \"cash out\", \"lower your rate\"], priority: 'MEDIUM', action: 'add-to-segment', scoreBoost: 15, platform: 'website'},\n        {id: 'first_time_buyer', label: 'First-Time Buyer Programs', description: 'Specializes in first-time buyers', keywords: [\"first time buyer\", \"first time home\", \"fthb\", \"homebuyer education\"], priority: 'MEDIUM', action: 'add-to-segment', scoreBoost: 12, platform: 'website'},\n        {id: 'digital_application', label: 'Online Application', description: 'Digital mortgage process', keywords: [\"online application\", \"digital mortgage\", \"apply online\", \"paperless\"], priority: 'LOW', action: 'increase-score', scoreBoost: 10, platform: 'website'},\n        {id: 'lender_licenses', label: 'Multi-State Licensing', description: 'Licensed in multiple states', keywords: [\"licensed in\", \"serving\", \"states\"], regexPattern: 'licensed? in (\\\\d+) states?', priority: 'HIGH', action: 'increase-score', scoreBoost: 25, platform: 'website'},\n        {id: 'awards', label: 'Industry Recognition', description: 'Awards or recognition', keywords: [\"top lender\", \"award\", \"scotsman guide\", \"mortgage professional\"], priority: 'MEDIUM', action: 'increase-score', scoreBoost: 15, platform: 'website'},\n        {id: 'closing_time', label: 'Fast Closing', description: 'Quick close guarantee', keywords: [\"fast close\", \"quick close\", \"15 day\", \"21 day close\"], regexPattern: '(\\\\d+)\\\\s*day close', priority: 'HIGH', action: 'increase-score', scoreBoost: 20, platform: 'website'},\n        {id: 'jumbo_loans', label: 'Jumbo Loan Specialist', description: 'High-value mortgages', keywords: [\"jumbo\", \"high balance\", \"luxury homes\", \"million dollar\"], priority: 'HIGH', action: 'add-to-segment', scoreBoost: 22, platform: 'website'},\n        {id: 'reverse_mortgage', label: 'Reverse Mortgage', description: 'HECM services', keywords: [\"reverse mortgage\", \"hecm\", \"home equity conversion\"], priority: 'MEDIUM', action: 'add-to-segment', scoreBoost: 15, platform: 'website'},\n        {id: 'construction_loans', label: 'Construction Lending', description: 'Construction-to-perm loans', keywords: [\"construction loan\", \"build your own\", \"construction to permanent\"], priority: 'MEDIUM', action: 'add-to-segment', scoreBoost: 15, platform: 'website'}\n      ],\n\n      fluffPatterns: [\n        {id: 'copyright', pattern: '┬⌐\\\\s*\\\\d{4}', description: 'Copyright', context: 'footer'},\n        {id: 'rights', pattern: 'all rights reserved', description: 'Rights', context: 'footer'},\n        {id: 'equal_housing', pattern: 'equal housing', description: 'Equal housing', context: 'footer'},\n        {id: 'nmls', pattern: 'nmls #?\\\\d+', description: 'NMLS number', context: 'footer'},\n        {id: 'privacy', pattern: 'privacy policy', description: 'Privacy', context: 'footer'},\n        {id: 'terms', pattern: 'terms (of|and)', description: 'Terms', context: 'footer'},\n        {id: 'cookies', pattern: 'cookies', description: 'Cookie notice', context: 'all'},\n        {id: 'disclaimer', pattern: 'licensed mortgage|rates subject to change', description: 'Disclaimers', context: 'footer'},\n        {id: 'social', pattern: 'follow us', description: 'Social media', context: 'footer'},\n        {id: 'contact', pattern: '^contact$', description: 'Contact link', context: 'header'},\n        {id: 'about', pattern: '^about$', description: 'About link', context: 'header'},\n        {id: 'rates', pattern: '^rates$', description: 'Rates link', context: 'header'},\n        {id: 'apply', pattern: '^apply( now)?$', description: 'Apply link', context: 'header'},\n        {id: 'calculator', pattern: '^calculators?$', description: 'Calculator', context: 'header'},\n        {id: 'back_top', pattern: 'back to top', description: 'Back to top', context: 'footer'},\n        {id: 'sitemap', pattern: 'sitemap', description: 'Sitemap', context: 'footer'},\n        {id: 'powered', pattern: 'powered by', description: 'Attribution', context: 'footer'},\n        {id: 'login', pattern: 'login', description: 'Login', context: 'header'},\n        {id: 'resources', pattern: '^resources$', description: 'Resources', context: 'header'},\n        {id: 'blog', pattern: '^blog$', description: 'Blog', context: 'header'}\n      ],\n\n      scoringRules: [\n        {id: 'large_team', name: 'Large Operation', description: 'Multiple loan officers', condition: 'signals.some(s => s.signalId === \"loan_officers\")', scoreBoost: 25, priority: 1, enabled: true},\n        {id: 'growing_company', name: 'Growing Company', description: 'Hiring with multi-state licensing', condition: 'signals.some(s => s.signalId === \"hiring\") && signals.some(s => s.signalId === \"lender_licenses\")', scoreBoost: 30, priority: 2, enabled: true},\n        {id: 'competitive_edge', name: 'Competitive Advantage', description: 'Fast closing with rate guarantee', condition: 'signals.some(s => s.signalId === \"closing_time\") && signals.some(s => s.signalId === \"rate_guarantee\")', scoreBoost: 25, priority: 3, enabled: true},\n        {id: 'tech_forward', name: 'Technology-Forward', description: 'Digital application with fast approval', condition: 'signals.some(s => s.signalId === \"digital_application\") && signals.some(s => s.signalId === \"same_day_preapproval\")', scoreBoost: 18, priority: 4, enabled: true},\n        {id: 'diverse_products', name: 'Diverse Product Mix', description: 'Multiple specialized loan types', condition: 'signals.filter(s => [\"jumbo_loans\", \"reverse_mortgage\", \"construction_loans\", \"refinance_specialist\"].includes(s.signalId)).length >= 2', scoreBoost: 20, priority: 5, enabled: true},\n        {id: 'first_timer_focus', name: 'First-Time Buyer Specialist', description: 'FTHB programs with low down', condition: 'signals.some(s => s.signalId === \"first_time_buyer\") && signals.some(s => s.signalId === \"low_down_payment\")', scoreBoost: 15, priority: 6, enabled: true},\n        {id: 'luxury_specialist', name: 'Luxury Market', description: 'Jumbo loans with fast closing', condition: 'signals.some(s => s.signalId === \"jumbo_loans\") && signals.some(s => s.signalId === \"closing_time\")', scoreBoost: 22, priority: 7, enabled: true},\n        {id: 'recognized_leader', name: 'Industry Leader', description: 'Awards with multi-state presence', condition: 'signals.some(s => s.signalId === \"awards\") && signals.some(s => s.signalId === \"lender_licenses\")', scoreBoost: 25, priority: 8, enabled: true},\n        {id: 'comprehensive_services', name: 'Full-Service Lender', description: 'Multiple loan products with digital tools', condition: 'signals.some(s => s.signalId === \"loan_types\") && signals.some(s => s.signalId === \"digital_application\")', scoreBoost: 18, priority: 9, enabled: true},\n        {id: 'speed_leader', name: 'Speed Leader', description: 'Fast approval and closing', condition: 'signals.some(s => s.signalId === \"same_day_preapproval\") && signals.some(s => s.signalId === \"closing_time\")', scoreBoost: 20, priority: 10, enabled: true}\n      ],\n\n      customFields: [\n        {key: 'loan_officer_count', label: 'Number of Loan Officers', type: 'number', description: 'Team size', extractionHints: ['loan officers', 'team', 'los'], required: false, defaultValue: 1},\n        {key: 'states_licensed', label: 'States Licensed', type: 'number', description: 'Multi-state reach', extractionHints: ['states', 'licensed in'], required: false, defaultValue: 1},\n        {key: 'loan_products', label: 'Loan Products Offered', type: 'array', description: 'Types of loans', extractionHints: ['conventional', 'fha', 'va', 'jumbo'], required: false, defaultValue: []},\n        {key: 'avg_closing_days', label: 'Average Closing Time (Days)', type: 'number', description: 'Typical closing period', extractionHints: ['day close', 'closing time'], required: false, defaultValue: 30},\n        {key: 'has_digital_app', label: 'Digital Application', type: 'boolean', description: 'Online application available', extractionHints: ['online', 'digital', 'apply online'], required: false, defaultValue: false},\n        {key: 'specialization', label: 'Market Specialization', type: 'string', description: 'Primary focus area', extractionHints: ['specialize', 'focus', 'expert'], required: false, defaultValue: 'general'},\n        {key: 'min_credit_score', label: 'Minimum Credit Score', type: 'number', description: 'Lowest score accepted', extractionHints: ['credit score', 'minimum', 'as low as'], required: false, defaultValue: 620}\n      ],\n\n      metadata: {\n        lastUpdated: '2025-12-29',\n        version: 1,\n        updatedBy: 'system',\n        notes: 'Mortgage lending intelligence - focuses on team size, loan product diversity, processing speed, and multi-state capabilities'\n      }\n    }\n  },\n  \n  'home-staging': {\n    id: 'home-staging',\n    name: 'Home Staging',\n    description: 'For stagers - visual marketing and ROI focus',\n    category: 'Real Estate',\n    \n    coreIdentity: {\n      title: 'High-End Visual Marketer & Spatial Strategist',\n      positioning: 'Sophisticated, artistic, and ROI-focused',\n      tone: 'Elegant, professional, results-driven'\n    },\n    \n    cognitiveLogic: {\n      framework: 'The Emotional Connection Framework',\n      reasoning: 'Logic that shifts the conversation from \"furniture rental\" to \"buyer psychology\" and \"equity maximization\"',\n      decisionProcess: 'Visual Impact ΓåÆ Buyer Psychology ΓåÆ ROI Justification'\n    },\n    \n    knowledgeRAG: {\n      static: [\n        'Design styles (Modern, Transitional, Contemporary)',\n        'Inventory logistics',\n        'Color psychology',\n        'Space optimization principles',\n        'Photography best practices'\n      ],\n      dynamic: [\n        'Client\\'s property portfolio',\n        '\"Before & After\" statistics',\n        'Package pricing tiers',\n        'Inventory availability',\n        'ROI data by property type',\n        'Market-specific styling trends'\n      ]\n    },\n    \n    learningLoops: {\n      patternRecognition: 'Tracks which room types (e.g., \"Empty Living Room,\" \"Dated Kitchen\") cause the most lead hesitation',\n      adaptation: 'Prompts the client to create a specific case study for problematic room types to overcome objections',\n      feedbackIntegration: 'Correlates staging investments with days-on-market reduction and sale price increases'\n    },\n    \n    tacticalExecution: {\n      primaryAction: 'Photo Quote Request',\n      conversionRhythm: 'Every conversation aims to get the lead to upload property photos for a \"Staging Impact Estimate\"',\n      secondaryActions: [\n        'Before & After portfolio review',\n        'ROI calculator (sale price increase vs staging cost)',\n        'Virtual staging preview',\n        'Package comparison guide',\n        'Consultation scheduling'\n      ]\n    },\n\n    research: {\n      scrapingStrategy: {\n        primarySource: 'website',\n        secondarySources: ['google-business'],\n        frequency: 'per-lead',\n        timeoutMs: 30000,\n        enableCaching: true,\n        cacheTtlSeconds: 300\n      },\n\n      highValueSignals: [\n        {id: 'portfolio_size', label: 'Large Inventory', description: 'Extensive furniture inventory', keywords: [\"inventory\", \"furniture collection\", \"pieces\", \"warehouse\"], regexPattern: '(\\\\d{3,})\\\\+?\\\\s*pieces?', priority: 'HIGH', action: 'increase-score', scoreBoost: 25, platform: 'website'},\n        {id: 'before_after', label: 'Before & After Portfolio', description: 'Shows transformation results', keywords: [\"before and after\", \"before & after\", \"transformations\", \"results\"], priority: 'CRITICAL', action: 'increase-score', scoreBoost: 35, platform: 'website'},\n        {id: 'virtual_staging', label: 'Virtual Staging', description: 'Offers digital staging', keywords: [\"virtual staging\", \"digital staging\", \"3d staging\", \"photo staging\"], priority: 'HIGH', action: 'add-to-segment', scoreBoost: 20, platform: 'website'},\n        {id: 'occupied_staging', label: 'Occupied Home Staging', description: 'Stages occupied properties', keywords: [\"occupied\", \"lived-in\", \"consultation\", \"redesign\"], priority: 'MEDIUM', action: 'add-to-segment', scoreBoost: 15, platform: 'website'},\n        {id: 'vacant_staging', label: 'Vacant Staging', description: 'Full vacant home staging', keywords: [\"vacant\", \"full staging\", \"empty home\", \"turnkey\"], priority: 'MEDIUM', action: 'add-to-segment', scoreBoost: 15, platform: 'website'},\n        {id: 'luxury_staging', label: 'Luxury Staging', description: 'High-end property focus', keywords: [\"luxury\", \"high-end\", \"upscale\", \"premium\", \"million dollar\"], priority: 'HIGH', action: 'add-to-segment', scoreBoost: 25, platform: 'website'},\n        {id: 'roi_stats', label: 'ROI Statistics', description: 'Provides staging ROI data', keywords: [\"roi\", \"return on investment\", \"increased sale price\", \"faster sale\"], regexPattern: '(\\\\d+)%\\\\s*(increase|faster|higher)', priority: 'CRITICAL', action: 'increase-score', scoreBoost: 30, platform: 'website'},\n        {id: 'awards', label: 'Industry Awards', description: 'Recognition or certifications', keywords: [\"award\", \"certified\", \"accredited\", \"resa\", \"staging association\"], priority: 'MEDIUM', action: 'increase-score', scoreBoost: 18, platform: 'website'},\n        {id: 'hiring', label: 'Hiring Stagers', description: 'Growing team', keywords: [\"hiring\", \"join our team\", \"careers\", \"stager positions\"], priority: 'HIGH', action: 'increase-score', scoreBoost: 25, platform: 'any'},\n        {id: 'expansion', label: 'Market Expansion', description: 'New locations or markets', keywords: [\"expanding\", \"new office\", \"now serving\", \"new market\"], priority: 'HIGH', action: 'increase-score', scoreBoost: 20, platform: 'any'},\n        {id: 'property_types', label: 'Multiple Property Types', description: 'Diverse staging experience', keywords: [\"residential\", \"commercial\", \"apartments\", \"condos\", \"townhomes\"], priority: 'MEDIUM', action: 'increase-score', scoreBoost: 12, platform: 'website'},\n        {id: 'consultation_free', label: 'Free Consultation', description: 'Complimentary assessment', keywords: [\"free consultation\", \"complimentary\", \"no obligation\"], priority: 'LOW', action: 'increase-score', scoreBoost: 8, platform: 'website'},\n        {id: 'package_deals', label: 'Staging Packages', description: 'Tiered pricing options', keywords: [\"packages\", \"package pricing\", \"bronze silver gold\", \"tiers\"], priority: 'MEDIUM', action: 'increase-score', scoreBoost: 10, platform: 'website'},\n        {id: 'quick_turnaround', label: 'Fast Installation', description: 'Quick staging setup', keywords: [\"24 hour\", \"48 hour\", \"quick install\", \"fast turnaround\"], regexPattern: '(\\\\d+)\\\\s*(hour|day)\\\\s*install', priority: 'MEDIUM', action: 'increase-score', scoreBoost: 15, platform: 'website'},\n        {id: 'partnerships', label: 'Agent Partnerships', description: 'Works with real estate agents', keywords: [\"agent partnership\", \"realtor network\", \"agent discount\", \"preferred stager\"], priority: 'LOW', action: 'increase-score', scoreBoost: 10, platform: 'website'}\n      ],\n\n      fluffPatterns: [\n        {id: 'copyright', pattern: '┬⌐\\\\s*\\\\d{4}', description: 'Copyright', context: 'footer'},\n        {id: 'rights', pattern: 'all rights reserved', description: 'Rights', context: 'footer'},\n        {id: 'privacy', pattern: 'privacy policy', description: 'Privacy', context: 'footer'},\n        {id: 'terms', pattern: 'terms (of|and)', description: 'Terms', context: 'footer'},\n        {id: 'cookies', pattern: 'cookies', description: 'Cookie notice', context: 'all'},\n        {id: 'social', pattern: 'follow us', description: 'Social media', context: 'footer'},\n        {id: 'contact', pattern: '^contact$', description: 'Contact link', context: 'header'},\n        {id: 'about', pattern: '^about$', description: 'About link', context: 'header'},\n        {id: 'portfolio', pattern: '^portfolio$', description: 'Portfolio link', context: 'header'},\n        {id: 'services', pattern: '^services$', description: 'Services', context: 'header'},\n        {id: 'gallery', pattern: '^gallery$', description: 'Gallery link', context: 'header'},\n        {id: 'back_top', pattern: 'back to top', description: 'Back to top', context: 'footer'},\n        {id: 'sitemap', pattern: 'sitemap', description: 'Sitemap', context: 'footer'},\n        {id: 'powered', pattern: 'powered by', description: 'Attribution', context: 'footer'},\n        {id: 'consultation', pattern: '^consultation$', description: 'Consult link', context: 'header'},\n        {id: 'blog', pattern: '^blog$', description: 'Blog', context: 'header'},\n        {id: 'testimonials', pattern: '^testimonials$', description: 'Testimonials', context: 'header'},\n        {id: 'faq', pattern: '^faq$', description: 'FAQ', context: 'header'},\n        {id: 'pricing', pattern: '^pricing$', description: 'Pricing link', context: 'header'},\n        {id: 'process', pattern: '^(our )?process$', description: 'Process link', context: 'header'}\n      ],\n\n      scoringRules: [\n        {id: 'proven_results', name: 'Proven Results', description: 'Before/after with ROI stats', condition: 'signals.some(s => s.signalId === \"before_after\") && signals.some(s => s.signalId === \"roi_stats\")', scoreBoost: 35, priority: 1, enabled: true},\n        {id: 'full_service', name: 'Full-Service Provider', description: 'Virtual and physical staging', condition: 'signals.some(s => s.signalId === \"virtual_staging\") && (signals.some(s => s.signalId === \"vacant_staging\") || signals.some(s => s.signalId === \"occupied_staging\"))', scoreBoost: 25, priority: 2, enabled: true},\n        {id: 'luxury_specialist', name: 'Luxury Specialist', description: 'High-end with large inventory', condition: 'signals.some(s => s.signalId === \"luxury_staging\") && signals.some(s => s.signalId === \"portfolio_size\")', scoreBoost: 28, priority: 3, enabled: true},\n        {id: 'growing_business', name: 'Growing Business', description: 'Hiring with expansion', condition: 'signals.some(s => s.signalId === \"hiring\") && signals.some(s => s.signalId === \"expansion\")', scoreBoost: 25, priority: 4, enabled: true},\n        {id: 'professional', name: 'Professional Operation', description: 'Awards with proven ROI', condition: 'signals.some(s => s.signalId === \"awards\") && signals.some(s => s.signalId === \"roi_stats\")', scoreBoost: 22, priority: 5, enabled: true},\n        {id: 'versatile', name: 'Versatile Provider', description: 'Multiple property types and staging methods', condition: 'signals.some(s => s.signalId === \"property_types\") && signals.filter(s => [\"vacant_staging\", \"occupied_staging\"].includes(s.signalId)).length >= 2', scoreBoost: 18, priority: 6, enabled: true},\n        {id: 'speed_service', name: 'Fast Service', description: 'Quick turnaround with packages', condition: 'signals.some(s => s.signalId === \"quick_turnaround\") && signals.some(s => s.signalId === \"package_deals\")', scoreBoost: 15, priority: 7, enabled: true},\n        {id: 'agent_friendly', name: 'Agent-Friendly', description: 'Partnerships with free consultation', condition: 'signals.some(s => s.signalId === \"partnerships\") && signals.some(s => s.signalId === \"consultation_free\")', scoreBoost: 12, priority: 8, enabled: true},\n        {id: 'comprehensive', name: 'Comprehensive Portfolio', description: 'Large inventory with quick install', condition: 'signals.some(s => s.signalId === \"portfolio_size\") && signals.some(s => s.signalId === \"quick_turnaround\")', scoreBoost: 20, priority: 9, enabled: true},\n        {id: 'modern_approach', name: 'Modern Approach', description: 'Virtual staging with proven results', condition: 'signals.some(s => s.signalId === \"virtual_staging\") && signals.some(s => s.signalId === \"before_after\")', scoreBoost: 18, priority: 10, enabled: true}\n      ],\n\n      customFields: [\n        {key: 'inventory_count', label: 'Inventory Pieces', type: 'number', description: 'Total furniture pieces', extractionHints: ['pieces', 'inventory', 'furniture'], required: false, defaultValue: 0},\n        {key: 'avg_roi_percent', label: 'Average ROI %', type: 'number', description: 'Typical return on investment', extractionHints: ['roi', 'increase', 'return'], required: false, defaultValue: 0},\n        {key: 'service_types', label: 'Staging Services', type: 'array', description: 'Types of staging offered', extractionHints: ['vacant', 'occupied', 'virtual'], required: false, defaultValue: []},\n        {key: 'specialization', label: 'Market Specialization', type: 'string', description: 'Primary focus area', extractionHints: ['luxury', 'residential', 'commercial'], required: false, defaultValue: 'residential'},\n        {key: 'has_virtual_staging', label: 'Offers Virtual Staging', type: 'boolean', description: 'Digital staging available', extractionHints: ['virtual', 'digital'], required: false, defaultValue: false},\n        {key: 'service_areas', label: 'Service Areas', type: 'array', description: 'Geographic coverage', extractionHints: ['serving', 'areas', 'cities'], required: false, defaultValue: []},\n        {key: 'install_time_hours', label: 'Typical Install Time (Hours)', type: 'number', description: 'Average setup time', extractionHints: ['hour', 'install', 'setup'], required: false, defaultValue: 48}\n      ],\n\n      metadata: {\n        lastUpdated: '2025-12-29',\n        version: 1,\n        updatedBy: 'system',\n        notes: 'Home staging intelligence - focuses on portfolio size, ROI demonstration, service diversity, and luxury market capabilities'\n      }\n    }\n  },\n  \n  'interior-design': {\n    id: 'interior-design',\n    name: 'Interior Design',\n    description: 'For designers - aesthetic and functional consultation',\n    category: 'Real Estate',\n    \n    coreIdentity: {\n      title: 'The Visionary Consultant',\n      positioning: 'Elegant, detailed, authoritative, and creative',\n      tone: 'Sophisticated, collaborative, inspirational'\n    },\n    \n    cognitiveLogic: {\n      framework: 'The Lifestyle Discovery Model',\n      reasoning: 'Logic that uses \"Diagnostic Questions\" to uncover a client\\'s aesthetic and functional needs before suggesting a style',\n      decisionProcess: 'Discovery ΓåÆ Vision Alignment ΓåÆ Curated Solutions'\n    },\n    \n    knowledgeRAG: {\n      static: [\n        'Material durability standards',\n        'Color theory principles',\n        'Space planning fundamentals',\n        'Lighting design basics',\n        'Furniture scale and proportion'\n      ],\n      dynamic: [\n        'Vendor lists and lead times',\n        'Designer\\'s specific aesthetic \"signature\"',\n        'Material pricing and availability',\n        'Trend forecasting data',\n        'Portfolio images by style',\n        'Project timelines'\n      ]\n    },\n    \n    learningLoops: {\n      patternRecognition: 'Analyzes lead \"Inspiration\" keywords (e.g., \"Scandi,\" \"Moody,\" \"Minimalist,\" \"Maximalist\")',\n      adaptation: 'Automatically curates the first set of portfolio images shown to the lead based on detected aesthetic preferences',\n      feedbackIntegration: 'Tracks which design styles convert best for different client demographics and project types'\n    },\n    \n    tacticalExecution: {\n      primaryAction: 'Design Discovery Call',\n      conversionRhythm: 'Focuses on booking a paid or free consultation to establish project scope and vision alignment',\n      secondaryActions: [\n        'Style quiz/assessment',\n        'Portfolio showcase (filtered by style)',\n        'Mood board creation',\n        'Budget range discussion',\n        'Timeline planning'\n      ]\n    },\n\n    research: {\n      scrapingStrategy: {\n        primarySource: 'website',\n        secondarySources: ['google-business'],\n        frequency: 'per-lead',\n        timeoutMs: 30000,\n        enableCaching: true,\n        cacheTtlSeconds: 300\n      },\n\n      highValueSignals: [\n        {id: 'portfolio_projects', label: 'Extensive Portfolio', description: 'Large project portfolio', keywords: [\"projects\", \"portfolio\", \"completed\", \"featured work\"], regexPattern: '(\\\\d{2,})\\\\+?\\\\s*projects?', priority: 'HIGH', action: 'increase-score', scoreBoost: 25, platform: 'website'},\n        {id: 'awards', label: 'Design Awards', description: 'Industry recognition', keywords: [\"award\", \"best of houzz\", \"asid\", \"designer of the year\", \"featured in\"], priority: 'HIGH', action: 'increase-score', scoreBoost: 30, platform: 'website'},\n        {id: 'residential_design', label: 'Residential Design', description: 'Home design focus', keywords: [\"residential\", \"home design\", \"whole house\", \"room redesign\"], priority: 'MEDIUM', action: 'add-to-segment', scoreBoost: 15, platform: 'website'},\n        {id: 'commercial_design', label: 'Commercial Design', description: 'Commercial space expertise', keywords: [\"commercial\", \"office design\", \"retail\", \"hospitality design\"], priority: 'MEDIUM', action: 'add-to-segment', scoreBoost: 18, platform: 'website'},\n        {id: 'full_service', label: 'Full-Service Design', description: 'End-to-end design services', keywords: [\"full service\", \"turnkey\", \"concept to completion\", \"from start to finish\"], priority: 'HIGH', action: 'increase-score', scoreBoost: 25, platform: 'website'},\n        {id: 'virtual_design', label: 'Virtual/Online Design', description: 'Remote design services', keywords: [\"virtual design\", \"online design\", \"e-design\", \"remote consultation\"], priority: 'MEDIUM', action: 'add-to-segment', scoreBoost: 15, platform: 'website'},\n        {id: 'luxury_design', label: 'Luxury Design', description: 'High-end market focus', keywords: [\"luxury\", \"high-end\", \"upscale\", \"custom\", \"bespoke\"], priority: 'HIGH', action: 'add-to-segment', scoreBoost: 28, platform: 'website'},\n        {id: 'sustainable_design', label: 'Sustainable Design', description: 'Eco-friendly focus', keywords: [\"sustainable\", \"eco-friendly\", \"green design\", \"leed\", \"environmental\"], priority: 'MEDIUM', action: 'add-to-segment', scoreBoost: 15, platform: 'website'},\n        {id: 'renovation_specialist', label: 'Renovation Specialist', description: 'Remodel expertise', keywords: [\"renovation\", \"remodel\", \"restoration\", \"historic\"], priority: 'MEDIUM', action: 'add-to-segment', scoreBoost: 18, platform: 'website'},\n        {id: 'hiring', label: 'Hiring Designers', description: 'Growing team', keywords: [\"hiring\", \"join our team\", \"designer positions\", \"careers\"], priority: 'HIGH', action: 'increase-score', scoreBoost: 25, platform: 'any'},\n        {id: 'showroom', label: 'Design Showroom', description: 'Physical showroom space', keywords: [\"showroom\", \"design studio\", \"visit us\", \"come see\"], priority: 'MEDIUM', action: 'increase-score', scoreBoost: 15, platform: 'website'},\n        {id: 'trade_program', label: 'Trade Program', description: 'Works with trade professionals', keywords: [\"trade\", \"to the trade\", \"designer discount\", \"trade only\"], priority: 'LOW', action: 'increase-score', scoreBoost: 10, platform: 'website'},\n        {id: 'certifications', label: 'Professional Certifications', description: 'Industry credentials', keywords: [\"asid\", \"iida\", \"ncidq\", \"certified\", \"accredited\"], priority: 'MEDIUM', action: 'increase-score', scoreBoost: 15, platform: 'website'},\n        {id: 'featured_press', label: 'Media Features', description: 'Press coverage', keywords: [\"featured in\", \"elle decor\", \"architectural digest\", \"house beautiful\", \"press\"], priority: 'HIGH', action: 'increase-score', scoreBoost: 25, platform: 'website'},\n        {id: 'specialty_services', label: 'Specialty Services', description: 'Niche design services', keywords: [\"color consultation\", \"space planning\", \"lighting design\", \"custom furniture\"], priority: 'MEDIUM', action: 'increase-score', scoreBoost: 12, platform: 'website'}\n      ],\n\n      fluffPatterns: [\n        {id: 'copyright', pattern: '┬⌐\\\\s*\\\\d{4}', description: 'Copyright', context: 'footer'},\n        {id: 'rights', pattern: 'all rights reserved', description: 'Rights', context: 'footer'},\n        {id: 'privacy', pattern: 'privacy policy', description: 'Privacy', context: 'footer'},\n        {id: 'terms', pattern: 'terms (of|and)', description: 'Terms', context: 'footer'},\n        {id: 'cookies', pattern: 'cookies', description: 'Cookie notice', context: 'all'},\n        {id: 'social', pattern: 'follow us', description: 'Social media', context: 'footer'},\n        {id: 'contact', pattern: '^contact$', description: 'Contact link', context: 'header'},\n        {id: 'about', pattern: '^about$', description: 'About link', context: 'header'},\n        {id: 'portfolio', pattern: '^portfolio$', description: 'Portfolio link', context: 'header'},\n        {id: 'services', pattern: '^services$', description: 'Services', context: 'header'},\n        {id: 'process', pattern: '^process$', description: 'Process link', context: 'header'},\n        {id: 'back_top', pattern: 'back to top', description: 'Back to top', context: 'footer'},\n        {id: 'sitemap', pattern: 'sitemap', description: 'Sitemap', context: 'footer'},\n        {id: 'powered', pattern: 'powered by', description: 'Attribution', context: 'footer'},\n        {id: 'consultation', pattern: '^consultation$', description: 'Consult link', context: 'header'},\n        {id: 'blog', pattern: '^blog$', description: 'Blog', context: 'header'},\n        {id: 'testimonials', pattern: '^testimonials$', description: 'Testimonials', context: 'header'},\n        {id: 'gallery', pattern: '^gallery$', description: 'Gallery', context: 'header'},\n        {id: 'shop', pattern: '^shop$', description: 'Shop link', context: 'header'},\n        {id: 'press', pattern: '^press$', description: 'Press link', context: 'header'}\n      ],\n\n      scoringRules: [\n        {id: 'recognized_designer', name: 'Recognized Designer', description: 'Awards with media features', condition: 'signals.some(s => s.signalId === \"awards\") && signals.some(s => s.signalId === \"featured_press\")', scoreBoost: 35, priority: 1, enabled: true},\n        {id: 'luxury_specialist', name: 'Luxury Specialist', description: 'Luxury focus with extensive portfolio', condition: 'signals.some(s => s.signalId === \"luxury_design\") && signals.some(s => s.signalId === \"portfolio_projects\")', scoreBoost: 30, priority: 2, enabled: true},\n        {id: 'comprehensive_provider', name: 'Comprehensive Provider', description: 'Full-service with showroom', condition: 'signals.some(s => s.signalId === \"full_service\") && signals.some(s => s.signalId === \"showroom\")', scoreBoost: 25, priority: 3, enabled: true},\n        {id: 'growing_firm', name: 'Growing Firm', description: 'Hiring with expansion', condition: 'signals.some(s => s.signalId === \"hiring\")', scoreBoost: 25, priority: 4, enabled: true},\n        {id: 'versatile', name: 'Versatile Designer', description: 'Both residential and commercial', condition: 'signals.some(s => s.signalId === \"residential_design\") && signals.some(s => s.signalId === \"commercial_design\")', scoreBoost: 22, priority: 5, enabled: true},\n        {id: 'professional', name: 'Professional', description: 'Certifications with awards', condition: 'signals.some(s => s.signalId === \"certifications\") && signals.some(s => s.signalId === \"awards\")', scoreBoost: 20, priority: 6, enabled: true},\n        {id: 'modern_approach', name: 'Modern Approach', description: 'Virtual and traditional services', condition: 'signals.some(s => s.signalId === \"virtual_design\") && signals.some(s => s.signalId === \"full_service\")', scoreBoost: 18, priority: 7, enabled: true},\n        {id: 'eco_conscious', name: 'Eco-Conscious', description: 'Sustainable design with certifications', condition: 'signals.some(s => s.signalId === \"sustainable_design\")', scoreBoost: 15, priority: 8, enabled: true},\n        {id: 'renovation_expert', name: 'Renovation Expert', description: 'Renovation specialist with portfolio', condition: 'signals.some(s => s.signalId === \"renovation_specialist\") && signals.some(s => s.signalId === \"portfolio_projects\")', scoreBoost: 18, priority: 9, enabled: true},\n        {id: 'trade_professional', name: 'Trade Professional', description: 'Trade program with showroom', condition: 'signals.some(s => s.signalId === \"trade_program\") && signals.some(s => s.signalId === \"showroom\")', scoreBoost: 15, priority: 10, enabled: true}\n      ],\n\n      customFields: [\n        {key: 'project_count', label: 'Number of Projects', type: 'number', description: 'Completed projects', extractionHints: ['projects', 'completed', 'portfolio'], required: false, defaultValue: 0},\n        {key: 'design_styles', label: 'Design Styles', type: 'array', description: 'Aesthetic specializations', extractionHints: ['modern', 'traditional', 'transitional', 'contemporary'], required: false, defaultValue: []},\n        {key: 'specialization', label: 'Market Specialization', type: 'string', description: 'Primary focus area', extractionHints: ['residential', 'commercial', 'luxury'], required: false, defaultValue: 'residential'},\n        {key: 'has_showroom', label: 'Has Showroom', type: 'boolean', description: 'Physical showroom location', extractionHints: ['showroom', 'studio'], required: false, defaultValue: false},\n        {key: 'offers_virtual', label: 'Offers Virtual Design', type: 'boolean', description: 'Remote services available', extractionHints: ['virtual', 'online', 'e-design'], required: false, defaultValue: false},\n        {key: 'service_areas', label: 'Service Areas', type: 'array', description: 'Geographic coverage', extractionHints: ['serving', 'areas', 'cities'], required: false, defaultValue: []},\n        {key: 'team_size', label: 'Team Size', type: 'number', description: 'Number of designers', extractionHints: ['designers', 'team', 'staff'], required: false, defaultValue: 1}\n      ],\n\n      metadata: {\n        lastUpdated: '2025-12-29',\n        version: 1,\n        updatedBy: 'system',\n        notes: 'Interior design intelligence - focuses on portfolio depth, industry recognition, service breadth, and market specialization'\n      }\n    }\n  },\n  \n  'architecture': {\n    id: 'architecture',\n    name: 'Architecture',\n    description: 'For architects - technical vision and regulatory expertise',\n    category: 'Real Estate',\n    \n    coreIdentity: {\n      title: 'The Technical Visionary',\n      positioning: 'Precise, visionary, and highly regulatory-aware. Focused on the intersection of \"Form and Function\"',\n      tone: 'Professional, technical, forward-thinking'\n    },\n    \n    cognitiveLogic: {\n      framework: 'The Feasibility-First Logic',\n      reasoning: 'Logic that prioritizes \"Can we build this?\" (zoning/code compliance) before \"What will it look like?\" (aesthetic design)',\n      decisionProcess: 'Regulatory Feasibility ΓåÆ Technical Design ΓåÆ Aesthetic Vision'\n    },\n    \n    knowledgeRAG: {\n      static: [\n        'Building codes (IBC, IRC)',\n        'ADA compliance requirements',\n        'Structural engineering basics',\n        'Zoning regulations',\n        'Environmental design standards',\n        'Permit processes'\n      ],\n      dynamic: [\n        'Local permit timelines by jurisdiction',\n        'Past project blueprints',\n        'Firm-specific CAD/BIM processes',\n        'Zoning variances and precedents',\n        'Material innovations',\n        'Code updates and changes'\n      ]\n    },\n    \n    learningLoops: {\n      patternRecognition: 'Flags if users are asking for \"Impossible Builds\" (e.g., 5 stories in a 2-story zoning district)',\n      adaptation: 'Suggests a \"Zoning Consultation\" or \"Variance Application\" strategy instead of immediate design engagement',\n      feedbackIntegration: 'Learns which code/zoning questions are most common and proactively addresses them early in conversation'\n    },\n    \n    tacticalExecution: {\n      primaryAction: 'Feasibility Assessment',\n      conversionRhythm: 'Directs users toward a \"Site Review\" or \"Master Planning\" phase to establish viability before design',\n      secondaryActions: [\n        'Zoning analysis',\n        'Code compliance review',\n        'Conceptual design presentation',\n        'Preliminary budget estimate',\n        'Project timeline development'\n      ]\n    },\n\n    research: {\n      scrapingStrategy: {\n        primarySource: 'website',\n        secondarySources: ['linkedin-company'],\n        frequency: 'weekly',\n        timeoutMs: 30000,\n        enableCaching: true,\n        cacheTtlSeconds: 600\n      },\n\n      highValueSignals: [\n        {id: 'project_count', label: 'Large Portfolio', description: 'Many completed projects', keywords: [\"projects\", \"portfolio\", \"completed\"], regexPattern: '(\\\\d{2,})\\\\+?\\\\s*projects?', priority: 'HIGH', action: 'increase-score', scoreBoost: 25, platform: 'website'},\n        {id: 'awards', label: 'Architecture Awards', description: 'Industry recognition', keywords: [\"aia award\", \"design award\", \"architecture award\", \"recognition\"], priority: 'CRITICAL', action: 'increase-score', scoreBoost: 40, platform: 'website'},\n        {id: 'leed_certified', label: 'LEED Certification', description: 'Sustainable design credentials', keywords: [\"leed\", \"leed certified\", \"green building\", \"sustainable\"], priority: 'HIGH', action: 'add-to-segment', scoreBoost: 25, platform: 'website'},\n        {id: 'commercial_architecture', label: 'Commercial Architecture', description: 'Commercial project focus', keywords: [\"commercial\", \"office building\", \"retail\", \"hospitality\", \"mixed-use\"], priority: 'HIGH', action: 'add-to-segment', scoreBoost: 25, platform: 'website'},\n        {id: 'residential_architecture', label: 'Residential Architecture', description: 'Custom home design', keywords: [\"residential\", \"custom homes\", \"single family\", \"estates\"], priority: 'MEDIUM', action: 'add-to-segment', scoreBoost: 15, platform: 'website'},\n        {id: 'master_planning', label: 'Master Planning', description: 'Large-scale planning services', keywords: [\"master planning\", \"urban design\", \"site planning\", \"campus\"], priority: 'HIGH', action: 'add-to-segment', scoreBoost: 28, platform: 'website'},\n        {id: 'renovation_adaptive', label: 'Renovation & Adaptive Reuse', description: 'Historic renovation expertise', keywords: [\"renovation\", \"adaptive reuse\", \"historic\", \"restoration\"], priority: 'MEDIUM', action: 'add-to-segment', scoreBoost: 18, platform: 'website'},\n        {id: 'team_size', label: 'Large Firm', description: 'Multiple architects', keywords: [\"architects\", \"principals\", \"team\"], regexPattern: '(\\\\d+)\\\\s*architects?', priority: 'HIGH', action: 'increase-score', scoreBoost: 30, platform: 'website'},\n        {id: 'hiring', label: 'Hiring Architects', description: 'Growing team', keywords: [\"hiring\", \"join our team\", \"architect positions\", \"careers\"], priority: 'HIGH', action: 'increase-score', scoreBoost: 30, platform: 'any'},\n        {id: 'bim_services', label: 'BIM Services', description: 'Building Information Modeling', keywords: [\"bim\", \"revit\", \"3d modeling\", \"digital twin\"], priority: 'MEDIUM', action: 'increase-score', scoreBoost: 15, platform: 'website'},\n        {id: 'international_projects', label: 'International Projects', description: 'Global project experience', keywords: [\"international\", \"global\", \"worldwide\", \"countries\"], priority: 'HIGH', action: 'add-to-segment', scoreBoost: 22, platform: 'website'},\n        {id: 'specialization', label: 'Specialized Practice', description: 'Niche expertise', keywords: [\"healthcare\", \"education\", \"hospitality\", \"industrial\", \"institutional\"], priority: 'MEDIUM', action: 'add-to-segment', scoreBoost: 15, platform: 'website'},\n        {id: 'published_work', label: 'Published Work', description: 'Featured in publications', keywords: [\"published\", \"architectural digest\", \"featured in\", \"architecture magazine\"], priority: 'HIGH', action: 'increase-score', scoreBoost: 25, platform: 'website'},\n        {id: 'registered', label: 'Licensed Architects', description: 'Professional licensure', keywords: [\"licensed\", \"registered\", \"aia\", \"ncarb\"], priority: 'LOW', action: 'increase-score', scoreBoost: 10, platform: 'website'},\n        {id: 'multi_office', label: 'Multiple Offices', description: 'Multi-location firm', keywords: [\"offices\", \"locations\", \"office in\"], regexPattern: '(\\\\d+)\\\\s*offices?', priority: 'HIGH', action: 'increase-score', scoreBoost: 25, platform: 'website'}\n      ],\n\n      fluffPatterns: [\n        {id: 'copyright', pattern: '┬⌐\\\\s*\\\\d{4}', description: 'Copyright', context: 'footer'},\n        {id: 'rights', pattern: 'all rights reserved', description: 'Rights', context: 'footer'},\n        {id: 'privacy', pattern: 'privacy policy', description: 'Privacy', context: 'footer'},\n        {id: 'terms', pattern: 'terms (of|and)', description: 'Terms', context: 'footer'},\n        {id: 'cookies', pattern: 'cookies', description: 'Cookie notice', context: 'all'},\n        {id: 'social', pattern: 'follow us', description: 'Social media', context: 'footer'},\n        {id: 'contact', pattern: '^contact$', description: 'Contact link', context: 'header'},\n        {id: 'about', pattern: '^about$', description: 'About link', context: 'header'},\n        {id: 'projects', pattern: '^projects$', description: 'Projects link', context: 'header'},\n        {id: 'services', pattern: '^services$', description: 'Services', context: 'header'},\n        {id: 'news', pattern: '^news$', description: 'News link', context: 'header'},\n        {id: 'back_top', pattern: 'back to top', description: 'Back to top', context: 'footer'},\n        {id: 'sitemap', pattern: 'sitemap', description: 'Sitemap', context: 'footer'},\n        {id: 'powered', pattern: 'powered by', description: 'Attribution', context: 'footer'},\n        {id: 'careers', pattern: '^careers$', description: 'Careers', context: 'header'},\n        {id: 'blog', pattern: '^blog$', description: 'Blog', context: 'header'},\n        {id: 'team', pattern: '^team$', description: 'Team link', context: 'header'},\n        {id: 'press', pattern: '^press$', description: 'Press link', context: 'header'},\n        {id: 'awards', pattern: '^awards$', description: 'Awards link', context: 'header'},\n        {id: 'sustainability', pattern: '^sustainability$', description: 'Sustainability', context: 'header'}\n      ],\n\n      scoringRules: [\n        {id: 'award_winning_firm', name: 'Award-Winning Firm', description: 'AIA awards with large portfolio', condition: 'signals.some(s => s.signalId === \"awards\") && signals.some(s => s.signalId === \"project_count\")', scoreBoost: 40, priority: 1, enabled: true},\n        {id: 'large_practice', name: 'Large Practice', description: 'Multiple architects with offices', condition: 'signals.some(s => s.signalId === \"team_size\") && signals.some(s => s.signalId === \"multi_office\")', scoreBoost: 35, priority: 2, enabled: true},\n        {id: 'sustainable_leader', name: 'Sustainable Leader', description: 'LEED certified with green focus', condition: 'signals.some(s => s.signalId === \"leed_certified\")', scoreBoost: 25, priority: 3, enabled: true},\n        {id: 'tech_forward', name: 'Technology-Forward', description: 'BIM services with modern tools', condition: 'signals.some(s => s.signalId === \"bim_services\")', scoreBoost: 18, priority: 4, enabled: true},\n        {id: 'versatile', name: 'Versatile Practice', description: 'Both commercial and residential', condition: 'signals.some(s => s.signalId === \"commercial_architecture\") && signals.some(s => s.signalId === \"residential_architecture\")', scoreBoost: 22, priority: 5, enabled: true},\n        {id: 'growing_firm', name: 'Growing Firm', description: 'Hiring architects', condition: 'signals.some(s => s.signalId === \"hiring\")', scoreBoost: 30, priority: 6, enabled: true},\n        {id: 'recognized_leader', name: 'Recognized Leader', description: 'Published with awards', condition: 'signals.some(s => s.signalId === \"published_work\") && signals.some(s => s.signalId === \"awards\")', scoreBoost: 35, priority: 7, enabled: true},\n        {id: 'global_reach', name: 'Global Practice', description: 'International projects with large team', condition: 'signals.some(s => s.signalId === \"international_projects\") && signals.some(s => s.signalId === \"team_size\")', scoreBoost: 30, priority: 8, enabled: true},\n        {id: 'niche_expert', name: 'Niche Expert', description: 'Specialized practice area', condition: 'signals.some(s => s.signalId === \"specialization\")', scoreBoost: 18, priority: 9, enabled: true},\n        {id: 'adaptive_reuse', name: 'Adaptive Reuse Specialist', description: 'Historic renovation with portfolio', condition: 'signals.some(s => s.signalId === \"renovation_adaptive\") && signals.some(s => s.signalId === \"project_count\")', scoreBoost: 20, priority: 10, enabled: true}\n      ],\n\n      customFields: [\n        {key: 'architect_count', label: 'Number of Architects', type: 'number', description: 'Licensed architects on staff', extractionHints: ['architects', 'principals', 'team'], required: false, defaultValue: 1},\n        {key: 'project_types', label: 'Project Types', type: 'array', description: 'Types of architecture', extractionHints: ['residential', 'commercial', 'institutional'], required: false, defaultValue: []},\n        {key: 'has_leed_accreditation', label: 'LEED Accredited', type: 'boolean', description: 'LEED certification', extractionHints: ['leed'], required: false, defaultValue: false},\n        {key: 'has_bim', label: 'Uses BIM', type: 'boolean', description: 'BIM capabilities', extractionHints: ['bim', 'revit'], required: false, defaultValue: false},\n        {key: 'office_locations', label: 'Office Count', type: 'number', description: 'Number of offices', extractionHints: ['offices', 'locations'], required: false, defaultValue: 1},\n        {key: 'specialization', label: 'Practice Specialization', type: 'string', description: 'Primary focus area', extractionHints: ['specialize', 'focus', 'expert'], required: false, defaultValue: 'general'},\n        {key: 'years_established', label: 'Years in Practice', type: 'number', description: 'Firm age', extractionHints: ['established', 'since', 'years'], required: false, defaultValue: 0}\n      ],\n\n      metadata: {\n        lastUpdated: '2025-12-29',\n        version: 1,\n        updatedBy: 'system',\n        notes: 'Architecture intelligence - focuses on firm size, project diversity, sustainability credentials, and industry recognition'\n      }\n    }\n  },\n  \n  'construction-development': {\n    id: 'construction-development',\n    name: 'Construction & Development',\n    description: 'For builders - reliability and timeline management',\n    category: 'Real Estate',\n    \n    coreIdentity: {\n      title: 'The Master Builder',\n      positioning: 'Reliable, transparent, ruggedly professional, and timeline-driven',\n      tone: 'Straightforward, competent, trustworthy'\n    },\n    \n    cognitiveLogic: {\n      framework: 'The Critical Path Framework',\n      reasoning: 'Logic that emphasizes the \"Build Sequence,\" safety protocols, and budget transparency. Focuses on \"De-risking\" the project for the owner',\n      decisionProcess: 'Risk Assessment ΓåÆ Sequencing ΓåÆ Budget Control'\n    },\n    \n    knowledgeRAG: {\n      static: [\n        'Material cost baselines',\n        'Trade sequences (Foundation ΓåÆ Framing ΓåÆ MEP ΓåÆ Finishes)',\n        'Safety regulations (OSHA)',\n        'Quality control standards',\n        'Warranty structures'\n      ],\n      dynamic: [\n        'Current subcontractor availability',\n        'Project gallery (completed work)',\n        'Safety certifications and insurance',\n        'Material pricing (lumber, steel, concrete)',\n        'Weather delays and seasonal factors',\n        'Permit status tracking'\n      ]\n    },\n    \n    learningLoops: {\n      patternRecognition: 'Tracks lead anxiety regarding \"Budget Overruns\" and \"Timeline Delays\"',\n      adaptation: 'Triggers a \"Fixed-Price vs. Cost-Plus\" educational module to address pricing concerns proactively',\n      feedbackIntegration: 'Identifies which guarantees (timeline, budget, quality) are most important to different client types'\n    },\n    \n    tacticalExecution: {\n      primaryAction: 'Bid Request',\n      conversionRhythm: 'Moves the lead toward submitting plans for a \"Preliminary Estimate\" or \"Detailed Proposal\"',\n      secondaryActions: [\n        'Project timeline estimate',\n        'Material selection consultation',\n        'Subcontractor vetting process',\n        'Site visit scheduling',\n        'Financing options discussion'\n      ]\n    },\n\n    research: {\n      scrapingStrategy: {\n        primarySource: 'website',\n        secondarySources: ['google-business', 'linkedin-company'],\n        frequency: 'per-lead',\n        timeoutMs: 30000,\n        enableCaching: true,\n        cacheTtlSeconds: 300\n      },\n\n      highValueSignals: [\n        {id: 'projects_completed', label: 'High Project Volume', description: 'Many completed projects', keywords: [\"projects completed\", \"homes built\", \"developments\"], regexPattern: '(\\\\d{2,})\\\\+?\\\\s*(projects?|homes?|developments?)', priority: 'CRITICAL', action: 'increase-score', scoreBoost: 35, platform: 'website'},\n        {id: 'custom_homes', label: 'Custom Home Builder', description: 'Custom residential construction', keywords: [\"custom homes\", \"custom builder\", \"luxury homes\", \"estate homes\"], priority: 'HIGH', action: 'add-to-segment', scoreBoost: 25, platform: 'website'},\n        {id: 'commercial_construction', label: 'Commercial Construction', description: 'Commercial project experience', keywords: [\"commercial construction\", \"office building\", \"retail construction\", \"industrial\"], priority: 'HIGH', action: 'add-to-segment', scoreBoost: 25, platform: 'website'},\n        {id: 'design_build', label: 'Design-Build Services', description: 'Integrated design-build', keywords: [\"design build\", \"design-build\", \"single source\", \"one stop\"], priority: 'HIGH', action: 'increase-score', scoreBoost: 28, platform: 'website'},\n        {id: 'hiring', label: 'Hiring Construction Workers', description: 'Growing workforce', keywords: [\"hiring\", \"now hiring\", \"careers\", \"join our team\", \"construction jobs\"], priority: 'HIGH', action: 'increase-score', scoreBoost: 30, platform: 'any'},\n        {id: 'expansion', label: 'Business Expansion', description: 'New markets or locations', keywords: [\"expanding\", \"new office\", \"now building in\", \"new market\"], priority: 'HIGH', action: 'increase-score', scoreBoost: 25, platform: 'any'},\n        {id: 'certifications', label: 'Industry Certifications', description: 'Professional credentials', keywords: [\"licensed\", \"insured\", \"bonded\", \"nahb\", \"certified\"], priority: 'MEDIUM', action: 'increase-score', scoreBoost: 15, platform: 'website'},\n        {id: 'warranty', label: 'Warranty Program', description: 'Construction warranty offered', keywords: [\"warranty\", \"guarantee\", \"quality assurance\"], regexPattern: '(\\\\d+)\\\\s*year warranty', priority: 'MEDIUM', action: 'increase-score', scoreBoost: 15, platform: 'website'},\n        {id: 'green_building', label: 'Green Building', description: 'Sustainable construction', keywords: [\"green building\", \"leed\", \"energy efficient\", \"sustainable\", \"net zero\"], priority: 'MEDIUM', action: 'add-to-segment', scoreBoost: 18, platform: 'website'},\n        {id: 'subdivisions', label: 'Subdivision Development', description: 'Community development', keywords: [\"subdivision\", \"community\", \"development\", \"master planned\"], priority: 'CRITICAL', action: 'add-to-segment', scoreBoost: 35, platform: 'website'},\n        {id: 'remodeling', label: 'Remodeling Services', description: 'Renovation/addition expertise', keywords: [\"remodeling\", \"renovation\", \"additions\", \"home improvement\"], priority: 'MEDIUM', action: 'add-to-segment', scoreBoost: 15, platform: 'website'},\n        {id: 'awards', label: 'Industry Awards', description: 'Builder awards or recognition', keywords: [\"builder of the year\", \"parade of homes\", \"award winning\", \"best builder\"], priority: 'HIGH', action: 'increase-score', scoreBoost: 25, platform: 'website'},\n        {id: 'safety_record', label: 'Safety Record', description: 'Emphasizes safety performance', keywords: [\"safety\", \"osha\", \"zero accidents\", \"safety first\"], priority: 'LOW', action: 'increase-score', scoreBoost: 10, platform: 'website'},\n        {id: 'fixed_price', label: 'Fixed-Price Contracts', description: 'Guaranteed pricing', keywords: [\"fixed price\", \"guaranteed price\", \"no surprises\", \"firm quote\"], priority: 'MEDIUM', action: 'increase-score', scoreBoost: 15, platform: 'website'},\n        {id: 'timeline_guarantee', label: 'Timeline Guarantee', description: 'On-time completion promise', keywords: [\"on-time\", \"timeline guarantee\", \"completion date\", \"scheduled completion\"], priority: 'MEDIUM', action: 'increase-score', scoreBoost: 15, platform: 'website'}\n      ],\n\n      fluffPatterns: [\n        {id: 'copyright', pattern: '┬⌐\\\\s*\\\\d{4}', description: 'Copyright', context: 'footer'},\n        {id: 'rights', pattern: 'all rights reserved', description: 'Rights', context: 'footer'},\n        {id: 'licensed', pattern: 'licensed.*insured.*bonded', description: 'License boilerplate', context: 'footer'},\n        {id: 'privacy', pattern: 'privacy policy', description: 'Privacy', context: 'footer'},\n        {id: 'terms', pattern: 'terms (of|and)', description: 'Terms', context: 'footer'},\n        {id: 'cookies', pattern: 'cookies', description: 'Cookie notice', context: 'all'},\n        {id: 'social', pattern: 'follow us', description: 'Social media', context: 'footer'},\n        {id: 'contact', pattern: '^contact$', description: 'Contact link', context: 'header'},\n        {id: 'about', pattern: '^about$', description: 'About link', context: 'header'},\n        {id: 'projects', pattern: '^projects$', description: 'Projects link', context: 'header'},\n        {id: 'services', pattern: '^services$', description: 'Services', context: 'header'},\n        {id: 'gallery', pattern: '^gallery$', description: 'Gallery', context: 'header'},\n        {id: 'back_top', pattern: 'back to top', description: 'Back to top', context: 'footer'},\n        {id: 'sitemap', pattern: 'sitemap', description: 'Sitemap', context: 'footer'},\n        {id: 'powered', pattern: 'powered by', description: 'Attribution', context: 'footer'},\n        {id: 'careers', pattern: '^careers$', description: 'Careers', context: 'header'},\n        {id: 'blog', pattern: '^blog$', description: 'Blog', context: 'header'},\n        {id: 'testimonials', pattern: '^testimonials$', description: 'Testimonials', context: 'header'},\n        {id: 'process', pattern: '^process$', description: 'Process link', context: 'header'},\n        {id: 'financing', pattern: '^financing$', description: 'Financing link', context: 'header'}\n      ],\n\n      scoringRules: [\n        {id: 'large_builder', name: 'Large Builder', description: 'High project volume with team growth', condition: 'signals.some(s => s.signalId === \"projects_completed\") && signals.some(s => s.signalId === \"hiring\")', scoreBoost: 40, priority: 1, enabled: true},\n        {id: 'design_build_firm', name: 'Design-Build Firm', description: 'Design-build with custom homes', condition: 'signals.some(s => s.signalId === \"design_build\") && signals.some(s => s.signalId === \"custom_homes\")', scoreBoost: 30, priority: 2, enabled: true},\n        {id: 'developer', name: 'Developer', description: 'Subdivision development with volume', condition: 'signals.some(s => s.signalId === \"subdivisions\") && signals.some(s => s.signalId === \"projects_completed\")', scoreBoost: 40, priority: 3, enabled: true},\n        {id: 'quality_focused', name: 'Quality-Focused', description: 'Awards with warranty', condition: 'signals.some(s => s.signalId === \"awards\") && signals.some(s => s.signalId === \"warranty\")', scoreBoost: 25, priority: 4, enabled: true},\n        {id: 'versatile_builder', name: 'Versatile Builder', description: 'Custom and commercial', condition: 'signals.some(s => s.signalId === \"custom_homes\") && signals.some(s => s.signalId === \"commercial_construction\")', scoreBoost: 28, priority: 5, enabled: true},\n        {id: 'remodeling_specialist', name: 'Remodeling Specialist', description: 'Renovation focus with portfolio', condition: 'signals.some(s => s.signalId === \"remodeling\") && signals.some(s => s.signalId === \"projects_completed\")', scoreBoost: 20, priority: 6, enabled: true},\n        {id: 'sustainable_builder', name: 'Sustainable Builder', description: 'Green building with certifications', condition: 'signals.some(s => s.signalId === \"green_building\") && signals.some(s => s.signalId === \"certifications\")', scoreBoost: 22, priority: 7, enabled: true},\n        {id: 'reliable_contractor', name: 'Reliable Contractor', description: 'Timeline and price guarantees', condition: 'signals.some(s => s.signalId === \"timeline_guarantee\") && signals.some(s => s.signalId === \"fixed_price\")', scoreBoost: 25, priority: 8, enabled: true},\n        {id: 'expanding_business', name: 'Expanding Business', description: 'Hiring with market expansion', condition: 'signals.some(s => s.signalId === \"hiring\") && signals.some(s => s.signalId === \"expansion\")', scoreBoost: 30, priority: 9, enabled: true},\n        {id: 'safety_conscious', name: 'Safety-Conscious', description: 'Safety record with certifications', condition: 'signals.some(s => s.signalId === \"safety_record\") && signals.some(s => s.signalId === \"certifications\")', scoreBoost: 15, priority: 10, enabled: true}\n      ],\n\n      customFields: [\n        {key: 'projects_completed', label: 'Projects Completed', type: 'number', description: 'Total completed projects', extractionHints: ['projects', 'homes built', 'completed'], required: false, defaultValue: 0},\n        {key: 'construction_types', label: 'Construction Types', type: 'array', description: 'Project types handled', extractionHints: ['custom', 'commercial', 'remodeling'], required: false, defaultValue: []},\n        {key: 'has_design_build', label: 'Design-Build Capabilities', type: 'boolean', description: 'Integrated services', extractionHints: ['design build'], required: false, defaultValue: false},\n        {key: 'service_areas', label: 'Service Areas', type: 'array', description: 'Geographic coverage', extractionHints: ['serving', 'areas', 'cities'], required: false, defaultValue: []},\n        {key: 'warranty_years', label: 'Warranty (Years)', type: 'number', description: 'Warranty period', extractionHints: ['year warranty', 'warranty'], required: false, defaultValue: 1},\n        {key: 'specialization', label: 'Specialization', type: 'string', description: 'Primary focus', extractionHints: ['specialize', 'custom homes', 'commercial'], required: false, defaultValue: 'general'},\n        {key: 'years_in_business', label: 'Years Established', type: 'number', description: 'Years operating', extractionHints: ['years', 'since', 'established'], required: false, defaultValue: 0}\n      ],\n\n      metadata: {\n        lastUpdated: '2025-12-29',\n        version: 1,\n        updatedBy: 'system',\n        notes: 'Construction & development intelligence - focuses on project volume, service diversity, certifications, and growth indicators'\n      }\n    }\n  },\n  \n  'title-escrow': {\n    id: 'title-escrow',\n    name: 'Title & Escrow',\n    description: 'For title/escrow companies - compliance and security focus',\n    category: 'Real Estate',\n    \n    coreIdentity: {\n      title: 'The Neutral Third-Party / The Deal Closer',\n      positioning: 'Calm, precise, legally rigorous, and administrative',\n      tone: 'Professional, reassuring, detail-oriented'\n    },\n    \n    cognitiveLogic: {\n      framework: 'The Compliance & Security Logic',\n      reasoning: 'Focuses on \"Clear Title,\" \"Wire Fraud Protection,\" and the \"Final Milestone\" of the transaction',\n      decisionProcess: 'Title Verification ΓåÆ Risk Mitigation ΓåÆ Secure Closing'\n    },\n    \n    knowledgeRAG: {\n      static: [\n        'Closing disclosure requirements',\n        'Lien search protocols',\n        'ALTA (American Land Title Association) standards',\n        'Title insurance types',\n        'Escrow disbursement rules',\n        'Recording procedures'\n      ],\n      dynamic: [\n        'Fee calculators by state/county',\n        'Current turn-around times',\n        'Firm-specific wire instructions (secured)',\n        'Title clearance status',\n        'Closing cost breakdowns',\n        'Document tracking'\n      ]\n    },\n    \n    learningLoops: {\n      patternRecognition: 'Monitors common \"Closing Friction\" questions (wire fraud, unclear fees, timeline delays)',\n      adaptation: 'Prompts the agent to proactively explain things like \"Prerecorded documents\" to first-time sellers/buyers',\n      feedbackIntegration: 'Identifies which security measures (wire verification, fraud prevention) resonate most with different client types'\n    },\n    \n    tacticalExecution: {\n      primaryAction: 'Order Initiation',\n      conversionRhythm: 'Focuses on getting the \"Purchase Agreement\" uploaded to open the file and begin title search',\n      secondaryActions: [\n        'Wire fraud protection education',\n        'Closing cost estimate',\n        'Timeline confirmation',\n        'Document checklist provision',\n        'Secure portal setup'\n      ]\n    },\n\n    research: {\n      scrapingStrategy: {\n        primarySource: 'website',\n        secondarySources: ['linkedin-company'],\n        frequency: 'per-lead',\n        timeoutMs: 30000,\n        enableCaching: true,\n        cacheTtlSeconds: 300\n      },\n\n      highValueSignals: [\n        {id: 'transaction_volume', label: 'High Transaction Volume', description: 'Many closings per year', keywords: [\"transactions\", \"closings\", \"files closed\"], regexPattern: '([\\\\d,]+)\\\\s*(transactions?|closings?)', priority: 'CRITICAL', action: 'increase-score', scoreBoost: 40, platform: 'website'},\n        {id: 'multi_state', label: 'Multi-State Operations', description: 'Licensed in multiple states', keywords: [\"licensed in\", \"serving\", \"states\"], regexPattern: 'licensed? in (\\\\d+) states?', priority: 'HIGH', action: 'increase-score', scoreBoost: 30, platform: 'website'},\n        {id: 'hiring', label: 'Hiring Escrow Officers', description: 'Growing team', keywords: [\"hiring\", \"join our team\", \"careers\", \"escrow officer\", \"title examiner\"], priority: 'HIGH', action: 'increase-score', scoreBoost: 28, platform: 'any'},\n        {id: 'expansion', label: 'Office Expansion', description: 'New offices or markets', keywords: [\"new office\", \"expanding\", \"now serving\", \"new location\"], priority: 'HIGH', action: 'increase-score', scoreBoost: 25, platform: 'any'},\n        {id: 'wire_fraud_protection', label: 'Wire Fraud Protection', description: 'Advanced security measures', keywords: [\"wire fraud\", \"fraud protection\", \"secure wire\", \"verified wiring\", \"wire verification\"], priority: 'CRITICAL', action: 'increase-score', scoreBoost: 35, platform: 'website'},\n        {id: 'online_closing', label: 'Online/Remote Closing', description: 'Digital closing capability', keywords: [\"remote closing\", \"online closing\", \"e-closing\", \"digital closing\", \"notary\"], priority: 'HIGH', action: 'increase-score', scoreBoost: 25, platform: 'website'},\n        {id: 'commercial_title', label: 'Commercial Title', description: 'Commercial transaction expertise', keywords: [\"commercial\", \"commercial title\", \"business transactions\", \"investment properties\"], priority: 'MEDIUM', action: 'add-to-segment', scoreBoost: 18, platform: 'website'},\n        {id: 'refinance_specialist', label: 'Refinance Services', description: 'Refinance focus', keywords: [\"refinance\", \"refi\", \"refinancing\"], priority: 'MEDIUM', action: 'add-to-segment', scoreBoost: 12, platform: 'website'},\n        {id: 'fast_turnaround', label: 'Fast Turnaround', description: 'Quick closing time', keywords: [\"fast closing\", \"quick turnaround\", \"rush service\"], regexPattern: '(\\\\d+)\\\\s*day (closing|turnaround)', priority: 'HIGH', action: 'increase-score', scoreBoost: 20, platform: 'website'},\n        {id: 'underwriter_direct', label: 'Direct Underwriter', description: 'Owned by underwriter', keywords: [\"underwriter\", \"direct\", \"first american\", \"fidelity\", \"old republic\"], priority: 'MEDIUM', action: 'increase-score', scoreBoost: 15, platform: 'website'},\n        {id: '1031_exchange', label: '1031 Exchange Services', description: 'Qualified intermediary', keywords: [\"1031\", \"qualified intermediary\", \"exchange\", \"tax-deferred\"], priority: 'MEDIUM', action: 'add-to-segment', scoreBoost: 15, platform: 'website'},\n        {id: 'builder_services', label: 'Builder Services', description: 'New construction closings', keywords: [\"builder services\", \"new construction\", \"builder\", \"construction closings\"], priority: 'MEDIUM', action: 'add-to-segment', scoreBoost: 12, platform: 'website'},\n        {id: 'mobile_closing', label: 'Mobile Closing', description: 'Notary travels to client', keywords: [\"mobile closing\", \"we come to you\", \"convenient closing\", \"travel\"], priority: 'LOW', action: 'increase-score', scoreBoost: 10, platform: 'website'},\n        {id: 'customer_portal', label: 'Online Portal', description: 'Client portal access', keywords: [\"online portal\", \"client portal\", \"document portal\", \"secure access\"], priority: 'MEDIUM', action: 'increase-score', scoreBoost: 12, platform: 'website'},\n        {id: 'awards', label: 'Industry Recognition', description: 'Awards or top company status', keywords: [\"award\", \"best title\", \"top company\", \"recognition\"], priority: 'MEDIUM', action: 'increase-score', scoreBoost: 15, platform: 'website'}\n      ],\n\n      fluffPatterns: [\n        {id: 'copyright', pattern: '┬⌐\\\\s*\\\\d{4}', description: 'Copyright', context: 'footer'},\n        {id: 'rights', pattern: 'all rights reserved', description: 'Rights', context: 'footer'},\n        {id: 'privacy', pattern: 'privacy policy', description: 'Privacy', context: 'footer'},\n        {id: 'terms', pattern: 'terms (of|and)', description: 'Terms', context: 'footer'},\n        {id: 'cookies', pattern: 'cookies', description: 'Cookie notice', context: 'all'},\n        {id: 'licensed', pattern: 'licensed.*regulated', description: 'License notice', context: 'footer'},\n        {id: 'social', pattern: 'follow us', description: 'Social media', context: 'footer'},\n        {id: 'contact', pattern: '^contact$', description: 'Contact link', context: 'header'},\n        {id: 'about', pattern: '^about$', description: 'About link', context: 'header'},\n        {id: 'services', pattern: '^services$', description: 'Services', context: 'header'},\n        {id: 'locations', pattern: '^locations$', description: 'Locations', context: 'header'},\n        {id: 'back_top', pattern: 'back to top', description: 'Back to top', context: 'footer'},\n        {id: 'sitemap', pattern: 'sitemap', description: 'Sitemap', context: 'footer'},\n        {id: 'powered', pattern: 'powered by', description: 'Attribution', context: 'footer'},\n        {id: 'careers', pattern: '^careers$', description: 'Careers', context: 'header'},\n        {id: 'blog', pattern: '^blog$', description: 'Blog', context: 'header'},\n        {id: 'calculator', pattern: '^calculator$', description: 'Calculator', context: 'header'},\n        {id: 'faq', pattern: '^faq$', description: 'FAQ', context: 'header'},\n        {id: 'portal', pattern: '^portal$', description: 'Portal link', context: 'header'},\n        {id: 'resources', pattern: '^resources$', description: 'Resources', context: 'header'}\n      ],\n\n      scoringRules: [\n        {id: 'high_volume_operator', name: 'High-Volume Operator', description: 'High transactions with multi-state presence', condition: 'signals.some(s => s.signalId === \"transaction_volume\") && signals.some(s => s.signalId === \"multi_state\")', scoreBoost: 45, priority: 1, enabled: true},\n        {id: 'security_leader', name: 'Security Leader', description: 'Wire fraud protection with online portal', condition: 'signals.some(s => s.signalId === \"wire_fraud_protection\") && signals.some(s => s.signalId === \"customer_portal\")', scoreBoost: 30, priority: 2, enabled: true},\n        {id: 'modern_company', name: 'Modern Company', description: 'Online closing with digital portal', condition: 'signals.some(s => s.signalId === \"online_closing\") && signals.some(s => s.signalId === \"customer_portal\")', scoreBoost: 25, priority: 3, enabled: true},\n        {id: 'growing_business', name: 'Growing Business', description: 'Hiring with expansion', condition: 'signals.some(s => s.signalId === \"hiring\") && signals.some(s => s.signalId === \"expansion\")', scoreBoost: 30, priority: 4, enabled: true},\n        {id: 'versatile_services', name: 'Versatile Services', description: 'Residential and commercial', condition: 'signals.some(s => s.signalId === \"commercial_title\")', scoreBoost: 18, priority: 5, enabled: true},\n        {id: 'speed_service', name: 'Speed Service', description: 'Fast turnaround with high volume', condition: 'signals.some(s => s.signalId === \"fast_turnaround\") && signals.some(s => s.signalId === \"transaction_volume\")', scoreBoost: 25, priority: 6, enabled: true},\n        {id: 'builder_partner', name: 'Builder Partner', description: 'Builder services with volume', condition: 'signals.some(s => s.signalId === \"builder_services\") && signals.some(s => s.signalId === \"transaction_volume\")', scoreBoost: 20, priority: 7, enabled: true},\n        {id: 'exchange_specialist', name: '1031 Exchange Specialist', description: '1031 services with commercial title', condition: 'signals.some(s => s.signalId === \"1031_exchange\") && signals.some(s => s.signalId === \"commercial_title\")', scoreBoost: 22, priority: 8, enabled: true},\n        {id: 'convenience_focused', name: 'Convenience-Focused', description: 'Mobile and online closing', condition: 'signals.some(s => s.signalId === \"mobile_closing\") && signals.some(s => s.signalId === \"online_closing\")', scoreBoost: 18, priority: 9, enabled: true},\n        {id: 'recognized_company', name: 'Recognized Company', description: 'Awards with high volume', condition: 'signals.some(s => s.signalId === \"awards\") && signals.some(s => s.signalId === \"transaction_volume\")', scoreBoost: 25, priority: 10, enabled: true}\n      ],\n\n      customFields: [\n        {key: 'annual_transactions', label: 'Annual Transactions', type: 'number', description: 'Yearly closing volume', extractionHints: ['transactions', 'closings', 'files'], required: false, defaultValue: 0},\n        {key: 'states_licensed', label: 'States Licensed', type: 'number', description: 'Multi-state presence', extractionHints: ['states', 'licensed in'], required: false, defaultValue: 1},\n        {key: 'office_count', label: 'Office Locations', type: 'number', description: 'Number of offices', extractionHints: ['offices', 'locations'], required: false, defaultValue: 1},\n        {key: 'has_online_closing', label: 'Offers Online Closing', type: 'boolean', description: 'Remote closing available', extractionHints: ['online', 'remote', 'e-closing'], required: false, defaultValue: false},\n        {key: 'has_wire_protection', label: 'Wire Fraud Protection', type: 'boolean', description: 'Advanced security', extractionHints: ['wire fraud', 'security'], required: false, defaultValue: false},\n        {key: 'avg_turnaround_days', label: 'Average Turnaround (Days)', type: 'number', description: 'Typical closing time', extractionHints: ['days', 'turnaround', 'closing time'], required: false, defaultValue: 30},\n        {key: 'specialization', label: 'Market Focus', type: 'string', description: 'Primary market', extractionHints: ['residential', 'commercial', 'refinance'], required: false, defaultValue: 'residential'}\n      ],\n\n      metadata: {\n        lastUpdated: '2025-12-29',\n        version: 1,\n        updatedBy: 'system',\n        notes: 'Title & escrow intelligence - focuses on transaction volume, security features, service speed, and geographic reach'\n      }\n    }\n  },\n  \n  // ============================================\n};\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\David\\PycharmProjects\\AI Sales Platform\\src\\lib\\scraper-intelligence\\scraper-queue.ts","messages":[{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":420,"column":9,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":420,"endColumn":67}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Scraper Queue\r\n * \r\n * Priority-based job queue for managing concurrent scrape operations.\r\n * Implements efficient job scheduling with priority handling.\r\n * \r\n * Features:\r\n * - Priority-based job scheduling\r\n * - Job status tracking\r\n * - Queue statistics\r\n * - Job cancellation\r\n * - Automatic cleanup of completed jobs\r\n */\r\n\r\nimport { logger } from '@/lib/logger/logger';\r\nimport type {\r\n  JobQueue,\r\n  ScrapeJobConfig,\r\n  ScrapeJobResult,\r\n  ScrapeJobStatus,\r\n  ScrapeJobPriority,\r\n  QueueStats,\r\n} from './scraper-runner-types';\r\nimport { generateJobId } from './scraper-runner-types';\r\n\r\n// ============================================================================\r\n// CONSTANTS\r\n// ============================================================================\r\n\r\nconst PRIORITY_ORDER: Record<ScrapeJobPriority, number> = {\r\n  urgent: 0,\r\n  high: 1,\r\n  normal: 2,\r\n  low: 3,\r\n};\r\n\r\nconst MAX_COMPLETED_HISTORY = 1000; // Keep last 1000 completed jobs\r\nconst CLEANUP_INTERVAL_MS = 5 * 60 * 1000; // Cleanup every 5 minutes\r\n\r\n// ============================================================================\r\n// TYPES\r\n// ============================================================================\r\n\r\n/**\r\n * Internal job representation\r\n */\r\ninterface QueuedJob {\r\n  config: ScrapeJobConfig;\r\n  result: ScrapeJobResult;\r\n  enqueuedAt: Date;\r\n  priority: number; // Numeric priority for sorting\r\n}\r\n\r\n// ============================================================================\r\n// IMPLEMENTATION\r\n// ============================================================================\r\n\r\n/**\r\n * In-memory priority queue for scrape jobs\r\n */\r\nexport class InMemoryScrapeQueue implements JobQueue {\r\n  private jobs = new Map<string, QueuedJob>();\r\n  private pendingQueue: string[] = []; // Job IDs in priority order\r\n  private cleanupTimer?: NodeJS.Timeout;\r\n  \r\n  // Statistics tracking\r\n  private stats = {\r\n    totalEnqueued: 0,\r\n    totalCompleted: 0,\r\n    totalFailed: 0,\r\n    totalCancelled: 0,\r\n    totalWaitTimeMs: 0,\r\n    totalExecutionTimeMs: 0,\r\n  };\r\n\r\n  constructor(\r\n    private readonly maxWorkers: number = 5\r\n  ) {\r\n    this.startCleanup();\r\n  }\r\n\r\n  /**\r\n   * Add a job to the queue\r\n   */\r\n  async enqueue(config: ScrapeJobConfig): Promise<void> {\r\n    const jobId = config.jobId;\r\n    const enqueuedAt = new Date();\r\n    const priority = PRIORITY_ORDER[config.priority] || PRIORITY_ORDER.normal;\r\n\r\n    // Create initial result\r\n    const result: ScrapeJobResult = {\r\n      config,\r\n      status: 'pending',\r\n      startedAt: enqueuedAt,\r\n    };\r\n\r\n    const job: QueuedJob = {\r\n      config,\r\n      result,\r\n      enqueuedAt,\r\n      priority,\r\n    };\r\n\r\n    // Add to jobs map\r\n    this.jobs.set(jobId, job);\r\n\r\n    // Add to pending queue in priority order\r\n    this.insertIntoPriorityQueue(jobId, priority);\r\n\r\n    this.stats.totalEnqueued++;\r\n\r\n    logger.debug('Job enqueued', {\r\n      jobId,\r\n      url: config.url,\r\n      priority: config.priority,\r\n      queuePosition: this.pendingQueue.indexOf(jobId),\r\n      queueSize: this.pendingQueue.length,\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Get next job to process\r\n   * \r\n   * Returns the highest priority pending job, or null if queue is empty\r\n   */\r\n  async dequeue(): Promise<ScrapeJobConfig | null> {\r\n    if (this.pendingQueue.length === 0) {\r\n      return null;\r\n    }\r\n\r\n    // Get highest priority job (first in queue)\r\n    const jobId = this.pendingQueue.shift();\r\n    if (!jobId) {\r\n      return null;\r\n    }\r\n\r\n    const job = this.jobs.get(jobId);\r\n    if (!job) {\r\n      logger.error('Job not found in map', { jobId });\r\n      return null;\r\n    }\r\n\r\n    // Update status to running\r\n    job.result.status = 'running';\r\n    job.result.startedAt = new Date();\r\n\r\n    logger.debug('Job dequeued', {\r\n      jobId,\r\n      url: job.config.url,\r\n      priority: job.config.priority,\r\n      waitTimeMs: job.result.startedAt.getTime() - job.enqueuedAt.getTime(),\r\n    });\r\n\r\n    return job.config;\r\n  }\r\n\r\n  /**\r\n   * Get job by ID\r\n   */\r\n  async getJob(jobId: string): Promise<ScrapeJobResult | null> {\r\n    const job = this.jobs.get(jobId);\r\n    return job ? job.result : null;\r\n  }\r\n\r\n  /**\r\n   * Update job result\r\n   */\r\n  async updateJob(jobId: string, updates: Partial<ScrapeJobResult>): Promise<void> {\r\n    const job = this.jobs.get(jobId);\r\n    \r\n    if (!job) {\r\n      logger.warn('Cannot update non-existent job', { jobId });\r\n      return;\r\n    }\r\n\r\n    // Merge updates\r\n    Object.assign(job.result, updates);\r\n\r\n    // Update statistics based on status\r\n    if (updates.status) {\r\n      this.updateStats(job, updates.status);\r\n    }\r\n\r\n    logger.debug('Job updated', {\r\n      jobId,\r\n      status: job.result.status,\r\n      updates: Object.keys(updates),\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Mark job as completed\r\n   */\r\n  async completeJob(\r\n    jobId: string,\r\n    result: Omit<ScrapeJobResult, 'config' | 'status' | 'startedAt'>\r\n  ): Promise<void> {\r\n    const job = this.jobs.get(jobId);\r\n    \r\n    if (!job) {\r\n      logger.warn('Cannot complete non-existent job', { jobId });\r\n      return;\r\n    }\r\n\r\n    const completedAt = new Date();\r\n    const durationMs = completedAt.getTime() - job.result.startedAt.getTime();\r\n\r\n    await this.updateJob(jobId, {\r\n      ...result,\r\n      status: 'completed',\r\n      completedAt,\r\n      durationMs,\r\n    });\r\n\r\n    logger.info('Job completed', {\r\n      jobId,\r\n      url: job.config.url,\r\n      durationMs,\r\n      signalCount: result.signals?.length || 0,\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Mark job as failed\r\n   */\r\n  async failJob(jobId: string, error: Error, attemptNumber: number): Promise<void> {\r\n    const job = this.jobs.get(jobId);\r\n    \r\n    if (!job) {\r\n      logger.warn('Cannot fail non-existent job', { jobId });\r\n      return;\r\n    }\r\n\r\n    const completedAt = new Date();\r\n    const durationMs = completedAt.getTime() - job.result.startedAt.getTime();\r\n\r\n    await this.updateJob(jobId, {\r\n      status: 'failed',\r\n      completedAt,\r\n      durationMs,\r\n      error: {\r\n        message: error.message,\r\n        code: (error as any).code || 'UNKNOWN_ERROR',\r\n        attemptNumber,\r\n        timestamp: new Date(),\r\n      },\r\n    });\r\n\r\n    logger.error('Job failed', error, {\r\n      jobId,\r\n      url: job.config.url,\r\n      attemptNumber,\r\n      durationMs,\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Cancel a job\r\n   */\r\n  async cancelJob(jobId: string): Promise<boolean> {\r\n    const job = this.jobs.get(jobId);\r\n    \r\n    if (!job) {\r\n      return false;\r\n    }\r\n\r\n    // Can only cancel pending jobs\r\n    if (job.result.status !== 'pending') {\r\n      logger.warn('Cannot cancel non-pending job', {\r\n        jobId,\r\n        status: job.result.status,\r\n      });\r\n      return false;\r\n    }\r\n\r\n    // Remove from pending queue\r\n    const index = this.pendingQueue.indexOf(jobId);\r\n    if (index !== -1) {\r\n      this.pendingQueue.splice(index, 1);\r\n    }\r\n\r\n    // Update status\r\n    await this.updateJob(jobId, {\r\n      status: 'cancelled',\r\n      completedAt: new Date(),\r\n    });\r\n\r\n    logger.info('Job cancelled', { jobId, url: job.config.url });\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Get queue statistics\r\n   */\r\n  getStats(): QueueStats {\r\n    const byStatus: Record<ScrapeJobStatus, number> = {\r\n      pending: 0,\r\n      running: 0,\r\n      completed: 0,\r\n      failed: 0,\r\n      cancelled: 0,\r\n      cached: 0,\r\n    };\r\n\r\n    const byPriority: Record<ScrapeJobPriority, number> = {\r\n      urgent: 0,\r\n      high: 0,\r\n      normal: 0,\r\n      low: 0,\r\n    };\r\n\r\n    let runningCount = 0;\r\n\r\n    for (const job of this.jobs.values()) {\r\n      byStatus[job.result.status]++;\r\n      byPriority[job.config.priority]++;\r\n      \r\n      if (job.result.status === 'running') {\r\n        runningCount++;\r\n      }\r\n    }\r\n\r\n    const avgWaitTimeMs = this.stats.totalEnqueued > 0\r\n      ? this.stats.totalWaitTimeMs / this.stats.totalEnqueued\r\n      : 0;\r\n\r\n    const avgExecutionTimeMs = this.stats.totalCompleted > 0\r\n      ? this.stats.totalExecutionTimeMs / this.stats.totalCompleted\r\n      : 0;\r\n\r\n    const utilization = this.maxWorkers > 0\r\n      ? runningCount / this.maxWorkers\r\n      : 0;\r\n\r\n    return {\r\n      total: this.jobs.size,\r\n      byStatus,\r\n      byPriority,\r\n      avgWaitTimeMs,\r\n      avgExecutionTimeMs,\r\n      utilization,\r\n      activeWorkers: runningCount,\r\n      maxWorkers: this.maxWorkers,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Get all pending jobs\r\n   */\r\n  getPendingJobs(): ScrapeJobConfig[] {\r\n    return this.pendingQueue\r\n      .map(jobId => this.jobs.get(jobId))\r\n      .filter((job): job is QueuedJob => job !== undefined)\r\n      .map(job => job.config);\r\n  }\r\n\r\n  /**\r\n   * Get all running jobs\r\n   */\r\n  getRunningJobs(): ScrapeJobConfig[] {\r\n    return Array.from(this.jobs.values())\r\n      .filter(job => job.result.status === 'running')\r\n      .map(job => job.config);\r\n  }\r\n\r\n  /**\r\n   * Clear all jobs\r\n   */\r\n  clear(): void {\r\n    this.jobs.clear();\r\n    this.pendingQueue = [];\r\n    logger.info('Queue cleared');\r\n  }\r\n\r\n  /**\r\n   * Shutdown and cleanup\r\n   */\r\n  shutdown(): void {\r\n    if (this.cleanupTimer) {\r\n      clearInterval(this.cleanupTimer);\r\n      this.cleanupTimer = undefined;\r\n    }\r\n    this.clear();\r\n  }\r\n\r\n  // ==========================================================================\r\n  // PRIVATE METHODS\r\n  // ==========================================================================\r\n\r\n  /**\r\n   * Insert job into priority queue maintaining sort order\r\n   */\r\n  private insertIntoPriorityQueue(jobId: string, priority: number): void {\r\n    // Find insertion point (binary search would be more efficient for large queues)\r\n    let insertIndex = this.pendingQueue.length;\r\n    \r\n    for (let i = 0; i < this.pendingQueue.length; i++) {\r\n      const existingJobId = this.pendingQueue[i];\r\n      const existingJob = this.jobs.get(existingJobId);\r\n      \r\n      if (existingJob && existingJob.priority > priority) {\r\n        insertIndex = i;\r\n        break;\r\n      }\r\n    }\r\n\r\n    this.pendingQueue.splice(insertIndex, 0, jobId);\r\n  }\r\n\r\n  /**\r\n   * Update statistics based on job status change\r\n   */\r\n  private updateStats(job: QueuedJob, newStatus: ScrapeJobStatus): void {\r\n    const now = new Date();\r\n\r\n    switch (newStatus) {\r\n      case 'running':\r\n        // Calculate wait time\r\n        const waitTime = now.getTime() - job.enqueuedAt.getTime();\r\n        this.stats.totalWaitTimeMs += waitTime;\r\n        break;\r\n\r\n      case 'completed':\r\n        this.stats.totalCompleted++;\r\n        if (job.result.durationMs) {\r\n          this.stats.totalExecutionTimeMs += job.result.durationMs;\r\n        }\r\n        break;\r\n\r\n      case 'failed':\r\n        this.stats.totalFailed++;\r\n        if (job.result.durationMs) {\r\n          this.stats.totalExecutionTimeMs += job.result.durationMs;\r\n        }\r\n        break;\r\n\r\n      case 'cancelled':\r\n        this.stats.totalCancelled++;\r\n        break;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Start periodic cleanup of old completed jobs\r\n   */\r\n  private startCleanup(): void {\r\n    this.cleanupTimer = setInterval(() => {\r\n      this.cleanupOldJobs();\r\n    }, CLEANUP_INTERVAL_MS);\r\n\r\n    // Don't keep the process alive just for cleanup\r\n    if (this.cleanupTimer.unref) {\r\n      this.cleanupTimer.unref();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Remove old completed/failed/cancelled jobs\r\n   */\r\n  private cleanupOldJobs(): void {\r\n    const completedJobs: Array<{ jobId: string; completedAt: Date }> = [];\r\n\r\n    for (const [jobId, job] of this.jobs.entries()) {\r\n      if (\r\n        job.result.status === 'completed' ||\r\n        job.result.status === 'failed' ||\r\n        job.result.status === 'cancelled'\r\n      ) {\r\n        if (job.result.completedAt) {\r\n          completedJobs.push({ jobId, completedAt: job.result.completedAt });\r\n        }\r\n      }\r\n    }\r\n\r\n    // Sort by completion time (oldest first)\r\n    completedJobs.sort((a, b) => a.completedAt.getTime() - b.completedAt.getTime());\r\n\r\n    // Remove oldest jobs if over limit\r\n    const toRemove = Math.max(0, completedJobs.length - MAX_COMPLETED_HISTORY);\r\n    let removedCount = 0;\r\n\r\n    for (let i = 0; i < toRemove; i++) {\r\n      const jobId = completedJobs[i].jobId;\r\n      this.jobs.delete(jobId);\r\n      removedCount++;\r\n    }\r\n\r\n    if (removedCount > 0) {\r\n      logger.debug('Queue cleanup completed', {\r\n        removedJobs: removedCount,\r\n        remainingJobs: this.jobs.size,\r\n      });\r\n    }\r\n  }\r\n}\r\n\r\n// ============================================================================\r\n// FACTORY\r\n// ============================================================================\r\n\r\n/**\r\n * Create a new scrape queue\r\n */\r\nexport function createScrapeQueue(maxWorkers?: number): JobQueue {\r\n  return new InMemoryScrapeQueue(maxWorkers);\r\n}\r\n\r\n// ============================================================================\r\n// UTILITIES\r\n// ============================================================================\r\n\r\n/**\r\n * Calculate job priority based on various factors\r\n */\r\nexport function calculateJobPriority(config: ScrapeJobConfig): ScrapeJobPriority {\r\n  // If explicitly set, use that\r\n  if (config.priority) {\r\n    return config.priority;\r\n  }\r\n\r\n  // Otherwise, calculate based on factors\r\n  let score = 0;\r\n\r\n  // Factor 1: Platform urgency\r\n  const platformScores: Partial<Record<string, number>> = {\r\n    'news': 3,           // Time-sensitive\r\n    'social-media': 2,   // Moderately time-sensitive\r\n    'website': 1,        // Standard\r\n    'dns': -1,           // Can be delayed\r\n  };\r\n  score += platformScores[config.platform] || 0;\r\n\r\n  // Factor 2: Organization priority (could be added later)\r\n  // score += organizationPriorityScore;\r\n\r\n  // Map score to priority\r\n  if (score >= 3) return 'urgent';\r\n  if (score >= 1) return 'high';\r\n  if (score <= -1) return 'low';\r\n  return 'normal';\r\n}\r\n\r\n/**\r\n * Validate job configuration\r\n */\r\nexport function validateJobConfig(config: ScrapeJobConfig): {\r\n  valid: boolean;\r\n  errors: string[];\r\n} {\r\n  const errors: string[] = [];\r\n\r\n  if (!config.jobId) {\r\n    errors.push('Job ID is required');\r\n  }\r\n\r\n  if (!config.organizationId) {\r\n    errors.push('Organization ID is required');\r\n  }\r\n\r\n  if (!config.industryId) {\r\n    errors.push('Industry ID is required');\r\n  }\r\n\r\n  if (!config.url) {\r\n    errors.push('URL is required');\r\n  }\r\n\r\n  if (!config.platform) {\r\n    errors.push('Platform is required');\r\n  }\r\n\r\n  // Validate URL format\r\n  if (config.url) {\r\n    try {\r\n      new URL(config.url);\r\n    } catch {\r\n      errors.push('Invalid URL format');\r\n    }\r\n  }\r\n\r\n  return {\r\n    valid: errors.length === 0,\r\n    errors,\r\n  };\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\David\\PycharmProjects\\AI Sales Platform\\src\\lib\\scraper-intelligence\\scraper-runner.ts","messages":[{"ruleId":"no-constant-condition","severity":2,"message":"Unexpected constant condition.","line":209,"column":12,"nodeType":"Literal","messageId":"unexpected","endLine":209,"endColumn":16}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Scraper Runner\r\n * \r\n * Main orchestration engine for intelligent web scraping across all 49 industry templates.\r\n * Coordinates caching, rate limiting, queue management, and progress tracking.\r\n * \r\n * Features:\r\n * - Multi-template scraping orchestration\r\n * - Intelligent caching (5-minute default TTL)\r\n * - Domain-based rate limiting\r\n * - Priority-based job queue\r\n * - Real-time progress tracking\r\n * - Automatic retry with exponential backoff\r\n * - Concurrent scrape management\r\n */\r\n\r\nimport { logger } from '@/lib/logger/logger';\r\nimport { processAndStoreScrape } from './scraper-intelligence-service';\r\nimport { getIndustryTemplate } from '@/lib/persona/industry-templates';\r\nimport type {\r\n  ScraperRunner,\r\n  ScraperRunnerConfig,\r\n  ScrapeJobConfig,\r\n  ScrapeJobResult,\r\n  ScrapeCache,\r\n  DomainRateLimiter,\r\n  JobQueue,\r\n  ProgressTracker,\r\n  ErrorHandler,\r\n  QueueStats,\r\n  CacheStats,\r\n} from './scraper-runner-types';\r\nimport {\r\n  DEFAULT_RUNNER_CONFIG,\r\n  extractDomain,\r\n  generateJobId,\r\n  ScrapeError,\r\n} from './scraper-runner-types';\r\nimport { createScrapeCache, getScrapeCacheKey, calculateCacheTTL } from './scraper-cache';\r\nimport { createDomainRateLimiter } from './domain-rate-limiter';\r\nimport { createScrapeQueue, validateJobConfig } from './scraper-queue';\r\nimport { createProgressTracker, createProgressEvent, formatProgressMessage } from './progress-tracker';\r\nimport { createErrorHandler, withRetry, withTimeout, logError } from './error-handler';\r\n\r\n// ============================================================================\r\n// IMPLEMENTATION\r\n// ============================================================================\r\n\r\n/**\r\n * Production-ready scraper runner implementation\r\n */\r\nexport class ProductionScraperRunner implements ScraperRunner {\r\n  private cache: ScrapeCache;\r\n  private rateLimiter: DomainRateLimiter;\r\n  private queue: JobQueue;\r\n  private progressTracker: ProgressTracker;\r\n  private errorHandler: ErrorHandler;\r\n  private config: ScraperRunnerConfig;\r\n  private running = false;\r\n  private activeWorkers = 0;\r\n  private shutdownSignal = false;\r\n\r\n  // Statistics\r\n  private stats = {\r\n    completedJobs: 0,\r\n    failedJobs: 0,\r\n    cachedJobs: 0,\r\n  };\r\n\r\n  constructor(config: Partial<ScraperRunnerConfig> = {}) {\r\n    this.config = { ...DEFAULT_RUNNER_CONFIG, ...config };\r\n\r\n    // Initialize components\r\n    this.cache = createScrapeCache(1000, this.config.cacheTtlMs);\r\n    this.rateLimiter = createDomainRateLimiter(this.config.rateLimitConfig);\r\n    this.queue = createScrapeQueue(this.config.maxConcurrent);\r\n    this.progressTracker = createProgressTracker();\r\n    this.errorHandler = createErrorHandler(this.config.retryStrategy);\r\n\r\n    logger.info('Scraper Runner initialized', {\r\n      maxConcurrent: this.config.maxConcurrent,\r\n      cacheTtlMs: this.config.cacheTtlMs,\r\n      enableCaching: this.config.enableCaching,\r\n      enableProgressTracking: this.config.enableProgressTracking,\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Submit a scrape job\r\n   */\r\n  async submitJob(config: ScrapeJobConfig): Promise<string> {\r\n    // Validate configuration\r\n    const validation = validateJobConfig(config);\r\n    if (!validation.valid) {\r\n      throw new ScrapeError(\r\n        `Invalid job configuration: ${validation.errors.join(', ')}`,\r\n        'validation_error',\r\n        400,\r\n        false,\r\n        { errors: validation.errors }\r\n      );\r\n    }\r\n\r\n    // Generate job ID if not provided\r\n    if (!config.jobId) {\r\n      config.jobId = generateJobId();\r\n    }\r\n\r\n    // Set defaults\r\n    const jobConfig: ScrapeJobConfig = {\r\n      ...config,\r\n      priority: config.priority || 'normal',\r\n      maxRetries: config.maxRetries ?? this.config.retryStrategy.maxAttempts,\r\n      timeoutMs: config.timeoutMs ?? this.config.defaultTimeoutMs,\r\n      skipCache: config.skipCache ?? false,\r\n    };\r\n\r\n    // Add to queue\r\n    await this.queue.enqueue(jobConfig);\r\n\r\n    // Emit progress event\r\n    if (this.config.enableProgressTracking) {\r\n      this.progressTracker.emit(createProgressEvent(\r\n        jobConfig.jobId,\r\n        'job_queued',\r\n        formatProgressMessage('job_queued', jobConfig.url),\r\n        0\r\n      ));\r\n    }\r\n\r\n    // Start processing if not already running\r\n    if (!this.running) {\r\n      this.startProcessing();\r\n    }\r\n\r\n    logger.info('Job submitted', {\r\n      jobId: jobConfig.jobId,\r\n      url: jobConfig.url,\r\n      priority: jobConfig.priority,\r\n      organizationId: jobConfig.organizationId,\r\n    });\r\n\r\n    return jobConfig.jobId;\r\n  }\r\n\r\n  /**\r\n   * Submit multiple jobs in batch\r\n   */\r\n  async submitBatch(configs: ScrapeJobConfig[]): Promise<string[]> {\r\n    const jobIds: string[] = [];\r\n\r\n    for (const config of configs) {\r\n      try {\r\n        const jobId = await this.submitJob(config);\r\n        jobIds.push(jobId);\r\n      } catch (error) {\r\n        logger.error('Failed to submit batch job', error as Error, {\r\n          url: config.url,\r\n        });\r\n        // Continue with other jobs\r\n      }\r\n    }\r\n\r\n    logger.info('Batch submitted', {\r\n      totalJobs: configs.length,\r\n      submittedJobs: jobIds.length,\r\n      failedJobs: configs.length - jobIds.length,\r\n    });\r\n\r\n    return jobIds;\r\n  }\r\n\r\n  /**\r\n   * Get job result\r\n   */\r\n  async getJobResult(jobId: string): Promise<ScrapeJobResult | null> {\r\n    return this.queue.getJob(jobId);\r\n  }\r\n\r\n  /**\r\n   * Cancel a job\r\n   */\r\n  async cancelJob(jobId: string): Promise<boolean> {\r\n    const cancelled = await this.queue.cancelJob(jobId);\r\n\r\n    if (cancelled && this.config.enableProgressTracking) {\r\n      const result = await this.queue.getJob(jobId);\r\n      if (result) {\r\n        this.progressTracker.emit(createProgressEvent(\r\n          jobId,\r\n          'job_cancelled',\r\n          formatProgressMessage('job_cancelled', result.config.url)\r\n        ));\r\n      }\r\n    }\r\n\r\n    return cancelled;\r\n  }\r\n\r\n  /**\r\n   * Wait for job completion\r\n   */\r\n  async waitForJob(\r\n    jobId: string,\r\n    timeoutMs: number = 60000\r\n  ): Promise<ScrapeJobResult> {\r\n    const startTime = Date.now();\r\n\r\n    while (true) {\r\n      const result = await this.queue.getJob(jobId);\r\n\r\n      if (!result) {\r\n        throw new ScrapeError(\r\n          `Job not found: ${jobId}`,\r\n          'validation_error',\r\n          404,\r\n          false\r\n        );\r\n      }\r\n\r\n      // Check if completed\r\n      if (\r\n        result.status === 'completed' ||\r\n        result.status === 'failed' ||\r\n        result.status === 'cancelled' ||\r\n        result.status === 'cached'\r\n      ) {\r\n        return result;\r\n      }\r\n\r\n      // Check timeout\r\n      if (Date.now() - startTime > timeoutMs) {\r\n        throw new ScrapeError(\r\n          `Timeout waiting for job ${jobId}`,\r\n          'timeout_error',\r\n          408,\r\n          false\r\n        );\r\n      }\r\n\r\n      // Wait before checking again\r\n      await new Promise(resolve => setTimeout(resolve, 100));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get runner statistics\r\n   */\r\n  getStats(): {\r\n    queue: QueueStats;\r\n    cache: CacheStats;\r\n    activeJobs: number;\r\n    completedJobs: number;\r\n    failedJobs: number;\r\n  } {\r\n    return {\r\n      queue: this.queue.getStats(),\r\n      cache: this.cache.getStats(),\r\n      activeJobs: this.activeWorkers,\r\n      completedJobs: this.stats.completedJobs,\r\n      failedJobs: this.stats.failedJobs,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Shutdown runner gracefully\r\n   */\r\n  async shutdown(): Promise<void> {\r\n    logger.info('Shutting down scraper runner...');\r\n    this.shutdownSignal = true;\r\n\r\n    // Wait for active workers to complete (max 30 seconds)\r\n    const shutdownTimeout = 30000;\r\n    const startTime = Date.now();\r\n\r\n    while (this.activeWorkers > 0 && Date.now() - startTime < shutdownTimeout) {\r\n      await new Promise(resolve => setTimeout(resolve, 100));\r\n    }\r\n\r\n    // Shutdown components\r\n    this.cache.clear();\r\n    this.progressTracker.shutdown();\r\n    this.rateLimiter.shutdown();\r\n    this.queue.shutdown();\r\n\r\n    logger.info('Scraper runner shut down', {\r\n      activeWorkersRemaining: this.activeWorkers,\r\n    });\r\n  }\r\n\r\n  // ==========================================================================\r\n  // PRIVATE METHODS - PROCESSING\r\n  // ==========================================================================\r\n\r\n  /**\r\n   * Start job processing loop\r\n   */\r\n  private async startProcessing(): Promise<void> {\r\n    if (this.running) {\r\n      return;\r\n    }\r\n\r\n    this.running = true;\r\n    logger.info('Starting job processing');\r\n\r\n    // Start worker loops\r\n    const workers: Promise<void>[] = [];\r\n    for (let i = 0; i < this.config.maxConcurrent; i++) {\r\n      workers.push(this.workerLoop(i));\r\n    }\r\n\r\n    // Wait for all workers (they run until shutdown)\r\n    await Promise.all(workers);\r\n\r\n    this.running = false;\r\n    logger.info('Job processing stopped');\r\n  }\r\n\r\n  /**\r\n   * Worker loop for processing jobs\r\n   */\r\n  private async workerLoop(workerId: number): Promise<void> {\r\n    logger.debug('Worker started', { workerId });\r\n\r\n    while (!this.shutdownSignal) {\r\n      try {\r\n        // Get next job\r\n        const jobConfig = await this.queue.dequeue();\r\n\r\n        if (!jobConfig) {\r\n          // No jobs available, wait before checking again\r\n          await new Promise(resolve => setTimeout(resolve, 1000));\r\n          continue;\r\n        }\r\n\r\n        // Process job\r\n        this.activeWorkers++;\r\n        await this.processJob(jobConfig);\r\n        this.activeWorkers--;\r\n\r\n      } catch (error) {\r\n        logger.error('Worker loop error', error as Error, { workerId });\r\n        this.activeWorkers = Math.max(0, this.activeWorkers - 1);\r\n      }\r\n    }\r\n\r\n    logger.debug('Worker stopped', { workerId });\r\n  }\r\n\r\n  /**\r\n   * Process a single job\r\n   */\r\n  private async processJob(config: ScrapeJobConfig): Promise<void> {\r\n    const { jobId, url, organizationId, industryId, platform } = config;\r\n\r\n    logger.info('Processing job', { jobId, url, organizationId, industryId });\r\n\r\n    // Emit started event\r\n    if (this.config.enableProgressTracking) {\r\n      this.progressTracker.emit(createProgressEvent(\r\n        jobId,\r\n        'job_started',\r\n        formatProgressMessage('job_started', url),\r\n        10\r\n      ));\r\n    }\r\n\r\n    try {\r\n      // Step 1: Check cache (if enabled)\r\n      if (this.config.enableCaching && !config.skipCache) {\r\n        const cached = await this.checkCache(config);\r\n        if (cached) {\r\n          await this.queue.completeJob(jobId, {\r\n            signals: cached.signals,\r\n            leadScore: cached.leadScore,\r\n            tempScrapeId: cached.tempScrapeId,\r\n            cached: true,\r\n            cacheAgeMs: cached.cacheAgeMs,\r\n            storageReduction: cached.storageReduction,\r\n          });\r\n\r\n          this.stats.cachedJobs++;\r\n          this.stats.completedJobs++;\r\n\r\n          if (this.config.enableProgressTracking) {\r\n            this.progressTracker.emit(createProgressEvent(\r\n              jobId,\r\n              'job_cached',\r\n              formatProgressMessage('job_cached', url),\r\n              100\r\n            ));\r\n          }\r\n\r\n          return;\r\n        }\r\n      }\r\n\r\n      // Step 2: Wait for rate limit slot\r\n      const domain = extractDomain(url);\r\n      await this.rateLimiter.waitForSlot(domain);\r\n\r\n      // Step 3: Execute scrape with retry logic\r\n      const result = await withRetry(\r\n        () => withTimeout(\r\n          () => this.executeScrape(config),\r\n          config.timeoutMs!,\r\n          `Scrape timeout for ${url}`\r\n        ),\r\n        this.errorHandler,\r\n        config.maxRetries\r\n      );\r\n\r\n      // Step 4: Cache result (if enabled)\r\n      if (this.config.enableCaching) {\r\n        const ttl = calculateCacheTTL(platform);\r\n        const cacheKey = getScrapeCacheKey(url, platform, organizationId);\r\n        \r\n        const resultToCache: ScrapeJobResult = {\r\n          config,\r\n          status: 'completed',\r\n          startedAt: new Date(),\r\n          completedAt: new Date(),\r\n          ...result,\r\n        };\r\n\r\n        await this.cache.set(cacheKey, resultToCache, ttl);\r\n      }\r\n\r\n      // Step 5: Mark job as completed\r\n      await this.queue.completeJob(jobId, result);\r\n      this.stats.completedJobs++;\r\n\r\n      if (this.config.enableProgressTracking) {\r\n        this.progressTracker.emit(createProgressEvent(\r\n          jobId,\r\n          'job_completed',\r\n          formatProgressMessage('job_completed', url),\r\n          100,\r\n          { signalCount: result.signals?.length || 0 }\r\n        ));\r\n      }\r\n\r\n      logger.info('Job completed successfully', {\r\n        jobId,\r\n        url,\r\n        signalCount: result.signals?.length || 0,\r\n        leadScore: result.leadScore,\r\n      });\r\n\r\n    } catch (error) {\r\n      await this.handleJobError(config, error as Error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Check cache for existing result\r\n   */\r\n  private async checkCache(config: ScrapeJobConfig): Promise<{\r\n    signals: any[];\r\n    leadScore: number;\r\n    tempScrapeId: string;\r\n    cacheAgeMs: number;\r\n    storageReduction?: any;\r\n  } | null> {\r\n    const { url, platform, organizationId } = config;\r\n    const cacheKey = getScrapeCacheKey(url, platform, organizationId);\r\n\r\n    const cached = await this.cache.get(cacheKey);\r\n\r\n    if (cached) {\r\n      const ageMs = Date.now() - cached.cachedAt.getTime();\r\n      \r\n      logger.info('Cache hit', {\r\n        url,\r\n        ageMs,\r\n        hits: cached.hits,\r\n      });\r\n\r\n      return {\r\n        signals: cached.result.signals || [],\r\n        leadScore: cached.result.leadScore || 0,\r\n        tempScrapeId: cached.result.tempScrapeId || '',\r\n        cacheAgeMs: ageMs,\r\n        storageReduction: cached.result.storageReduction,\r\n      };\r\n    }\r\n\r\n    logger.debug('Cache miss', { url });\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Execute the actual scrape operation\r\n   */\r\n  private async executeScrape(config: ScrapeJobConfig): Promise<{\r\n    signals: any[];\r\n    leadScore: number;\r\n    tempScrapeId: string;\r\n    storageReduction?: any;\r\n  }> {\r\n    const { url, organizationId, workspaceId, industryId, relatedRecordId, platform } = config;\r\n\r\n    // Get industry template\r\n    const template = await getIndustryTemplate(industryId);\r\n    if (!template) {\r\n      throw new ScrapeError(\r\n        `Industry template not found: ${industryId}`,\r\n        'validation_error',\r\n        404,\r\n        false,\r\n        { industryId }\r\n      );\r\n    }\r\n\r\n    // TODO: Replace with actual web scraping implementation\r\n    // For now, this is a placeholder that calls the existing service\r\n    // In production, you would:\r\n    // 1. Fetch the webpage (using puppeteer, playwright, or axios)\r\n    // 2. Extract content (convert HTML to markdown or text)\r\n    // 3. Call processAndStoreScrape with the raw content\r\n\r\n    // Placeholder scraping logic\r\n    const rawHtml = `<!DOCTYPE html><html><body>Sample content for ${url}</body></html>`;\r\n    const cleanedContent = `Sample content for ${url}`;\r\n    const metadata = {\r\n      title: 'Sample Page',\r\n      description: 'Sample description',\r\n      author: undefined,\r\n      keywords: [],\r\n    };\r\n\r\n    // Process and store the scrape\r\n    const result = await processAndStoreScrape({\r\n      organizationId,\r\n      workspaceId,\r\n      industryId,\r\n      recordId: relatedRecordId || `temp_${Date.now()}`,\r\n      url,\r\n      rawHtml,\r\n      cleanedContent,\r\n      metadata,\r\n      platform,\r\n    });\r\n\r\n    return {\r\n      signals: result.signals,\r\n      leadScore: result.leadScore,\r\n      tempScrapeId: result.tempScrapeId,\r\n      storageReduction: result.storageReduction,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Handle job error\r\n   */\r\n  private async handleJobError(config: ScrapeJobConfig, error: Error): Promise<void> {\r\n    const { jobId, url } = config;\r\n\r\n    logError(error, { jobId, url });\r\n\r\n    // Determine attempt number (from retry context if available)\r\n    const attemptNumber = (error as any).attemptNumber || 1;\r\n\r\n    // Mark job as failed\r\n    await this.queue.failJob(jobId, error, attemptNumber);\r\n    this.stats.failedJobs++;\r\n\r\n    // Emit failure event\r\n    if (this.config.enableProgressTracking) {\r\n      const formatted = this.errorHandler.formatError(error);\r\n      this.progressTracker.emit(createProgressEvent(\r\n        jobId,\r\n        'job_failed',\r\n        formatProgressMessage('job_failed', url, formatted.message),\r\n        0,\r\n        { error: formatted }\r\n      ));\r\n    }\r\n\r\n    logger.error('Job failed', error, {\r\n      jobId,\r\n      url,\r\n      attemptNumber,\r\n    });\r\n  }\r\n}\r\n\r\n// ============================================================================\r\n// FACTORY\r\n// ============================================================================\r\n\r\n/**\r\n * Create a new scraper runner instance\r\n */\r\nexport function createScraperRunner(\r\n  config?: Partial<ScraperRunnerConfig>\r\n): ScraperRunner {\r\n  return new ProductionScraperRunner(config);\r\n}\r\n\r\n// ============================================================================\r\n// SINGLETON (Optional)\r\n// ============================================================================\r\n\r\nlet globalRunner: ScraperRunner | null = null;\r\n\r\n/**\r\n * Get global scraper runner instance (singleton)\r\n */\r\nexport function getScraperRunner(\r\n  config?: Partial<ScraperRunnerConfig>\r\n): ScraperRunner {\r\n  if (!globalRunner) {\r\n    globalRunner = createScraperRunner(config);\r\n  }\r\n  return globalRunner;\r\n}\r\n\r\n/**\r\n * Reset global scraper runner (for testing)\r\n */\r\nexport function resetScraperRunner(): void {\r\n  if (globalRunner) {\r\n    globalRunner.shutdown();\r\n    globalRunner = null;\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\David\\PycharmProjects\\AI Sales Platform\\src\\lib\\services\\discovery-engine.ts","messages":[{"ruleId":"no-dupe-else-if","severity":2,"message":"This branch can never execute. Its condition is a duplicate or covered by previous conditions in the if-else-if chain.","line":791,"column":12,"nodeType":"BinaryExpression","messageId":"unexpected","endLine":791,"endColumn":42}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Native Discovery Engine\r\n * \r\n * This service is 100% native and relies on zero third-party data APIs.\r\n * \r\n * HUNTER-CLOSER COMPLIANCE:\r\n * - Replaces Clearbit, ZoomInfo, Apollo with our own scraping\r\n * - Checks discoveryArchive first (30-day cache)\r\n * - Uses BrowserController for intelligent web scraping\r\n * - LLM synthesis of raw data into structured Lead Objects\r\n * - Builds proprietary competitive moat\r\n * \r\n * Data Extraction Targets:\r\n * - Team members (About, Team pages)\r\n * - Tech stack (footer scripts, meta tags, job postings)\r\n * - Press mentions (News, Press pages)\r\n * - Contact information\r\n * - Company size indicators\r\n * - Recent activity signals\r\n */\r\n\r\nimport { logger } from '@/lib/logger/logger';\r\nimport { BrowserController, createBrowserController } from './BrowserController';\r\nimport { \r\n  saveToDiscoveryArchive, \r\n  getFromDiscoveryArchiveByHash,\r\n  calculateContentHash \r\n} from '@/lib/scraper-intelligence/discovery-archive-service';\r\nimport { sendUnifiedChatMessage } from '@/lib/ai/unified-ai-service';\r\nimport type { TemporaryScrape } from '@/types/scraper-intelligence';\r\nimport type { WorkflowState } from '@/types/workflow-state';\r\nimport { createWorkflowState } from '@/types/workflow-state';\r\nimport { getServerSignalCoordinator } from '@/lib/orchestration/coordinator-factory-server';\r\nimport { Timestamp } from 'firebase/firestore';\r\n\r\n// ============================================================================\r\n// TYPES\r\n// ============================================================================\r\n\r\nexport interface DiscoveredCompany {\r\n  domain: string;\r\n  companyName?: string;\r\n  description?: string;\r\n  industry?: string;\r\n  size?: string;\r\n  location?: string;\r\n  \r\n  // Team data\r\n  teamMembers: Array<{\r\n    name: string;\r\n    title?: string;\r\n    imageUrl?: string;\r\n    linkedinUrl?: string;\r\n    email?: string;\r\n  }>;\r\n  \r\n  // Tech stack\r\n  techStack: Array<{\r\n    name: string;\r\n    category: 'frontend' | 'backend' | 'analytics' | 'marketing' | 'infrastructure' | 'other';\r\n    confidence: number;\r\n  }>;\r\n  \r\n  // Press & news\r\n  pressmentions: Array<{\r\n    title: string;\r\n    url?: string;\r\n    date?: string;\r\n    summary?: string;\r\n  }>;\r\n  \r\n  // Contact info\r\n  contactInfo: {\r\n    email?: string;\r\n    phone?: string;\r\n    address?: string;\r\n    socialMedia?: {\r\n      linkedin?: string;\r\n      twitter?: string;\r\n      facebook?: string;\r\n    };\r\n  };\r\n  \r\n  // Signals\r\n  signals: {\r\n    isHiring: boolean;\r\n    jobCount: number;\r\n    recentActivity: boolean;\r\n    fundingStage?: string;\r\n    growthIndicators: string[];\r\n  };\r\n  \r\n  // Metadata\r\n  metadata: {\r\n    scrapedAt: Date;\r\n    expiresAt: Date;\r\n    source: 'discovery-engine';\r\n    confidence: number;\r\n  };\r\n  \r\n  // Workflow state tracking\r\n  workflow: WorkflowState;\r\n}\r\n\r\nexport interface DiscoveryResult {\r\n  company: DiscoveredCompany;\r\n  rawData: RawScrapedData;\r\n  fromCache: boolean;\r\n  scrapeId: string;\r\n}\r\n\r\nexport interface DiscoveredPerson {\r\n  email: string;\r\n  firstName?: string;\r\n  lastName?: string;\r\n  fullName?: string;\r\n  title?: string;\r\n  company?: string;\r\n  location?: string;\r\n  \r\n  // Social profiles\r\n  socialProfiles: {\r\n    linkedin?: string;\r\n    twitter?: string;\r\n    github?: string;\r\n    website?: string;\r\n  };\r\n  \r\n  // Professional data\r\n  currentRole?: {\r\n    title: string;\r\n    company: string;\r\n    startDate?: string;\r\n  };\r\n  \r\n  previousRoles?: Array<{\r\n    title: string;\r\n    company: string;\r\n    startDate?: string;\r\n    endDate?: string;\r\n  }>;\r\n  \r\n  // Skills and interests\r\n  skills?: string[];\r\n  interests?: string[];\r\n  \r\n  // Metadata\r\n  metadata: {\r\n    discoveredAt: Date;\r\n    expiresAt: Date;\r\n    source: 'person-discovery';\r\n    confidence: number;\r\n    methods: string[]; // How we found this data (e.g., 'linkedin', 'company-website', 'github')\r\n  };\r\n  \r\n  // Workflow state tracking\r\n  workflow: WorkflowState;\r\n}\r\n\r\nexport interface PersonDiscoveryResult {\r\n  person: DiscoveredPerson;\r\n  fromCache: boolean;\r\n  scrapeId: string;\r\n}\r\n\r\nexport interface RawScrapedData {\r\n  url: string;\r\n  html: string;\r\n  text: string;\r\n  highValueAreas: Array<{\r\n    type: string;\r\n    content: string;\r\n    selector: string;\r\n  }>;\r\n  links: Array<{\r\n    href: string;\r\n    text: string;\r\n    type?: string;\r\n  }>;\r\n  teamMembers: Array<any>;\r\n  techStack: Array<any>;\r\n  careerData: any;\r\n}\r\n\r\n// ============================================================================\r\n// MAIN DISCOVERY FUNCTION\r\n// ============================================================================\r\n\r\n/**\r\n * Discover company data from domain\r\n * \r\n * This is the main entry point for company discovery.\r\n * Checks 30-day cache first, then scrapes if needed.\r\n * \r\n * @param domain - Company domain (e.g., 'example.com')\r\n * @param organizationId - Organization requesting the discovery\r\n * @returns Complete discovery result with company data\r\n * \r\n * @example\r\n * ```typescript\r\n * const result = await discoverCompany('stripe.com', 'org_123');\r\n * console.log(`Found ${result.company.teamMembers.length} team members`);\r\n * console.log(`From cache: ${result.fromCache}`);\r\n * ```\r\n */\r\nexport async function discoverCompany(\r\n  domain: string,\r\n  organizationId: string\r\n): Promise<DiscoveryResult> {\r\n  try {\r\n    logger.info('Starting company discovery', {\r\n      domain,\r\n      organizationId,\r\n      source: 'native-discovery-engine',\r\n    });\r\n\r\n    // Step 1: Check discoveryArchive (30-day cache)\r\n    const cached = await checkDiscoveryArchive(domain, organizationId);\r\n    if (cached) {\r\n      logger.info('Discovery archive HIT - serving from cache', {\r\n        domain,\r\n        organizationId,\r\n        cacheAge: Date.now() - cached.scrape.createdAt.getTime(),\r\n        message: 'Cost savings achieved - no scraping needed',\r\n      });\r\n\r\n      const company = JSON.parse(cached.scrape.cleanedContent) as DiscoveredCompany;\r\n      \r\n      // Emit Signal Bus signals even for cached data (lower priority)\r\n      await emitDiscoverySignals(company, organizationId, true);\r\n\r\n      return {\r\n        company,\r\n        rawData: JSON.parse(cached.scrape.rawHtml) as RawScrapedData,\r\n        fromCache: true,\r\n        scrapeId: cached.scrape.id,\r\n      };\r\n    }\r\n\r\n    // Step 2: Cache MISS - perform native scraping\r\n    logger.info('Discovery archive MISS - initiating scrape', {\r\n      domain,\r\n      organizationId,\r\n      message: 'Building proprietary moat',\r\n    });\r\n\r\n    const rawData = await scrapeCompanyData(domain);\r\n\r\n    // Step 3: Synthesize structured data with LLM\r\n    const company = await synthesizeLeadObject(domain, rawData);\r\n\r\n    // Step 4: Save to discoveryArchive (30-day TTL)\r\n    const scrapeResult = await saveToArchive(domain, organizationId, company, rawData);\r\n\r\n    logger.info('Company discovery complete', {\r\n      domain,\r\n      organizationId,\r\n      teamMembersFound: company.teamMembers.length,\r\n      techStackFound: company.techStack.length,\r\n      fromCache: false,\r\n    });\r\n\r\n    // Emit Signal Bus signals for newly discovered data\r\n    await emitDiscoverySignals(company, organizationId, false);\r\n\r\n    return {\r\n      company,\r\n      rawData,\r\n      fromCache: false,\r\n      scrapeId: scrapeResult.scrape.id,\r\n    };\r\n  } catch (error) {\r\n    logger.error('Failed to discover company', error, {\r\n      domain,\r\n      organizationId,\r\n    });\r\n    \r\n    const errorMessage = error instanceof Error ? error.message : 'Unknown error';\r\n    throw new Error(`Failed to discover company ${domain}: ${errorMessage}`);\r\n  }\r\n}\r\n\r\n// ============================================================================\r\n// CACHE CHECKING\r\n// ============================================================================\r\n\r\n/**\r\n * Check if company data exists in discoveryArchive (30-day cache)\r\n */\r\nasync function checkDiscoveryArchive(\r\n  domain: string,\r\n  organizationId: string\r\n): Promise<{ scrape: TemporaryScrape } | null> {\r\n  try {\r\n    // We'll use URL as the cache key\r\n    const url = domain.startsWith('http') ? domain : `https://${domain}`;\r\n    const contentHash = calculateContentHash(url);\r\n\r\n    const cached = await getFromDiscoveryArchiveByHash(organizationId, contentHash);\r\n    \r\n    if (!cached) {\r\n      return null;\r\n    }\r\n\r\n    // Check if still valid (not expired)\r\n    if (cached.expiresAt < new Date()) {\r\n      logger.info('Discovery archive entry expired', {\r\n        domain,\r\n        expiresAt: cached.expiresAt,\r\n      });\r\n      return null;\r\n    }\r\n\r\n    return { scrape: cached };\r\n  } catch (error) {\r\n    logger.warn('Failed to check discovery archive', {\r\n      domain,\r\n      error: error instanceof Error ? error.message : 'Unknown error',\r\n    });\r\n    return null;\r\n  }\r\n}\r\n\r\n// ============================================================================\r\n// WEB SCRAPING\r\n// ============================================================================\r\n\r\n/**\r\n * Scrape company data using BrowserController\r\n * \r\n * Orchestrates Playwright browser to visit domain and extract data.\r\n * Uses stealth mode to avoid detection.\r\n */\r\nasync function scrapeCompanyData(domain: string): Promise<RawScrapedData> {\r\n  const controller = createBrowserController({ headless: true });\r\n  \r\n  try {\r\n    const url = domain.startsWith('http') ? domain : `https://${domain}`;\r\n    \r\n    logger.info('Starting web scrape', { domain, url });\r\n\r\n    // Navigate to domain\r\n    await controller.navigate(url);\r\n\r\n    // Extract high-value areas\r\n    const highValueAreas = await controller.identifyHighValueAreas();\r\n    \r\n    // Extract detailed data from each area\r\n    const areaContents = await Promise.all(\r\n      highValueAreas.slice(0, 10).map(async (area) => {\r\n        try {\r\n          const extracted = await controller.extractFromArea(area);\r\n          return {\r\n            type: area.type,\r\n            content: typeof extracted.content === 'string' \r\n              ? extracted.content \r\n              : JSON.stringify(extracted.content),\r\n            selector: area.selector,\r\n          };\r\n        } catch (error) {\r\n          logger.warn('Failed to extract from area', {\r\n            type: area.type,\r\n            error: error instanceof Error ? error.message : 'Unknown',\r\n          });\r\n          return null;\r\n        }\r\n      })\r\n    );\r\n\r\n    // Get links\r\n    const links = await controller.findFooterLinks();\r\n\r\n    // Get team members\r\n    const teamMembers = await controller.findTeamDirectory();\r\n\r\n    // Get tech stack\r\n    const techStack = await controller.extractTechStack();\r\n\r\n    // Get career data\r\n    const careerData = await controller.findCareerPortal();\r\n\r\n    // Get full HTML and text\r\n    const html = await controller.getContent();\r\n    const text = await controller.getTextContent();\r\n\r\n    logger.info('Web scrape complete', {\r\n      domain,\r\n      highValueAreas: areaContents.filter(a => a !== null).length,\r\n      linksFound: links.length,\r\n      teamMembersFound: teamMembers.length,\r\n      techStackFound: techStack.length,\r\n    });\r\n\r\n    return {\r\n      url,\r\n      html: html.substring(0, 100000), // Limit size\r\n      text: text.substring(0, 50000),\r\n      highValueAreas: areaContents.filter((a): a is NonNullable<typeof a> => a !== null),\r\n      links,\r\n      teamMembers,\r\n      techStack,\r\n      careerData,\r\n    };\r\n  } catch (error) {\r\n    logger.error('Failed to scrape company data', error, { domain });\r\n    throw error;\r\n  } finally {\r\n    await controller.close();\r\n  }\r\n}\r\n\r\n// ============================================================================\r\n// INDUSTRY DETECTION\r\n// ============================================================================\r\n\r\n/**\r\n * Industry-specific patterns for better data extraction\r\n */\r\nconst INDUSTRY_PATTERNS = {\r\n  saas: {\r\n    keywords: ['software', 'platform', 'api', 'cloud', 'app', 'tool', 'dashboard', 'subscription', 'saas'],\r\n    techIndicators: ['react', 'vue', 'angular', 'stripe', 'aws', 'gcp', 'azure'],\r\n    extractionFocus: ['pricing', 'features', 'integrations', 'api-docs', 'changelog'],\r\n  },\r\n  ecommerce: {\r\n    keywords: ['shop', 'store', 'cart', 'checkout', 'product', 'buy', 'price', 'shipping', 'order'],\r\n    techIndicators: ['shopify', 'woocommerce', 'magento', 'stripe', 'paypal'],\r\n    extractionFocus: ['products', 'categories', 'shipping-policy', 'return-policy'],\r\n  },\r\n  healthcare: {\r\n    keywords: ['health', 'medical', 'doctor', 'patient', 'clinic', 'hospital', 'telemedicine', 'wellness'],\r\n    techIndicators: ['hipaa', 'ehr', 'emr', 'epic', 'cerner'],\r\n    extractionFocus: ['services', 'providers', 'locations', 'insurance', 'compliance'],\r\n  },\r\n  fintech: {\r\n    keywords: ['finance', 'bank', 'payment', 'invest', 'crypto', 'blockchain', 'lending', 'insurance'],\r\n    techIndicators: ['stripe', 'plaid', 'coinbase', 'blockchain', 'encryption'],\r\n    extractionFocus: ['security', 'compliance', 'features', 'rates', 'partners'],\r\n  },\r\n  manufacturing: {\r\n    keywords: ['manufacturing', 'production', 'factory', 'industrial', 'supply chain', 'warehouse'],\r\n    techIndicators: ['iot', 'plc', 'scada', 'erp', 'mes'],\r\n    extractionFocus: ['products', 'capabilities', 'certifications', 'locations'],\r\n  },\r\n  consulting: {\r\n    keywords: ['consulting', 'advisory', 'services', 'expert', 'professional services', 'strategy'],\r\n    techIndicators: [],\r\n    extractionFocus: ['services', 'team', 'case-studies', 'clients', 'expertise'],\r\n  },\r\n  agency: {\r\n    keywords: ['agency', 'marketing', 'advertising', 'creative', 'digital', 'design', 'branding'],\r\n    techIndicators: ['adobe', 'figma', 'google-analytics', 'hubspot'],\r\n    extractionFocus: ['portfolio', 'services', 'clients', 'team', 'awards'],\r\n  },\r\n};\r\n\r\n/**\r\n * Detect company industry from scraped data\r\n */\r\nfunction detectIndustry(rawData: RawScrapedData): string | null {\r\n  const textLower = rawData.text.toLowerCase();\r\n  const techStack = rawData.techStack.map((t) => t.name.toLowerCase());\r\n\r\n  let bestMatch: { industry: string; score: number } | null = null;\r\n\r\n  for (const [industry, pattern] of Object.entries(INDUSTRY_PATTERNS)) {\r\n    let score = 0;\r\n\r\n    // Check keywords in text\r\n    for (const keyword of pattern.keywords) {\r\n      const regex = new RegExp(`\\\\b${keyword}\\\\b`, 'gi');\r\n      const matches = textLower.match(regex);\r\n      if (matches) {\r\n        score += matches.length * 2;\r\n      }\r\n    }\r\n\r\n    // Check tech indicators\r\n    for (const tech of pattern.techIndicators) {\r\n      if (techStack.some((t) => t.includes(tech.toLowerCase()))) {\r\n        score += 5;\r\n      }\r\n    }\r\n\r\n    if (!bestMatch || score > bestMatch.score) {\r\n      bestMatch = { industry, score };\r\n    }\r\n  }\r\n\r\n  // Only return if confidence is reasonable\r\n  return bestMatch && bestMatch.score > 3 ? bestMatch.industry : null;\r\n}\r\n\r\n// ============================================================================\r\n// LLM SYNTHESIS\r\n// ============================================================================\r\n\r\n/**\r\n * Synthesize structured Lead Object from raw scraped data\r\n * \r\n * Uses LLM to extract meaningful information from raw HTML/text\r\n * and structure it into a clean DiscoveredCompany object.\r\n * Now enhanced with industry-specific prompts.\r\n */\r\nasync function synthesizeLeadObject(\r\n  domain: string,\r\n  rawData: RawScrapedData\r\n): Promise<DiscoveredCompany> {\r\n  try {\r\n    // Detect industry for better prompt engineering\r\n    const detectedIndustry = detectIndustry(rawData);\r\n    \r\n    logger.info('Synthesizing lead object with LLM', { \r\n      domain,\r\n      detectedIndustry: detectedIndustry || 'general',\r\n    });\r\n\r\n    // Build industry-specific prompt for LLM\r\n    const prompt = buildSynthesisPrompt(domain, rawData, detectedIndustry);\r\n\r\n    // Generate structured data with LLM\r\n    const response = await sendUnifiedChatMessage({\r\n      model: 'gpt-4o-mini',\r\n      messages: [\r\n        {\r\n          role: 'system',\r\n          content: buildSystemPrompt(detectedIndustry),\r\n        },\r\n        {\r\n          role: 'user',\r\n          content: prompt,\r\n        },\r\n      ],\r\n      temperature: 0.1, // Low temperature for consistent extraction\r\n      maxTokens: 2000,\r\n    });\r\n\r\n    // Parse LLM response\r\n    let synthesized: Partial<DiscoveredCompany>;\r\n    try {\r\n      // Try to extract JSON from response text\r\n      const content = response.text;\r\n      const jsonMatch = content.match(/\\{[\\s\\S]*\\}/);\r\n      if (jsonMatch) {\r\n        synthesized = JSON.parse(jsonMatch[0]);\r\n      } else {\r\n        synthesized = JSON.parse(content);\r\n      }\r\n    } catch (parseError) {\r\n      logger.warn('Failed to parse LLM response, using defaults', {\r\n        domain,\r\n        error: parseError instanceof Error ? parseError.message : 'Unknown',\r\n      });\r\n      synthesized = {};\r\n    }\r\n\r\n    // Merge with raw data\r\n    const company: DiscoveredCompany = {\r\n      domain,\r\n      companyName: synthesized.companyName || extractDomainName(domain),\r\n      description: synthesized.description,\r\n      industry: synthesized.industry,\r\n      size: synthesized.size,\r\n      location: synthesized.location,\r\n      \r\n      teamMembers: rawData.teamMembers.length > 0 \r\n        ? rawData.teamMembers \r\n        : (synthesized.teamMembers || []),\r\n      \r\n      techStack: rawData.techStack.length > 0 \r\n        ? rawData.techStack \r\n        : (synthesized.techStack || []),\r\n      \r\n      pressmentions: synthesized.pressmentions || [],\r\n      \r\n      contactInfo: synthesized.contactInfo || {\r\n        socialMedia: {},\r\n      },\r\n      \r\n      signals: {\r\n        isHiring: (rawData.careerData?.jobCount || 0) > 0,\r\n        jobCount: rawData.careerData?.jobCount || 0,\r\n        recentActivity: true,\r\n        fundingStage: synthesized.signals?.fundingStage,\r\n        growthIndicators: synthesized.signals?.growthIndicators || [],\r\n      },\r\n      \r\n      metadata: {\r\n        scrapedAt: new Date(),\r\n        expiresAt: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000), // 30 days\r\n        source: 'discovery-engine',\r\n        confidence: calculateConfidence(rawData, synthesized),\r\n      },\r\n      \r\n      // Initialize workflow state\r\n      workflow: createWorkflowState('discovery', 'completed'),\r\n    };\r\n\r\n    logger.info('LLM synthesis complete', {\r\n      domain,\r\n      confidence: company.metadata.confidence,\r\n    });\r\n\r\n    return company;\r\n  } catch (error) {\r\n    logger.error('Failed to synthesize lead object', error, { domain });\r\n    \r\n    // Fallback to raw data only\r\n    return {\r\n      domain,\r\n      companyName: extractDomainName(domain),\r\n      teamMembers: rawData.teamMembers || [],\r\n      techStack: rawData.techStack || [],\r\n      pressmentions: [],\r\n      contactInfo: { socialMedia: {} },\r\n      signals: {\r\n        isHiring: (rawData.careerData?.jobCount || 0) > 0,\r\n        jobCount: rawData.careerData?.jobCount || 0,\r\n        recentActivity: false,\r\n        growthIndicators: [],\r\n      },\r\n      metadata: {\r\n        scrapedAt: new Date(),\r\n        expiresAt: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000),\r\n        source: 'discovery-engine',\r\n        confidence: 0.5,\r\n      },\r\n      workflow: createWorkflowState('discovery', 'completed'),\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Build system prompt based on detected industry\r\n */\r\nfunction buildSystemPrompt(industry: string | null): string {\r\n  const basePrompt = `You are an expert B2B company data analyst specializing in extracting structured information from website content. Your task is to analyze website data and return accurate, well-structured JSON objects.`;\r\n\r\n  if (!industry) {\r\n    return basePrompt;\r\n  }\r\n\r\n  const industryPrompts: Record<string, string> = {\r\n    saas: `${basePrompt} You specialize in SaaS companies. Pay special attention to:\r\n- Pricing tiers and business model (freemium, subscription, usage-based)\r\n- Target customer segments (SMB, mid-market, enterprise)\r\n- Key integrations and API availability\r\n- Product categories and features\r\n- Growth indicators (customer count, funding, expansions)`,\r\n\r\n    ecommerce: `${basePrompt} You specialize in e-commerce businesses. Pay special attention to:\r\n- Product categories and catalog size\r\n- Shipping and fulfillment capabilities\r\n- Payment methods and checkout features\r\n- Return policies and customer service\r\n- Market focus (B2C, B2B, D2C)`,\r\n\r\n    healthcare: `${basePrompt} You specialize in healthcare companies. Pay special attention to:\r\n- Services offered (telehealth, diagnostics, treatment, etc.)\r\n- Compliance certifications (HIPAA, FDA, etc.)\r\n- Provider network and locations\r\n- Insurance accepted\r\n- Patient-focused vs. provider-focused offerings`,\r\n\r\n    fintech: `${basePrompt} You specialize in fintech companies. Pay special attention to:\r\n- Financial products and services\r\n- Security and compliance measures\r\n- Regulatory licenses and jurisdictions\r\n- Payment methods and banking partners\r\n- Target customer segments (consumer, business, enterprise)`,\r\n\r\n    manufacturing: `${basePrompt} You specialize in manufacturing companies. Pay special attention to:\r\n- Manufacturing capabilities and processes\r\n- Product categories and materials\r\n- Quality certifications (ISO, etc.)\r\n- Production locations and facilities\r\n- Supply chain and distribution capabilities`,\r\n\r\n    consulting: `${basePrompt} You specialize in consulting firms. Pay special attention to:\r\n- Service offerings and expertise areas\r\n- Client industries served\r\n- Team credentials and experience\r\n- Case studies and success stories\r\n- Geographic coverage`,\r\n\r\n    agency: `${basePrompt} You specialize in creative and marketing agencies. Pay special attention to:\r\n- Service capabilities (branding, digital, creative, etc.)\r\n- Portfolio and notable clients\r\n- Team size and specializations\r\n- Awards and recognition\r\n- Technology stack used`,\r\n  };\r\n\r\n  return industryPrompts[industry] || basePrompt;\r\n}\r\n\r\n/**\r\n * Build LLM prompt for data synthesis (industry-specific)\r\n */\r\nfunction buildSynthesisPrompt(\r\n  domain: string,\r\n  rawData: RawScrapedData,\r\n  industry: string | null\r\n): string {\r\n  const basePrompt = `Extract company information from this website data for ${domain}.\r\n\r\n${industry ? `DETECTED INDUSTRY: ${industry.toUpperCase()}` : ''}\r\n\r\nWEBSITE TEXT (first 5000 chars):\r\n${rawData.text.substring(0, 5000)}\r\n\r\nHIGH-VALUE AREAS:\r\n${rawData.highValueAreas.map((area, i) => \r\n  `${i + 1}. ${area.type}: ${area.content.substring(0, 500)}`\r\n).join('\\n')}\r\n\r\nTEAM MEMBERS FOUND: ${rawData.teamMembers.length}\r\nTECH STACK FOUND: ${rawData.techStack.map(t => t.name).join(', ')}\r\nCAREER OPENINGS: ${rawData.careerData?.jobCount || 0}`;\r\n\r\n  // Add industry-specific extraction instructions\r\n  let industryInstructions = '';\r\n  if (industry && INDUSTRY_PATTERNS[industry as keyof typeof INDUSTRY_PATTERNS]) {\r\n    const pattern = INDUSTRY_PATTERNS[industry as keyof typeof INDUSTRY_PATTERNS];\r\n    industryInstructions = `\r\n\r\nINDUSTRY-SPECIFIC FOCUS AREAS:\r\n${pattern.extractionFocus.map((focus, i) => `${i + 1}. ${focus}`).join('\\n')}\r\n\r\nWhen extracting data, prioritize finding information about: ${pattern.extractionFocus.join(', ')}`;\r\n  }\r\n\r\n  return `${basePrompt}${industryInstructions}\r\n\r\nExtract and return a JSON object with this structure:\r\n{\r\n  \"companyName\": \"string\",\r\n  \"description\": \"string (2-3 sentences highlighting key value proposition)\",\r\n  \"industry\": \"string (be specific, e.g., 'B2B SaaS - Marketing Analytics' not just 'Software')\",\r\n  \"size\": \"string (e.g., '1-10', '10-50', '50-200', '200-1000', '1000+', 'Enterprise')\",\r\n  \"location\": \"string (headquarters city, country)\",\r\n  \"contactInfo\": {\r\n    \"email\": \"string (general contact or sales email)\",\r\n    \"phone\": \"string\",\r\n    \"address\": \"string (if available)\",\r\n    \"socialMedia\": {\r\n      \"linkedin\": \"string (full URL)\",\r\n      \"twitter\": \"string (handle or URL)\",\r\n      \"facebook\": \"string (URL)\"\r\n    }\r\n  },\r\n  \"signals\": {\r\n    \"fundingStage\": \"string (bootstrapped, seed, series A-F, public, acquired, etc.)\",\r\n    \"growthIndicators\": [\r\n      \"string array of specific growth signals like 'Recently raised Series B',\r\n      'Expanding to 3 new markets',\r\n      'Hiring 50+ roles',\r\n      'Featured in TechCrunch',\r\n      'Hit 100K users milestone'\"\r\n    ]\r\n  },\r\n  \"pressmentions\": [\r\n    {\r\n      \"title\": \"string (headline)\",\r\n      \"summary\": \"string (1-2 sentence summary)\",\r\n      \"date\": \"string (YYYY-MM-DD or 'Month YYYY' format)\",\r\n      \"url\": \"string (if available)\"\r\n    }\r\n  ]\r\n}\r\n\r\nIMPORTANT:\r\n- Be specific and accurate, don't make up information\r\n- If data is not available, omit the field or use null\r\n- Extract real quotes and facts from the website\r\n- For growth indicators, be specific with numbers and timeframes\r\n- Return ONLY valid JSON, no markdown formatting, no explanations`;\r\n}\r\n\r\n/**\r\n * Calculate confidence score based on data completeness\r\n */\r\nfunction calculateConfidence(rawData: RawScrapedData, synthesized: Partial<DiscoveredCompany>): number {\r\n  let score = 0;\r\n  let maxScore = 0;\r\n\r\n  // Team members found\r\n  maxScore += 20;\r\n  if (rawData.teamMembers.length > 0) score += 20;\r\n  else if (rawData.teamMembers.length > 5) score += 15;\r\n  else if (rawData.teamMembers.length > 0) score += 10;\r\n\r\n  // Tech stack found\r\n  maxScore += 15;\r\n  if (rawData.techStack.length > 5) score += 15;\r\n  else if (rawData.techStack.length > 0) score += 10;\r\n\r\n  // Company info extracted\r\n  maxScore += 30;\r\n  if (synthesized.companyName) score += 10;\r\n  if (synthesized.description) score += 10;\r\n  if (synthesized.industry) score += 5;\r\n  if (synthesized.size) score += 5;\r\n\r\n  // Contact info found\r\n  maxScore += 15;\r\n  if (synthesized.contactInfo?.email) score += 10;\r\n  if (synthesized.contactInfo?.phone) score += 5;\r\n\r\n  // High-value areas extracted\r\n  maxScore += 20;\r\n  score += Math.min(20, rawData.highValueAreas.length * 4);\r\n\r\n  return Math.round((score / maxScore) * 100) / 100;\r\n}\r\n\r\n/**\r\n * Extract company name from domain\r\n */\r\nfunction extractDomainName(domain: string): string {\r\n  let name = domain.replace(/^https?:\\/\\//, '').replace(/^www\\./, '').split('.')[0];\r\n  return name.charAt(0).toUpperCase() + name.slice(1);\r\n}\r\n\r\n// ============================================================================\r\n// ARCHIVE STORAGE\r\n// ============================================================================\r\n\r\n/**\r\n * Save discovered data to discoveryArchive with 30-day TTL\r\n */\r\nasync function saveToArchive(\r\n  domain: string,\r\n  organizationId: string,\r\n  company: DiscoveredCompany,\r\n  rawData: RawScrapedData\r\n): Promise<{ scrape: TemporaryScrape; isNew: boolean }> {\r\n  try {\r\n    const url = domain.startsWith('http') ? domain : `https://${domain}`;\r\n\r\n    const result = await saveToDiscoveryArchive({\r\n      organizationId,\r\n      url,\r\n      rawHtml: JSON.stringify(rawData),\r\n      cleanedContent: JSON.stringify(company),\r\n      metadata: {\r\n        title: company.companyName || extractDomainName(domain),\r\n        description: company.description,\r\n        author: 'discovery-engine',\r\n      },\r\n    });\r\n\r\n    logger.info('Saved to discovery archive', {\r\n      domain,\r\n      organizationId,\r\n      scrapeId: result.scrape.id,\r\n      isNew: result.isNew,\r\n      expiresAt: result.scrape.expiresAt,\r\n    });\r\n\r\n    return result;\r\n  } catch (error) {\r\n    logger.error('Failed to save to discovery archive', error, {\r\n      domain,\r\n      organizationId,\r\n    });\r\n    throw error;\r\n  }\r\n}\r\n\r\n// ============================================================================\r\n// BATCH DISCOVERY\r\n// ============================================================================\r\n\r\n/**\r\n * Discover multiple companies in batch\r\n * \r\n * Rate-limited to avoid overwhelming target sites.\r\n * \r\n * @param domains - Array of domains to discover\r\n * @param organizationId - Organization requesting discovery\r\n * @param options - Batch options\r\n * @returns Array of discovery results\r\n */\r\nexport async function discoverCompaniesBatch(\r\n  domains: string[],\r\n  organizationId: string,\r\n  options: {\r\n    concurrency?: number;\r\n    delayMs?: number;\r\n  } = {}\r\n): Promise<DiscoveryResult[]> {\r\n  const { concurrency = 3, delayMs = 2000 } = options;\r\n\r\n  logger.info('Starting batch discovery', {\r\n    domainsCount: domains.length,\r\n    concurrency,\r\n    organizationId,\r\n  });\r\n\r\n  const results: DiscoveryResult[] = [];\r\n  \r\n  // Process in batches\r\n  for (let i = 0; i < domains.length; i += concurrency) {\r\n    const batch = domains.slice(i, i + concurrency);\r\n    \r\n    const batchResults = await Promise.allSettled(\r\n      batch.map(domain => discoverCompany(domain, organizationId))\r\n    );\r\n\r\n    for (const result of batchResults) {\r\n      if (result.status === 'fulfilled') {\r\n        results.push(result.value);\r\n      } else {\r\n        logger.error('Batch discovery failed for domain', result.reason);\r\n      }\r\n    }\r\n\r\n    // Rate limiting delay between batches\r\n    if (i + concurrency < domains.length) {\r\n      await new Promise(resolve => setTimeout(resolve, delayMs));\r\n    }\r\n  }\r\n\r\n  logger.info('Batch discovery complete', {\r\n    totalDomains: domains.length,\r\n    successCount: results.length,\r\n    failedCount: domains.length - results.length,\r\n  });\r\n\r\n  return results;\r\n}\r\n\r\n// ============================================================================\r\n// PERSON DISCOVERY\r\n// ============================================================================\r\n\r\n/**\r\n * Discover person data from email address\r\n * \r\n * This function enriches a person's email with professional data by:\r\n * 1. Checking 30-day cache first\r\n * 2. Extracting domain and searching company website\r\n * 3. Finding LinkedIn profile via Google search\r\n * 4. Synthesizing data with LLM\r\n * \r\n * @param email - Person's email address\r\n * @param organizationId - Organization requesting the discovery\r\n * @returns Complete person discovery result\r\n * \r\n * @example\r\n * ```typescript\r\n * const result = await discoverPerson('john@example.com', 'org_123');\r\n * console.log(`Found: ${result.person.fullName} - ${result.person.title}`);\r\n * console.log(`LinkedIn: ${result.person.socialProfiles.linkedin}`);\r\n * console.log(`From cache: ${result.fromCache}`);\r\n * ```\r\n */\r\nexport async function discoverPerson(\r\n  email: string,\r\n  organizationId: string\r\n): Promise<PersonDiscoveryResult> {\r\n  try {\r\n    logger.info('Starting person discovery', {\r\n      email,\r\n      organizationId,\r\n      source: 'person-discovery',\r\n    });\r\n\r\n    // Validate email\r\n    if (!email || !email.includes('@')) {\r\n      throw new Error('Invalid email address');\r\n    }\r\n\r\n    // Step 1: Check discoveryArchive (30-day cache)\r\n    const cacheKey = `person:${email}`;\r\n    const contentHash = calculateContentHash(cacheKey);\r\n    const cached = await getFromDiscoveryArchiveByHash(organizationId, contentHash);\r\n    \r\n    if (cached && cached.expiresAt > new Date()) {\r\n      logger.info('Person discovery archive HIT', {\r\n        email,\r\n        organizationId,\r\n        cacheAge: Date.now() - cached.createdAt.getTime(),\r\n      });\r\n\r\n      const person = JSON.parse(cached.cleanedContent) as DiscoveredPerson;\r\n      \r\n      // Emit Signal Bus signal even for cached data (lower priority)\r\n      await emitPersonDiscoverySignals(person, organizationId, true);\r\n\r\n      return {\r\n        person,\r\n        fromCache: true,\r\n        scrapeId: cached.id,\r\n      };\r\n    }\r\n\r\n    // Step 2: Cache MISS - perform discovery\r\n    logger.info('Person discovery archive MISS - initiating search', {\r\n      email,\r\n      organizationId,\r\n    });\r\n\r\n    const person = await discoverPersonData(email, organizationId);\r\n\r\n    // Step 3: Save to discoveryArchive (30-day TTL)\r\n    const scrapeResult = await saveToDiscoveryArchive({\r\n      organizationId,\r\n      url: cacheKey,\r\n      rawHtml: JSON.stringify({ email, discoveredAt: new Date() }),\r\n      cleanedContent: JSON.stringify(person),\r\n      metadata: {\r\n        title: person.fullName || email,\r\n        description: person.title,\r\n        author: 'person-discovery',\r\n      },\r\n    });\r\n\r\n    logger.info('Person discovery complete', {\r\n      email,\r\n      organizationId,\r\n      fullName: person.fullName,\r\n      title: person.title,\r\n      fromCache: false,\r\n    });\r\n\r\n    // Emit Signal Bus signal for newly discovered person\r\n    await emitPersonDiscoverySignals(person, organizationId, false);\r\n\r\n    return {\r\n      person,\r\n      fromCache: false,\r\n      scrapeId: scrapeResult.scrape.id,\r\n    };\r\n  } catch (error) {\r\n    logger.error('Failed to discover person', error, {\r\n      email,\r\n      organizationId,\r\n    });\r\n    \r\n    const errorMessage = error instanceof Error ? error.message : 'Unknown error';\r\n    throw new Error(`Failed to discover person ${email}: ${errorMessage}`);\r\n  }\r\n}\r\n\r\n/**\r\n * Perform person data discovery\r\n * \r\n * Multi-source discovery strategy:\r\n * 1. Extract domain from email\r\n * 2. Search company website for person\r\n * 3. Search LinkedIn via Google\r\n * 4. Search GitHub if applicable\r\n * 5. Synthesize with LLM\r\n */\r\nasync function discoverPersonData(\r\n  email: string,\r\n  organizationId: string\r\n): Promise<DiscoveredPerson> {\r\n  const controller = createBrowserController({ headless: true });\r\n  const discoveryMethods: string[] = [];\r\n  let personData: Partial<DiscoveredPerson> = {\r\n    email,\r\n    socialProfiles: {},\r\n  };\r\n\r\n  try {\r\n    // Extract email parts\r\n    const [localPart, domain] = email.split('@');\r\n    const firstName = extractFirstName(localPart);\r\n    const lastName = extractLastName(localPart);\r\n\r\n    personData.firstName = firstName;\r\n    personData.lastName = lastName;\r\n    personData.fullName = `${firstName} ${lastName}`.trim() || email;\r\n\r\n    // Strategy 1: Search company website\r\n    try {\r\n      const companyUrl = `https://${domain}`;\r\n      await controller.navigate(companyUrl);\r\n      \r\n      const teamMembers = await controller.findTeamDirectory();\r\n      const matchedMember = teamMembers.find((member) => {\r\n        const memberName = member.name.toLowerCase();\r\n        return (\r\n          (firstName && memberName.includes(firstName.toLowerCase())) ||\r\n          (lastName && memberName.includes(lastName.toLowerCase())) ||\r\n          member.email === email\r\n        );\r\n      });\r\n\r\n      if (matchedMember) {\r\n        personData.title = matchedMember.title;\r\n        personData.currentRole = {\r\n          title: matchedMember.title || '',\r\n          company: domain,\r\n        };\r\n        if (matchedMember.linkedinUrl) {\r\n          personData.socialProfiles.linkedin = matchedMember.linkedinUrl;\r\n        }\r\n        discoveryMethods.push('company-website');\r\n      }\r\n    } catch (error) {\r\n      logger.debug('Company website search failed', {\r\n        email,\r\n        error: error instanceof Error ? error.message : 'Unknown',\r\n      });\r\n    }\r\n\r\n    // Strategy 2: LinkedIn search via Google\r\n    if (!personData.socialProfiles.linkedin) {\r\n      try {\r\n        const searchQuery = `site:linkedin.com/in \"${firstName} ${lastName}\" ${domain}`;\r\n        const googleUrl = `https://www.google.com/search?q=${encodeURIComponent(searchQuery)}`;\r\n        \r\n        await controller.navigate(googleUrl);\r\n        await controller.getPage()?.waitForTimeout(2000);\r\n        \r\n        // Extract LinkedIn URLs from search results\r\n        const linkedinLinks = await controller.getPage()?.$$eval('a', (links) =>\r\n          links\r\n            .map((link) => link.getAttribute('href') || '')\r\n            .filter((href) => href.includes('linkedin.com/in/'))\r\n            .map((href) => {\r\n              // Extract clean LinkedIn URL\r\n              const match = href.match(/https?:\\/\\/(www\\.)?linkedin\\.com\\/in\\/[^&?]+/);\r\n              return match ? match[0] : null;\r\n            })\r\n            .filter((url): url is string => url !== null)\r\n        );\r\n\r\n        if (linkedinLinks && linkedinLinks.length > 0) {\r\n          personData.socialProfiles.linkedin = linkedinLinks[0];\r\n          discoveryMethods.push('google-linkedin-search');\r\n        }\r\n      } catch (error) {\r\n        logger.debug('LinkedIn search failed', {\r\n          email,\r\n          error: error instanceof Error ? error.message : 'Unknown',\r\n        });\r\n      }\r\n    }\r\n\r\n    // Strategy 3: GitHub search (for technical roles)\r\n    try {\r\n      const githubUsername = localPart.replace(/[^a-zA-Z0-9-]/g, '');\r\n      const githubUrl = `https://github.com/${githubUsername}`;\r\n      \r\n      await controller.navigate(githubUrl);\r\n      await controller.getPage()?.waitForTimeout(1000);\r\n      \r\n      // Check if profile exists (no 404)\r\n      const title = await controller.getPage()?.title();\r\n      if (title && !title.includes('Page not found')) {\r\n        personData.socialProfiles.github = githubUrl;\r\n        discoveryMethods.push('github');\r\n      }\r\n    } catch (error) {\r\n      logger.debug('GitHub search failed', {\r\n        email,\r\n        error: error instanceof Error ? error.message : 'Unknown',\r\n      });\r\n    }\r\n\r\n    // Strategy 4: LLM synthesis\r\n    const synthesized = await synthesizePersonData(email, personData, discoveryMethods);\r\n\r\n    const finalPerson: DiscoveredPerson = {\r\n      ...personData,\r\n      ...synthesized,\r\n      email,\r\n      socialProfiles: {\r\n        ...personData.socialProfiles,\r\n        ...synthesized.socialProfiles,\r\n      },\r\n      metadata: {\r\n        discoveredAt: new Date(),\r\n        expiresAt: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000), // 30 days\r\n        source: 'person-discovery',\r\n        confidence: calculatePersonConfidence(personData, discoveryMethods),\r\n        methods: discoveryMethods,\r\n      },\r\n      workflow: createWorkflowState('discovery', 'completed'),\r\n    };\r\n\r\n    return finalPerson;\r\n  } catch (error) {\r\n    logger.error('Failed to discover person data', error, { email });\r\n    \r\n    // Return minimal data\r\n    return {\r\n      email,\r\n      fullName: personData.fullName || email,\r\n      socialProfiles: personData.socialProfiles || {},\r\n      metadata: {\r\n        discoveredAt: new Date(),\r\n        expiresAt: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000),\r\n        source: 'person-discovery',\r\n        confidence: 0.1,\r\n        methods: discoveryMethods,\r\n      },\r\n      workflow: createWorkflowState('discovery', 'failed'),\r\n    };\r\n  } finally {\r\n    await controller.close();\r\n  }\r\n}\r\n\r\n/**\r\n * Synthesize person data with LLM\r\n */\r\nasync function synthesizePersonData(\r\n  email: string,\r\n  personData: Partial<DiscoveredPerson>,\r\n  methods: string[]\r\n): Promise<Partial<DiscoveredPerson>> {\r\n  try {\r\n    const prompt = `Enrich this person's profile based on available data:\r\n\r\nEmail: ${email}\r\nName: ${personData.fullName || 'Unknown'}\r\nTitle: ${personData.title || 'Unknown'}\r\nCompany: ${personData.currentRole?.company || 'Unknown'}\r\nLinkedIn: ${personData.socialProfiles?.linkedin || 'Not found'}\r\nGitHub: ${personData.socialProfiles?.github || 'Not found'}\r\n\r\nDiscovery methods used: ${methods.join(', ')}\r\n\r\nBased on this information, provide:\r\n1. Inferred professional role/seniority\r\n2. Likely skills (if technical role detected)\r\n3. Professional interests\r\n4. Missing profile information\r\n\r\nReturn JSON with this structure:\r\n{\r\n  \"title\": \"string (if can be improved)\",\r\n  \"skills\": [\"string array\"],\r\n  \"interests\": [\"string array\"],\r\n  \"currentRole\": {\r\n    \"title\": \"string\",\r\n    \"company\": \"string\"\r\n  }\r\n}\r\n\r\nReturn ONLY valid JSON, no markdown.`;\r\n\r\n    const response = await sendUnifiedChatMessage({\r\n      model: 'gpt-4o-mini',\r\n      messages: [{ role: 'user', content: prompt }],\r\n      temperature: 0.1,\r\n      maxTokens: 500,\r\n    });\r\n\r\n    // Parse LLM response\r\n    try {\r\n      const content = response.text;\r\n      const jsonMatch = content.match(/\\{[\\s\\S]*\\}/);\r\n      if (jsonMatch) {\r\n        return JSON.parse(jsonMatch[0]);\r\n      }\r\n    } catch (parseError) {\r\n      logger.debug('Failed to parse LLM person synthesis', {\r\n        email,\r\n        error: parseError instanceof Error ? parseError.message : 'Unknown',\r\n      });\r\n    }\r\n\r\n    return {};\r\n  } catch (error) {\r\n    logger.debug('Person LLM synthesis failed', {\r\n      email,\r\n      error: error instanceof Error ? error.message : 'Unknown',\r\n    });\r\n    return {};\r\n  }\r\n}\r\n\r\n/**\r\n * Calculate person discovery confidence score\r\n */\r\nfunction calculatePersonConfidence(\r\n  personData: Partial<DiscoveredPerson>,\r\n  methods: string[]\r\n): number {\r\n  let score = 0;\r\n  let maxScore = 0;\r\n\r\n  // Name found\r\n  maxScore += 20;\r\n  if (personData.fullName && personData.fullName !== personData.email) {\r\n    score += 20;\r\n  }\r\n\r\n  // Title found\r\n  maxScore += 25;\r\n  if (personData.title) score += 25;\r\n\r\n  // LinkedIn found\r\n  maxScore += 30;\r\n  if (personData.socialProfiles?.linkedin) score += 30;\r\n\r\n  // Company website match\r\n  maxScore += 15;\r\n  if (methods.includes('company-website')) score += 15;\r\n\r\n  // Additional profiles\r\n  maxScore += 10;\r\n  if (personData.socialProfiles?.github) score += 5;\r\n  if (personData.socialProfiles?.twitter) score += 5;\r\n\r\n  return Math.round((score / maxScore) * 100) / 100;\r\n}\r\n\r\n/**\r\n * Extract first name from email local part\r\n */\r\nfunction extractFirstName(localPart: string): string {\r\n  // Common patterns: john.doe, john_doe, johndoe, j.doe\r\n  const cleaned = localPart.toLowerCase().replace(/[^a-z.]/g, '');\r\n  const parts = cleaned.split('.');\r\n  \r\n  if (parts.length > 0 && parts[0].length > 1) {\r\n    return capitalize(parts[0]);\r\n  }\r\n  \r\n  return '';\r\n}\r\n\r\n/**\r\n * Extract last name from email local part\r\n */\r\nfunction extractLastName(localPart: string): string {\r\n  const cleaned = localPart.toLowerCase().replace(/[^a-z.]/g, '');\r\n  const parts = cleaned.split('.');\r\n  \r\n  if (parts.length > 1 && parts[1].length > 1) {\r\n    return capitalize(parts[1]);\r\n  }\r\n  \r\n  return '';\r\n}\r\n\r\n/**\r\n * Capitalize first letter\r\n */\r\nfunction capitalize(str: string): string {\r\n  return str.charAt(0).toUpperCase() + str.slice(1);\r\n}\r\n\r\n/**\r\n * Batch person discovery\r\n */\r\nexport async function discoverPeopleBatch(\r\n  emails: string[],\r\n  organizationId: string,\r\n  options: {\r\n    concurrency?: number;\r\n    delayMs?: number;\r\n  } = {}\r\n): Promise<PersonDiscoveryResult[]> {\r\n  const { concurrency = 3, delayMs = 2000 } = options;\r\n\r\n  logger.info('Starting batch person discovery', {\r\n    emailsCount: emails.length,\r\n    concurrency,\r\n    organizationId,\r\n  });\r\n\r\n  const results: PersonDiscoveryResult[] = [];\r\n  \r\n  // Process in batches\r\n  for (let i = 0; i < emails.length; i += concurrency) {\r\n    const batch = emails.slice(i, i + concurrency);\r\n    \r\n    const batchResults = await Promise.allSettled(\r\n      batch.map(email => discoverPerson(email, organizationId))\r\n    );\r\n\r\n    for (const result of batchResults) {\r\n      if (result.status === 'fulfilled') {\r\n        results.push(result.value);\r\n      } else {\r\n        logger.error('Batch person discovery failed', result.reason);\r\n      }\r\n    }\r\n\r\n    // Rate limiting delay between batches\r\n    if (i + concurrency < emails.length) {\r\n      await new Promise(resolve => setTimeout(resolve, delayMs));\r\n    }\r\n  }\r\n\r\n  logger.info('Batch person discovery complete', {\r\n    totalEmails: emails.length,\r\n    successCount: results.length,\r\n    failedCount: emails.length - results.length,\r\n  });\r\n\r\n  return results;\r\n}\r\n\r\n// ============================================================================\r\n// SIGNAL BUS INTEGRATION\r\n// ============================================================================\r\n\r\n/**\r\n * Emit discovery signals to the Neural Net\r\n * \r\n * Emits signals when company data is discovered (new or cached).\r\n * Triggers downstream actions like lead scoring, sequence enrollment, etc.\r\n */\r\nasync function emitDiscoverySignals(\r\n  company: DiscoveredCompany,\r\n  organizationId: string,\r\n  fromCache: boolean\r\n): Promise<void> {\r\n  try {\r\n    const coordinator = getServerSignalCoordinator();\r\n\r\n    // Signal 1: website.discovered - Always emit when company is discovered\r\n    await coordinator.emitSignal({\r\n      type: 'website.discovered',\r\n      orgId: organizationId,\r\n      confidence: company.metadata.confidence,\r\n      priority: fromCache ? 'Low' : 'Medium',\r\n      metadata: {\r\n        source: 'discovery-engine',\r\n        domain: company.domain,\r\n        companyName: company.companyName,\r\n        industry: company.industry,\r\n        size: company.size,\r\n        location: company.location,\r\n        teamMembersCount: company.teamMembers.length,\r\n        techStackCount: company.techStack.length,\r\n        fromCache,\r\n        scrapedAt: company.metadata.scrapedAt.toISOString(),\r\n        expiresAt: company.metadata.expiresAt.toISOString(),\r\n      },\r\n    });\r\n\r\n    // Signal 2: website.technology.detected - Emit if tech stack found\r\n    if (company.techStack.length > 0) {\r\n      await coordinator.emitSignal({\r\n        type: 'website.technology.detected',\r\n        orgId: organizationId,\r\n        confidence: 0.9, // Tech stack detection is usually accurate\r\n        priority: 'Medium',\r\n        metadata: {\r\n          source: 'discovery-engine',\r\n          domain: company.domain,\r\n          companyName: company.companyName,\r\n          techStack: company.techStack.map(t => ({\r\n            name: t.name,\r\n            category: t.category,\r\n            confidence: t.confidence,\r\n          })),\r\n          techStackCount: company.techStack.length,\r\n          categories: [...new Set(company.techStack.map(t => t.category))],\r\n        },\r\n      });\r\n    }\r\n\r\n    // Signal 3: lead.discovered - Emit for each team member found\r\n    if (company.teamMembers.length > 0) {\r\n      for (const member of company.teamMembers.slice(0, 10)) { // Limit to first 10 to avoid spam\r\n        if (member.email) {\r\n          await coordinator.emitSignal({\r\n            type: 'lead.discovered',\r\n            leadId: member.email, // Use email as temporary leadId\r\n            orgId: organizationId,\r\n            confidence: member.email ? 0.8 : 0.5,\r\n            priority: member.email ? 'Medium' : 'Low',\r\n            metadata: {\r\n              source: 'discovery-engine',\r\n              discoveryMethod: 'team-directory',\r\n              domain: company.domain,\r\n              companyName: company.companyName,\r\n              personName: member.name,\r\n              personTitle: member.title,\r\n              personEmail: member.email,\r\n              personLinkedIn: member.linkedinUrl,\r\n              personImageUrl: member.imageUrl,\r\n              companyIndustry: company.industry,\r\n              companySize: company.size,\r\n            },\r\n          });\r\n        }\r\n      }\r\n    }\r\n\r\n    logger.info('Discovery signals emitted', {\r\n      domain: company.domain,\r\n      organizationId,\r\n      fromCache,\r\n      signalsEmitted: {\r\n        websiteDiscovered: 1,\r\n        technologyDetected: company.techStack.length > 0 ? 1 : 0,\r\n        leadsDiscovered: Math.min(company.teamMembers.filter(m => m.email).length, 10),\r\n      },\r\n    });\r\n  } catch (error) {\r\n    // Don't fail discovery if signal emission fails\r\n    logger.error('Failed to emit discovery signals', error, {\r\n      domain: company.domain,\r\n      organizationId,\r\n    });\r\n  }\r\n}\r\n\r\n/**\r\n * Emit person discovery signals to the Neural Net\r\n * \r\n * Emits signals when person data is discovered.\r\n */\r\nasync function emitPersonDiscoverySignals(\r\n  person: DiscoveredPerson,\r\n  organizationId: string,\r\n  fromCache: boolean\r\n): Promise<void> {\r\n  try {\r\n    const coordinator = getServerSignalCoordinator();\r\n\r\n    // Signal: lead.discovered\r\n    await coordinator.emitSignal({\r\n      type: 'lead.discovered',\r\n      leadId: person.email,\r\n      orgId: organizationId,\r\n      confidence: person.metadata.confidence,\r\n      priority: fromCache ? 'Low' : 'Medium',\r\n      metadata: {\r\n        source: 'person-discovery',\r\n        discoveryMethod: 'email-enrichment',\r\n        email: person.email,\r\n        firstName: person.firstName,\r\n        lastName: person.lastName,\r\n        fullName: person.fullName,\r\n        title: person.title,\r\n        company: person.company,\r\n        currentRole: person.currentRole,\r\n        location: person.location,\r\n        socialProfiles: person.socialProfiles,\r\n        skills: person.skills,\r\n        interests: person.interests,\r\n        discoveryMethods: person.metadata.methods,\r\n        fromCache,\r\n        discoveredAt: person.metadata.discoveredAt.toISOString(),\r\n        expiresAt: person.metadata.expiresAt.toISOString(),\r\n      },\r\n    });\r\n\r\n    logger.info('Person discovery signal emitted', {\r\n      email: person.email,\r\n      organizationId,\r\n      fullName: person.fullName,\r\n      fromCache,\r\n    });\r\n  } catch (error) {\r\n    // Don't fail person discovery if signal emission fails\r\n    logger.error('Failed to emit person discovery signal', error, {\r\n      email: person.email,\r\n      organizationId,\r\n    });\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\David\\PycharmProjects\\AI Sales Platform\\src\\lib\\services\\mutation-engine.ts","messages":[{"ruleId":"no-useless-escape","severity":2,"message":"Unnecessary escape character: \\[.","line":179,"column":42,"nodeType":"Literal","messageId":"unnecessaryEscape","endLine":179,"endColumn":43,"suggestions":[{"messageId":"removeEscape","fix":{"range":[5376,5377],"text":""},"desc":"Remove the `\\`. This maintains the current functionality."},{"messageId":"escapeBackslash","fix":{"range":[5376,5376],"text":"\\"},"desc":"Replace the `\\` with `\\\\` to include the actual backslash character."}]},{"ruleId":"no-useless-escape","severity":2,"message":"Unnecessary escape character: \\[.","line":207,"column":42,"nodeType":"Literal","messageId":"unnecessaryEscape","endLine":207,"endColumn":43,"suggestions":[{"messageId":"removeEscape","fix":{"range":[6115,6116],"text":""},"desc":"Remove the `\\`. This maintains the current functionality."},{"messageId":"escapeBackslash","fix":{"range":[6115,6115],"text":"\\"},"desc":"Replace the `\\` with `\\\\` to include the actual backslash character."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Mutation Engine\r\n * \r\n * Compiles IndustryTemplate + OnboardingData ΓåÆ Mutated Template (BaseModel input)\r\n * \r\n * Core Responsibilities:\r\n * 1. Deep merge template with onboarding-specific mutations\r\n * 2. Apply conditional rules based on customer profile\r\n * 3. Adjust signal weights mathematically\r\n * 4. Modify persona based on sales methodology\r\n * \r\n * Design Principles:\r\n * - Immutable: Never modifies original template\r\n * - Predictable: Same inputs always produce same output\r\n * - Testable: All mutations are verifiable through unit tests\r\n */\r\n\r\nimport type { IndustryTemplate, MutationRule } from '@/lib/persona/templates/types';\r\nimport type { OnboardingData } from '@/types/agent-memory';\r\nimport { logger } from '@/lib/logger/logger';\r\n\r\nexport class MutationEngine {\r\n  /**\r\n   * Compile template with onboarding data\r\n   * \r\n   * @param template - Industry template (genetic blueprint)\r\n   * @param onboarding - Client onboarding data\r\n   * @returns Mutated template ready for BaseModel conversion\r\n   */\r\n  compile(\r\n    template: IndustryTemplate,\r\n    onboarding: OnboardingData\r\n  ): IndustryTemplate {\r\n    if (!onboarding) {\r\n      throw new Error('Onboarding data is required');\r\n    }\r\n\r\n    logger.debug('[MutationEngine] Starting compilation', {\r\n      templateId: template.id,\r\n      businessName: onboarding.businessName\r\n    });\r\n\r\n    // Start with deep clone of template (immutable)\r\n    let mutated = this.deepClone(template);\r\n\r\n    // Apply global mutation rules\r\n    mutated = this.applyGlobalRules(mutated, onboarding);\r\n\r\n    // Apply template-specific mutation rules (if any)\r\n    if ('mutationRules' in template && Array.isArray((template as any).mutationRules)) {\r\n      mutated = this.applyTemplateRules(mutated, onboarding, (template as any).mutationRules as MutationRule[]);\r\n    }\r\n\r\n    logger.debug('[MutationEngine] Compilation complete', {\r\n      templateId: template.id,\r\n      mutationsApplied: true\r\n    });\r\n\r\n    return mutated;\r\n  }\r\n\r\n  /**\r\n   * Apply global mutation rules that apply to ALL templates\r\n   */\r\n  private applyGlobalRules(\r\n    template: IndustryTemplate,\r\n    onboarding: OnboardingData\r\n  ): IndustryTemplate {\r\n    let mutated = { ...template };\r\n\r\n    // Rule 1: Enterprise Focus - Boost hiring/expansion signals\r\n    if (this.isEnterpriseFocus(onboarding)) {\r\n      mutated = this.boostEnterpriseSignals(mutated);\r\n    }\r\n\r\n    // Rule 2: Aggressive Closing - Adjust persona tone\r\n    if (onboarding.closingStyle && onboarding.closingStyle > 7) {\r\n      mutated = this.adjustForAggressiveClosing(mutated);\r\n    }\r\n\r\n    // Rule 3: B2B Complexity - Adjust cognitive framework\r\n    if (this.isB2BComplex(onboarding)) {\r\n      mutated = this.adjustForB2BComplexity(mutated);\r\n    }\r\n\r\n    return mutated;\r\n  }\r\n\r\n  /**\r\n   * Apply template-specific mutation rules\r\n   */\r\n  private applyTemplateRules(\r\n    template: IndustryTemplate,\r\n    onboarding: OnboardingData,\r\n    rules: MutationRule[]\r\n  ): IndustryTemplate {\r\n    let mutated = { ...template };\r\n\r\n    // Sort by priority (lower number = higher priority)\r\n    const sortedRules = [...rules].sort((a, b) => a.priority - b.priority);\r\n\r\n    for (const rule of sortedRules) {\r\n      if (rule.condition(onboarding)) {\r\n        logger.debug('[MutationEngine] Applying rule', { ruleId: rule.id });\r\n        mutated = this.applyMutations(mutated, rule.mutations);\r\n      }\r\n    }\r\n\r\n    return mutated;\r\n  }\r\n\r\n  /**\r\n   * Apply mutation operations to template\r\n   */\r\n  private applyMutations(\r\n    template: IndustryTemplate,\r\n    mutations: any[]\r\n  ): IndustryTemplate {\r\n    let mutated = this.deepClone(template);\r\n\r\n    for (const mutation of mutations) {\r\n      const { path, operation, value, skipIfMissing } = mutation;\r\n\r\n      try {\r\n        const currentValue = this.getValueAtPath(mutated, path);\r\n\r\n        if (currentValue === undefined && skipIfMissing) {\r\n          continue;\r\n        }\r\n\r\n        const newValue = this.calculateNewValue(currentValue, operation, value);\r\n        this.setValueAtPath(mutated, path, newValue);\r\n      } catch (error) {\r\n        logger.warn('[MutationEngine] Mutation failed', {\r\n          path,\r\n          operation,\r\n          error: error instanceof Error ? error.message : 'Unknown error'\r\n        });\r\n      }\r\n    }\r\n\r\n    return mutated;\r\n  }\r\n\r\n  /**\r\n   * Calculate new value based on operation\r\n   */\r\n  private calculateNewValue(current: any, operation: string, value: any): any {\r\n    switch (operation) {\r\n      case 'add':\r\n        return (current || 0) + value;\r\n      case 'subtract':\r\n        return (current || 0) - value;\r\n      case 'multiply':\r\n        return (current || 0) * value;\r\n      case 'set':\r\n        return value;\r\n      case 'append':\r\n        return Array.isArray(current) ? [...current, value] : [value];\r\n      case 'prepend':\r\n        return Array.isArray(current) ? [value, ...current] : [value];\r\n      default:\r\n        return current;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get value at nested path\r\n   */\r\n  private getValueAtPath(obj: any, path: string): any {\r\n    // Handle array notation like \"highValueSignals[funding].scoreBoost\"\r\n    const parts = path.split('.');\r\n    let current = obj;\r\n\r\n    for (const part of parts) {\r\n      if (!current) return undefined;\r\n\r\n      // Check for array index notation [id]\r\n      const arrayMatch = part.match(/^([^\\[]+)\\[([^\\]]+)\\]$/);\r\n      if (arrayMatch) {\r\n        const [, arrayKey, idValue] = arrayMatch;\r\n        const array = current[arrayKey];\r\n        if (Array.isArray(array)) {\r\n          current = array.find((item: any) => item.id === idValue);\r\n        } else {\r\n          return undefined;\r\n        }\r\n      } else {\r\n        current = current[part];\r\n      }\r\n    }\r\n\r\n    return current;\r\n  }\r\n\r\n  /**\r\n   * Set value at nested path\r\n   */\r\n  private setValueAtPath(obj: any, path: string, value: any): void {\r\n    const parts = path.split('.');\r\n    let current = obj;\r\n\r\n    for (let i = 0; i < parts.length - 1; i++) {\r\n      const part = parts[i];\r\n      \r\n      // Handle array notation\r\n      const arrayMatch = part.match(/^([^\\[]+)\\[([^\\]]+)\\]$/);\r\n      if (arrayMatch) {\r\n        const [, arrayKey, idValue] = arrayMatch;\r\n        const array = current[arrayKey];\r\n        if (Array.isArray(array)) {\r\n          current = array.find((item: any) => item.id === idValue);\r\n        }\r\n      } else {\r\n        if (!current[part]) {\r\n          current[part] = {};\r\n        }\r\n        current = current[part];\r\n      }\r\n    }\r\n\r\n    const lastPart = parts[parts.length - 1];\r\n    current[lastPart] = value;\r\n  }\r\n\r\n  /**\r\n   * Check if target customer is Enterprise\r\n   */\r\n  private isEnterpriseFocus(onboarding: OnboardingData): boolean {\r\n    const targetCustomer = onboarding.targetCustomer?.toLowerCase() || '';\r\n    return (\r\n      targetCustomer.includes('enterprise') ||\r\n      targetCustomer.includes('500+') ||\r\n      targetCustomer.includes('large')\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Check if target is B2B with complex procurement\r\n   */\r\n  private isB2BComplex(onboarding: OnboardingData): boolean {\r\n    const targetCustomer = onboarding.targetCustomer?.toLowerCase() || '';\r\n    return (\r\n      targetCustomer.includes('b2b') ||\r\n      targetCustomer.includes('procurement') ||\r\n      targetCustomer.includes('rfp') ||\r\n      targetCustomer.includes('business')\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Boost signals relevant to Enterprise customers\r\n   */\r\n  private boostEnterpriseSignals(template: IndustryTemplate): IndustryTemplate {\r\n    const mutated = this.deepClone(template);\r\n\r\n    if (mutated.research?.highValueSignals) {\r\n      mutated.research.highValueSignals = mutated.research.highValueSignals.map(signal => {\r\n        // Boost signals related to growth, funding, hiring\r\n        if (\r\n          signal.id.includes('funding') ||\r\n          signal.id.includes('hiring') ||\r\n          signal.id.includes('expansion') ||\r\n          signal.id.includes('new_location')\r\n        ) {\r\n          return {\r\n            ...signal,\r\n            scoreBoost: signal.scoreBoost + 3\r\n          };\r\n        }\r\n        return signal;\r\n      });\r\n    }\r\n\r\n    return mutated;\r\n  }\r\n\r\n  /**\r\n   * Adjust template for aggressive closing methodology\r\n   */\r\n  private adjustForAggressiveClosing(template: IndustryTemplate): IndustryTemplate {\r\n    const mutated = this.deepClone(template);\r\n\r\n    // Adjust tone to be more direct\r\n    if (mutated.coreIdentity) {\r\n      mutated.coreIdentity.tone = 'Direct, urgent, action-oriented';\r\n    }\r\n\r\n    // Adjust conversion rhythm\r\n    if (mutated.tacticalExecution) {\r\n      mutated.tacticalExecution.conversionRhythm = \r\n        'Every message ends with a clear call-to-action and booking link';\r\n    }\r\n\r\n    // Boost urgency-related signals if present\r\n    if (mutated.research?.highValueSignals) {\r\n      mutated.research.highValueSignals = mutated.research.highValueSignals.map(signal => {\r\n        if (signal.id.includes('hiring') || signal.id.includes('expansion')) {\r\n          return {\r\n            ...signal,\r\n            scoreBoost: signal.scoreBoost + 2\r\n          };\r\n        }\r\n        return signal;\r\n      });\r\n    }\r\n\r\n    return mutated;\r\n  }\r\n\r\n  /**\r\n   * Adjust cognitive framework for B2B complexity\r\n   */\r\n  private adjustForB2BComplexity(template: IndustryTemplate): IndustryTemplate {\r\n    const mutated = this.deepClone(template);\r\n\r\n    if (mutated.cognitiveLogic) {\r\n      // Enhance framework for complex sales\r\n      if (!mutated.cognitiveLogic.framework.includes('B2B')) {\r\n        mutated.cognitiveLogic.framework = `B2B Enterprise: ${mutated.cognitiveLogic.framework}`;\r\n      }\r\n\r\n      // Update reasoning to include stakeholder management\r\n      if (!mutated.cognitiveLogic.reasoning.includes('stakeholder')) {\r\n        mutated.cognitiveLogic.reasoning += \r\n          '. Identify multiple stakeholders and decision-makers in complex buying committees.';\r\n      }\r\n    }\r\n\r\n    return mutated;\r\n  }\r\n\r\n  /**\r\n   * Deep clone object (handles nested structures)\r\n   */\r\n  private deepClone<T>(obj: T): T {\r\n    return JSON.parse(JSON.stringify(obj));\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\David\\PycharmProjects\\AI Sales Platform\\src\\lib\\templates\\revenue-forecasting-engine.ts","messages":[{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":428,"column":7,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":428,"endColumn":54},{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":429,"column":7,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":429,"endColumn":76}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Revenue Forecasting Engine\r\n * \r\n * Predictive revenue forecasting using:\r\n * - Stage-weighted pipeline value\r\n * - Historical win rates\r\n * - Deal velocity and trends\r\n * - Quota attainment tracking\r\n * - Rolling forecasts (30/60/90 day)\r\n * \r\n * FORECASTING METHODS:\r\n * 1. Pipeline-based: Sum of (deal value ├ù stage probability)\r\n * 2. Historical-based: Trend analysis of past performance\r\n * 3. Quota-based: Tracking against targets\r\n * 4. Confidence intervals: Best case / Most likely / Worst case\r\n * \r\n * INTEGRATION:\r\n * - Uses industry templates for stage probabilities\r\n * - Uses deal scoring for adjusted probabilities\r\n * - Emits signals to Signal Bus\r\n */\r\n\r\nimport { logger } from '@/lib/logger/logger';\r\nimport { getServerSignalCoordinator } from '@/lib/orchestration/coordinator-factory-server';\r\nimport type { Deal } from '@/lib/crm/deal-service';\r\nimport { getTemplateById } from './industry-templates';\r\nimport type { SalesIndustryTemplate } from './industry-templates';\r\nimport { calculateDealScore } from './deal-scoring-engine';\r\n\r\n// ============================================================================\r\n// TYPES\r\n// ============================================================================\r\n\r\nexport interface RevenueForecast {\r\n  organizationId: string;\r\n  workspaceId: string;\r\n  period: ForecastPeriod;\r\n  \r\n  // Primary forecast\r\n  forecast: number; // Most likely revenue\r\n  bestCase: number; // Optimistic scenario (90th percentile)\r\n  worstCase: number; // Pessimistic scenario (10th percentile)\r\n  confidence: number; // 0-100 - How confident we are\r\n  \r\n  // Breakdown\r\n  byStage: Map<string, StageRevenue>;\r\n  byRep?: Map<string, number>;\r\n  byProduct?: Map<string, number>;\r\n  \r\n  // Metrics\r\n  pipelineCoverage: number; // Pipeline / Quota ratio\r\n  weightedPipeline: number; // Sum of (deal value ├ù probability)\r\n  commitRevenue: number; // High-probability deals only\r\n  \r\n  // Trends\r\n  trend: 'improving' | 'stable' | 'declining';\r\n  trendPercentage: number; // +10% or -5%, etc.\r\n  \r\n  // Quota tracking\r\n  quota?: number;\r\n  quotaAttainment: number; // 0-100% of quota achieved\r\n  quotaGap: number; // How much more needed to hit quota\r\n  \r\n  // Metadata\r\n  dealsAnalyzed: number;\r\n  calculatedAt: Date;\r\n  forecastDate: Date; // End of forecast period\r\n}\r\n\r\nexport interface StageRevenue {\r\n  stageName: string;\r\n  dealCount: number;\r\n  totalValue: number;\r\n  weightedValue: number; // Value ├ù probability\r\n  probability: number; // Stage probability\r\n}\r\n\r\nexport type ForecastPeriod = '30-day' | '60-day' | '90-day' | 'quarter' | 'annual';\r\n\r\nexport interface ForecastOptions {\r\n  organizationId: string;\r\n  workspaceId: string;\r\n  period: ForecastPeriod;\r\n  templateId?: string;\r\n  quota?: number;\r\n  includeRepBreakdown?: boolean;\r\n  includeProductBreakdown?: boolean;\r\n}\r\n\r\nexport interface QuotaPerformance {\r\n  quota: number;\r\n  achieved: number;\r\n  attainment: number; // 0-100%\r\n  gap: number;\r\n  onTrack: boolean;\r\n  projectedAttainment: number; // Projected end-of-period attainment\r\n  daysRemaining: number;\r\n  requiredDailyRevenue: number; // How much per day to hit quota\r\n}\r\n\r\nexport interface ForecastTrend {\r\n  current: number;\r\n  previous: number;\r\n  change: number; // Dollar change\r\n  changePercentage: number; // Percentage change\r\n  direction: 'up' | 'down' | 'flat';\r\n  momentum: 'accelerating' | 'stable' | 'decelerating';\r\n}\r\n\r\n// ============================================================================\r\n// MAIN FORECASTING ENGINE\r\n// ============================================================================\r\n\r\n/**\r\n * Generate revenue forecast\r\n * \r\n * This is the main entry point for revenue forecasting.\r\n * \r\n * @param options - Forecasting options\r\n * @returns Comprehensive revenue forecast with confidence intervals\r\n * \r\n * @example\r\n * ```typescript\r\n * const forecast = await generateRevenueForecast({\r\n *   organizationId: 'org_123',\r\n *   workspaceId: 'default',\r\n *   period: '90-day',\r\n *   templateId: 'saas',\r\n *   quota: 500000\r\n * });\r\n * \r\n * console.log(`Forecast: $${forecast.forecast.toLocaleString()}`);\r\n * console.log(`Quota Attainment: ${forecast.quotaAttainment}%`);\r\n * ```\r\n */\r\nexport async function generateRevenueForecast(\r\n  options: ForecastOptions\r\n): Promise<RevenueForecast> {\r\n  const startTime = Date.now();\r\n  \r\n  try {\r\n    logger.info('Generating revenue forecast', {\r\n      orgId: options.organizationId,\r\n      period: options.period,\r\n      templateId: options.templateId\r\n    });\r\n    \r\n    // 1. Get industry template\r\n    let template: SalesIndustryTemplate | null = null;\r\n    if (options.templateId) {\r\n      template = getTemplateById(options.templateId);\r\n    }\r\n    \r\n    // 2. Fetch deals in pipeline (mock for now)\r\n    const deals = await fetchPipelineDeals(options.organizationId, options.workspaceId, options.period);\r\n    \r\n    // 3. Calculate stage-weighted revenue\r\n    const byStage = calculateRevenueByStage(deals, template);\r\n    \r\n    // 4. Calculate weighted pipeline\r\n    const weightedPipeline = Array.from(byStage.values())\r\n      .reduce((sum, stage) => sum + stage.weightedValue, 0);\r\n    \r\n    // 5. Calculate commit revenue (high-probability deals only)\r\n    const commitRevenue = calculateCommitRevenue(deals, template);\r\n    \r\n    // 6. Generate forecast scenarios\r\n    const mostLikely = weightedPipeline;\r\n    const bestCase = calculateBestCase(weightedPipeline, deals, template);\r\n    const worstCase = calculateWorstCase(weightedPipeline, deals, template);\r\n    \r\n    // 7. Calculate confidence\r\n    const confidence = calculateForecastConfidence(deals, template);\r\n    \r\n    // 8. Analyze trends\r\n    const trend = await analyzeTrend(options.organizationId, options.workspaceId, mostLikely);\r\n    \r\n    // 9. Calculate quota metrics\r\n    let quotaAttainment = 0;\r\n    let quotaGap = 0;\r\n    let pipelineCoverage = 0;\r\n    \r\n    if (options.quota) {\r\n      quotaAttainment = Math.round((mostLikely / options.quota) * 100);\r\n      quotaGap = options.quota - mostLikely;\r\n      pipelineCoverage = weightedPipeline / options.quota;\r\n    }\r\n    \r\n    // 10. Calculate forecast date (end of period)\r\n    const forecastDate = calculateForecastDate(options.period);\r\n    \r\n    const forecast: RevenueForecast = {\r\n      organizationId: options.organizationId,\r\n      workspaceId: options.workspaceId,\r\n      period: options.period,\r\n      forecast: Math.round(mostLikely),\r\n      bestCase: Math.round(bestCase),\r\n      worstCase: Math.round(worstCase),\r\n      confidence,\r\n      byStage,\r\n      weightedPipeline: Math.round(weightedPipeline),\r\n      commitRevenue: Math.round(commitRevenue),\r\n      pipelineCoverage,\r\n      trend: trend.direction === 'up' ? 'improving' : trend.direction === 'down' ? 'declining' : 'stable',\r\n      trendPercentage: trend.changePercentage,\r\n      quota: options.quota,\r\n      quotaAttainment,\r\n      quotaGap,\r\n      dealsAnalyzed: deals.length,\r\n      calculatedAt: new Date(),\r\n      forecastDate\r\n    };\r\n    \r\n    // 11. Emit Signal Bus event\r\n    try {\r\n      const coordinator = await getServerSignalCoordinator();\r\n      await coordinator.emitSignal({\r\n        type: 'forecast.updated',\r\n        orgId: options.organizationId,\r\n        workspaceId: options.workspaceId,\r\n        confidence: confidence / 100,\r\n        priority: quotaAttainment < 70 ? 'High' : 'Medium',\r\n        metadata: {\r\n          period: options.period,\r\n          forecast: forecast.forecast,\r\n          bestCase: forecast.bestCase,\r\n          worstCase: forecast.worstCase,\r\n          quotaAttainment,\r\n          quotaGap,\r\n          trend: forecast.trend,\r\n          trendPercentage: forecast.trendPercentage,\r\n          dealsAnalyzed: deals.length,\r\n          templateId: options.templateId,\r\n          timestamp: new Date().toISOString()\r\n        }\r\n      });\r\n      \r\n      logger.info('Signal emitted: forecast.updated', {\r\n        orgId: options.organizationId,\r\n        forecast: forecast.forecast\r\n      });\r\n    } catch (signalError) {\r\n      logger.warn('Failed to emit forecast.updated signal', signalError);\r\n    }\r\n    \r\n    const duration = Date.now() - startTime;\r\n    logger.info('Revenue forecast generated', {\r\n      orgId: options.organizationId,\r\n      period: options.period,\r\n      forecast: forecast.forecast,\r\n      quota: options.quota,\r\n      attainment: quotaAttainment,\r\n      duration\r\n    });\r\n    \r\n    return forecast;\r\n    \r\n  } catch (error) {\r\n    logger.error('Revenue forecasting failed', error as Error, {\r\n      orgId: options.organizationId,\r\n      period: options.period\r\n    });\r\n    throw new Error(`Revenue forecasting failed: ${(error as Error).message}`);\r\n  }\r\n}\r\n\r\n// ============================================================================\r\n// CALCULATION FUNCTIONS\r\n// ============================================================================\r\n\r\n/**\r\n * Calculate revenue breakdown by stage\r\n */\r\nfunction calculateRevenueByStage(\r\n  deals: Deal[],\r\n  template: SalesIndustryTemplate | null\r\n): Map<string, StageRevenue> {\r\n  const byStage = new Map<string, StageRevenue>();\r\n  \r\n  deals.forEach(deal => {\r\n    const stage = (deal as { stage?: string }).stage || 'unknown';\r\n    const value = deal.value || 0;\r\n    \r\n    // Get stage probability from template\r\n    const stageProbability = template?.stages.find(s => s.id === stage)?.probability || 50;\r\n    const probability = stageProbability / 100;\r\n    \r\n    const existing = byStage.get(stage);\r\n    if (existing) {\r\n      existing.dealCount += 1;\r\n      existing.totalValue += value;\r\n      existing.weightedValue += value * probability;\r\n    } else {\r\n      byStage.set(stage, {\r\n        stageName: stage,\r\n        dealCount: 1,\r\n        totalValue: value,\r\n        weightedValue: value * probability,\r\n        probability: stageProbability\r\n      });\r\n    }\r\n  });\r\n  \r\n  return byStage;\r\n}\r\n\r\n/**\r\n * Calculate commit revenue (high-probability deals only)\r\n * Typically deals with >75% probability\r\n */\r\nfunction calculateCommitRevenue(\r\n  deals: Deal[],\r\n  template: SalesIndustryTemplate | null\r\n): number {\r\n  return deals.reduce((sum, deal) => {\r\n    const stage = (deal as { stage?: string }).stage || 'unknown';\r\n    const probability = template?.stages.find(s => s.id === stage)?.probability || 50;\r\n    \r\n    // Only count high-probability deals\r\n    if (probability >= 75) {\r\n      return sum + (deal.value || 0);\r\n    }\r\n    return sum;\r\n  }, 0);\r\n}\r\n\r\n/**\r\n * Calculate best case scenario (90th percentile)\r\n */\r\nfunction calculateBestCase(\r\n  weightedPipeline: number,\r\n  deals: Deal[],\r\n  template: SalesIndustryTemplate | null\r\n): number {\r\n  // Best case assumes higher win rates\r\n  // Increase weighted pipeline by 20-30%\r\n  const uplift = 1.25;\r\n  return weightedPipeline * uplift;\r\n}\r\n\r\n/**\r\n * Calculate worst case scenario (10th percentile)\r\n */\r\nfunction calculateWorstCase(\r\n  weightedPipeline: number,\r\n  deals: Deal[],\r\n  template: SalesIndustryTemplate | null\r\n): number {\r\n  // Worst case assumes lower win rates\r\n  // Decrease weighted pipeline by 20-30%\r\n  const downside = 0.75;\r\n  return weightedPipeline * downside;\r\n}\r\n\r\n/**\r\n * Calculate forecast confidence\r\n */\r\nfunction calculateForecastConfidence(\r\n  deals: Deal[],\r\n  template: SalesIndustryTemplate | null\r\n): number {\r\n  let confidence = 60; // Base confidence\r\n  \r\n  // More deals = higher confidence\r\n  if (deals.length >= 50) confidence += 20;\r\n  else if (deals.length >= 20) confidence += 15;\r\n  else if (deals.length >= 10) confidence += 10;\r\n  else if (deals.length < 5) confidence -= 20;\r\n  \r\n  // Pipeline diversity = higher confidence\r\n  const stageSet = new Set(deals.map(d => (d as { stage?: string }).stage));\r\n  if (stageSet.size >= 4) confidence += 10;\r\n  \r\n  // Template available = higher confidence\r\n  if (template) confidence += 10;\r\n  \r\n  return Math.min(100, Math.max(0, confidence));\r\n}\r\n\r\n/**\r\n * Analyze trend compared to previous period\r\n */\r\nasync function analyzeTrend(\r\n  orgId: string,\r\n  workspaceId: string,\r\n  currentForecast: number\r\n): Promise<ForecastTrend> {\r\n  // Mock: simulate previous period forecast\r\n  const previousForecast = currentForecast * (0.8 + Math.random() * 0.4); // 80%-120% of current\r\n  \r\n  const change = currentForecast - previousForecast;\r\n  const changePercentage = Math.round((change / previousForecast) * 100);\r\n  \r\n  let direction: 'up' | 'down' | 'flat' = 'flat';\r\n  if (changePercentage > 5) direction = 'up';\r\n  else if (changePercentage < -5) direction = 'down';\r\n  \r\n  let momentum: 'accelerating' | 'stable' | 'decelerating' = 'stable';\r\n  if (Math.abs(changePercentage) > 15) {\r\n    momentum = changePercentage > 0 ? 'accelerating' : 'decelerating';\r\n  }\r\n  \r\n  return {\r\n    current: currentForecast,\r\n    previous: previousForecast,\r\n    change,\r\n    changePercentage,\r\n    direction,\r\n    momentum\r\n  };\r\n}\r\n\r\n/**\r\n * Calculate end date for forecast period\r\n */\r\nfunction calculateForecastDate(period: ForecastPeriod): Date {\r\n  const now = new Date();\r\n  \r\n  switch (period) {\r\n    case '30-day':\r\n      return new Date(now.getTime() + 30 * 24 * 60 * 60 * 1000);\r\n    case '60-day':\r\n      return new Date(now.getTime() + 60 * 24 * 60 * 60 * 1000);\r\n    case '90-day':\r\n      return new Date(now.getTime() + 90 * 24 * 60 * 60 * 1000);\r\n    case 'quarter':\r\n      // End of current quarter\r\n      const quarter = Math.floor(now.getMonth() / 3);\r\n      const quarterEnd = new Date(now.getFullYear(), (quarter + 1) * 3, 0);\r\n      return quarterEnd;\r\n    case 'annual':\r\n      return new Date(now.getFullYear(), 11, 31);\r\n    default:\r\n      return new Date(now.getTime() + 90 * 24 * 60 * 60 * 1000);\r\n  }\r\n}\r\n\r\n/**\r\n * Mock function to fetch pipeline deals\r\n */\r\nasync function fetchPipelineDeals(\r\n  orgId: string,\r\n  workspaceId: string,\r\n  period: ForecastPeriod\r\n): Promise<Deal[]> {\r\n  // Mock: generate sample deals\r\n  const dealCount = Math.floor(Math.random() * 20) + 10; // 10-30 deals\r\n  const deals: Deal[] = [];\r\n  \r\n  const stages = ['discovery', 'demo', 'proposal', 'negotiation'];\r\n  \r\n  for (let i = 0; i < dealCount; i++) {\r\n    const stage = stages[Math.floor(Math.random() * stages.length)];\r\n    const value = Math.floor(Math.random() * 100000) + 10000; // $10K-$110K\r\n    \r\n    deals.push({\r\n      id: `deal_${i}`,\r\n      organizationId: orgId,\r\n      value,\r\n      createdAt: new Date(Date.now() - Math.random() * 60 * 24 * 60 * 60 * 1000),\r\n      updatedAt: new Date(),\r\n      stage\r\n    } as Deal);\r\n  }\r\n  \r\n  return deals;\r\n}\r\n\r\n// ============================================================================\r\n// QUOTA TRACKING\r\n// ============================================================================\r\n\r\n/**\r\n * Calculate quota performance\r\n */\r\nexport async function calculateQuotaPerformance(\r\n  organizationId: string,\r\n  workspaceId: string,\r\n  period: ForecastPeriod,\r\n  quota: number,\r\n  templateId?: string\r\n): Promise<QuotaPerformance> {\r\n  try {\r\n    // Generate forecast\r\n    const forecast = await generateRevenueForecast({\r\n      organizationId,\r\n      workspaceId,\r\n      period,\r\n      quota,\r\n      templateId\r\n    });\r\n    \r\n    // Calculate days remaining\r\n    const now = new Date();\r\n    const endDate = forecast.forecastDate;\r\n    const daysRemaining = Math.ceil((endDate.getTime() - now.getTime()) / (1000 * 60 * 60 * 24));\r\n    \r\n    // Calculate required daily revenue\r\n    const gap = forecast.quotaGap > 0 ? forecast.quotaGap : 0;\r\n    const requiredDailyRevenue = daysRemaining > 0 ? gap / daysRemaining : 0;\r\n    \r\n    // Project end-of-period attainment\r\n    const trend = forecast.trendPercentage / 100;\r\n    const projectedAttainment = forecast.quotaAttainment * (1 + trend);\r\n    \r\n    const performance: QuotaPerformance = {\r\n      quota,\r\n      achieved: forecast.forecast,\r\n      attainment: forecast.quotaAttainment,\r\n      gap,\r\n      onTrack: forecast.quotaAttainment >= 70, // 70%+ is \"on track\"\r\n      projectedAttainment: Math.round(projectedAttainment),\r\n      daysRemaining,\r\n      requiredDailyRevenue: Math.round(requiredDailyRevenue)\r\n    };\r\n    \r\n    logger.info('Quota performance calculated', {\r\n      orgId: organizationId,\r\n      quota,\r\n      attainment: performance.attainment,\r\n      onTrack: performance.onTrack\r\n    });\r\n    \r\n    return performance;\r\n    \r\n  } catch (error) {\r\n    logger.error('Quota performance calculation failed', error as Error, {\r\n      orgId: organizationId\r\n    });\r\n    throw new Error(`Quota performance calculation failed: ${(error as Error).message}`);\r\n  }\r\n}\r\n\r\n// ============================================================================\r\n// FORECAST COMPARISON\r\n// ============================================================================\r\n\r\n/**\r\n * Compare forecasts across multiple periods\r\n */\r\nexport async function compareForecastPeriods(\r\n  organizationId: string,\r\n  workspaceId: string,\r\n  periods: ForecastPeriod[],\r\n  templateId?: string\r\n): Promise<Map<ForecastPeriod, RevenueForecast>> {\r\n  const forecasts = new Map<ForecastPeriod, RevenueForecast>();\r\n  \r\n  for (const period of periods) {\r\n    try {\r\n      const forecast = await generateRevenueForecast({\r\n        organizationId,\r\n        workspaceId,\r\n        period,\r\n        templateId\r\n      });\r\n      forecasts.set(period, forecast);\r\n    } catch (error) {\r\n      logger.warn('Failed to generate forecast for period', { period, error });\r\n    }\r\n  }\r\n  \r\n  return forecasts;\r\n}\r\n\r\n/**\r\n * Get forecast history for trend analysis\r\n */\r\nexport async function getForecastHistory(\r\n  organizationId: string,\r\n  workspaceId: string,\r\n  period: ForecastPeriod,\r\n  months: number = 6\r\n): Promise<Array<{\r\n  date: Date;\r\n  forecast: number;\r\n  actual?: number;\r\n  accuracy?: number;\r\n}>> {\r\n  // Mock implementation - would fetch from historical data\r\n  const history: Array<{ date: Date; forecast: number; actual?: number; accuracy?: number }> = [];\r\n  \r\n  for (let i = months; i >= 0; i--) {\r\n    const date = new Date();\r\n    date.setMonth(date.getMonth() - i);\r\n    \r\n    const forecast = Math.floor(Math.random() * 200000) + 100000; // $100K-$300K\r\n    const actual = i > 0 ? Math.floor(forecast * (0.8 + Math.random() * 0.4)) : undefined;\r\n    const accuracy = actual ? Math.round((1 - Math.abs(forecast - actual) / forecast) * 100) : undefined;\r\n    \r\n    history.push({ date, forecast, actual, accuracy });\r\n  }\r\n  \r\n  return history;\r\n}\r\n\r\nlogger.info('Revenue Forecasting Engine initialized');\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\David\\PycharmProjects\\AI Sales Platform\\src\\lib\\utils\\retry.ts","messages":[{"ruleId":"no-useless-catch","severity":2,"message":"Unnecessary try/catch wrapper.","line":336,"column":3,"nodeType":"TryStatement","messageId":"unnecessaryCatch","endLine":353,"endColumn":4}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Retry Utility with Exponential Backoff\r\n * \r\n * Provides retry logic for operations that may fail transiently,\r\n * such as API calls, database operations, and LLM requests.\r\n * \r\n * Features:\r\n * - Exponential backoff with jitter\r\n * - Configurable max retries and delays\r\n * - Custom retry conditions\r\n * - Request cancellation support (AbortController)\r\n * - Detailed error logging\r\n * \r\n * Usage:\r\n * ```typescript\r\n * const result = await retryWithBackoff(\r\n *   async () => await callOpenAI(prompt),\r\n *   {\r\n *     maxRetries: 3,\r\n *     baseDelayMs: 1000,\r\n *     maxDelayMs: 10000,\r\n *     shouldRetry: (error) => error.status === 429 || error.status >= 500\r\n *   }\r\n * );\r\n * ```\r\n */\r\n\r\nimport { logger } from '@/lib/logger/logger';\r\n\r\n// ============================================================================\r\n// TYPES\r\n// ============================================================================\r\n\r\nexport interface RetryOptions<T = any> {\r\n  /** Maximum number of retry attempts (default: 3) */\r\n  maxRetries?: number;\r\n  \r\n  /** Base delay between retries in milliseconds (default: 1000) */\r\n  baseDelayMs?: number;\r\n  \r\n  /** Maximum delay between retries in milliseconds (default: 30000 = 30s) */\r\n  maxDelayMs?: number;\r\n  \r\n  /** Custom function to determine if error should trigger retry */\r\n  shouldRetry?: (error: any, attempt: number) => boolean;\r\n  \r\n  /** Callback called before each retry */\r\n  onRetry?: (error: any, attempt: number, delayMs: number) => void;\r\n  \r\n  /** AbortSignal for cancellation support */\r\n  signal?: AbortSignal;\r\n  \r\n  /** Operation name for logging (default: 'operation') */\r\n  operationName?: string;\r\n  \r\n  /** Whether to add jitter to delay (default: true) */\r\n  addJitter?: boolean;\r\n}\r\n\r\nexport interface RetryResult<T> {\r\n  /** Result of the operation */\r\n  result: T;\r\n  \r\n  /** Number of attempts made */\r\n  attempts: number;\r\n  \r\n  /** Total time spent in milliseconds */\r\n  totalTimeMs: number;\r\n  \r\n  /** Whether operation succeeded */\r\n  success: boolean;\r\n}\r\n\r\n// ============================================================================\r\n// RETRY FUNCTIONS\r\n// ============================================================================\r\n\r\n/**\r\n * Retry an async operation with exponential backoff\r\n * \r\n * @param operation - Async function to retry\r\n * @param options - Retry configuration\r\n * @returns Result of the operation\r\n * @throws Last error if all retries exhausted\r\n */\r\nexport async function retryWithBackoff<T>(\r\n  operation: () => Promise<T>,\r\n  options: RetryOptions<T> = {}\r\n): Promise<T> {\r\n  const {\r\n    maxRetries = 3,\r\n    baseDelayMs = 1000,\r\n    maxDelayMs = 30000,\r\n    shouldRetry = defaultShouldRetry,\r\n    onRetry,\r\n    signal,\r\n    operationName = 'operation',\r\n    addJitter = true\r\n  } = options;\r\n  \r\n  const startTime = Date.now();\r\n  let lastError: any;\r\n  \r\n  for (let attempt = 0; attempt <= maxRetries; attempt++) {\r\n    try {\r\n      // Check if operation was cancelled\r\n      if (signal?.aborted) {\r\n        throw new Error('Operation cancelled');\r\n      }\r\n      \r\n      // Execute operation\r\n      const result = await operation();\r\n      \r\n      // Log success if retries were needed\r\n      if (attempt > 0) {\r\n        logger.info(`${operationName} succeeded after ${attempt} retries`, {\r\n          attempts: attempt + 1,\r\n          totalTimeMs: Date.now() - startTime\r\n        });\r\n      }\r\n      \r\n      return result;\r\n      \r\n    } catch (error) {\r\n      lastError = error;\r\n      \r\n      // Check if we should retry\r\n      const isLastAttempt = attempt === maxRetries;\r\n      const shouldRetryError = shouldRetry(error, attempt);\r\n      \r\n      if (isLastAttempt || !shouldRetryError) {\r\n        // Log final failure\r\n        logger.error(`${operationName} failed after ${attempt + 1} attempts`, error as Error, {\r\n          attempts: attempt + 1,\r\n          totalTimeMs: Date.now() - startTime\r\n        });\r\n        throw error;\r\n      }\r\n      \r\n      // Calculate delay with exponential backoff\r\n      const exponentialDelay = Math.min(\r\n        baseDelayMs * Math.pow(2, attempt),\r\n        maxDelayMs\r\n      );\r\n      \r\n      // Add jitter to prevent thundering herd\r\n      const jitter = addJitter ? Math.random() * 0.3 * exponentialDelay : 0;\r\n      const delayMs = exponentialDelay + jitter;\r\n      \r\n      // Call retry callback\r\n      if (onRetry) {\r\n        onRetry(error, attempt + 1, delayMs);\r\n      }\r\n      \r\n      // Log retry attempt\r\n      logger.warn(`${operationName} failed, retrying in ${Math.round(delayMs)}ms`, {\r\n        attempt: attempt + 1,\r\n        maxRetries,\r\n        error: error instanceof Error ? error.message : String(error)\r\n      });\r\n      \r\n      // Wait before retrying\r\n      await sleep(delayMs, signal);\r\n    }\r\n  }\r\n  \r\n  // This should never be reached, but TypeScript requires it\r\n  throw lastError;\r\n}\r\n\r\n/**\r\n * Default retry condition - retry on network errors and 5xx status codes\r\n */\r\nfunction defaultShouldRetry(error: any, attempt: number): boolean {\r\n  // Never retry after max attempts\r\n  if (attempt >= 10) {\r\n    return false;\r\n  }\r\n  \r\n  // Retry on network errors\r\n  if (\r\n    error.code === 'ECONNRESET' ||\r\n    error.code === 'ETIMEDOUT' ||\r\n    error.code === 'ENOTFOUND' ||\r\n    error.message?.includes('network') ||\r\n    error.message?.includes('timeout')\r\n  ) {\r\n    return true;\r\n  }\r\n  \r\n  // Retry on rate limits (429)\r\n  if (error.status === 429 || error.statusCode === 429) {\r\n    return true;\r\n  }\r\n  \r\n  // Retry on server errors (5xx)\r\n  if (error.status >= 500 || error.statusCode >= 500) {\r\n    return true;\r\n  }\r\n  \r\n  // Don't retry on client errors (4xx, except 429)\r\n  if ((error.status >= 400 && error.status < 500) || \r\n      (error.statusCode >= 400 && error.statusCode < 500)) {\r\n    return false;\r\n  }\r\n  \r\n  // Retry on unknown errors\r\n  return true;\r\n}\r\n\r\n/**\r\n * Sleep for specified duration with cancellation support\r\n */\r\nfunction sleep(ms: number, signal?: AbortSignal): Promise<void> {\r\n  return new Promise((resolve, reject) => {\r\n    // Handle cancellation\r\n    if (signal?.aborted) {\r\n      reject(new Error('Sleep cancelled'));\r\n      return;\r\n    }\r\n    \r\n    const timeoutId = setTimeout(resolve, ms);\r\n    \r\n    // Listen for cancellation\r\n    if (signal) {\r\n      signal.addEventListener('abort', () => {\r\n        clearTimeout(timeoutId);\r\n        reject(new Error('Sleep cancelled'));\r\n      }, { once: true });\r\n    }\r\n  });\r\n}\r\n\r\n// ============================================================================\r\n// LLM-SPECIFIC RETRY PRESETS\r\n// ============================================================================\r\n\r\n/**\r\n * Retry options for OpenAI API calls\r\n */\r\nexport const OpenAIRetryOptions: RetryOptions = {\r\n  maxRetries: 3,\r\n  baseDelayMs: 1000,\r\n  maxDelayMs: 10000,\r\n  operationName: 'OpenAI API call',\r\n  shouldRetry: (error, attempt) => {\r\n    // Retry on rate limits\r\n    if (error.status === 429 || error.statusCode === 429) {\r\n      return true;\r\n    }\r\n    \r\n    // Retry on server errors\r\n    if (error.status >= 500 || error.statusCode >= 500) {\r\n      return true;\r\n    }\r\n    \r\n    // Retry on timeout\r\n    if (error.code === 'ETIMEDOUT' || error.message?.includes('timeout')) {\r\n      return true;\r\n    }\r\n    \r\n    // Don't retry on invalid requests\r\n    if (error.status === 400 || error.status === 401 || error.status === 403) {\r\n      return false;\r\n    }\r\n    \r\n    // Retry on unknown errors (but limit attempts)\r\n    return attempt < 3;\r\n  }\r\n};\r\n\r\n/**\r\n * Retry options for general LLM calls\r\n */\r\nexport const LLMRetryOptions: RetryOptions = {\r\n  maxRetries: 3,\r\n  baseDelayMs: 2000,\r\n  maxDelayMs: 15000,\r\n  operationName: 'LLM call',\r\n  shouldRetry: (error, attempt) => {\r\n    // Retry on rate limits and server errors\r\n    return (\r\n      error.status === 429 ||\r\n      error.status >= 500 ||\r\n      error.code === 'ETIMEDOUT' ||\r\n      (attempt < 3 && !error.status)\r\n    );\r\n  }\r\n};\r\n\r\n/**\r\n * Retry options for database operations\r\n */\r\nexport const DatabaseRetryOptions: RetryOptions = {\r\n  maxRetries: 5,\r\n  baseDelayMs: 500,\r\n  maxDelayMs: 5000,\r\n  operationName: 'Database operation',\r\n  shouldRetry: (error, attempt) => {\r\n    // Retry on deadlocks and timeouts\r\n    return (\r\n      error.code === 'ECONNRESET' ||\r\n      error.code === 'ETIMEDOUT' ||\r\n      error.message?.includes('deadlock') ||\r\n      error.message?.includes('timeout') ||\r\n      (attempt < 5 && !error.status)\r\n    );\r\n  }\r\n};\r\n\r\n/**\r\n * Retry options for external API calls\r\n */\r\nexport const ExternalAPIRetryOptions: RetryOptions = {\r\n  maxRetries: 3,\r\n  baseDelayMs: 1000,\r\n  maxDelayMs: 10000,\r\n  operationName: 'External API call',\r\n  shouldRetry: defaultShouldRetry\r\n};\r\n\r\n// ============================================================================\r\n// HELPER FUNCTIONS\r\n// ============================================================================\r\n\r\n/**\r\n * Retry with exponential backoff and return detailed result\r\n */\r\nexport async function retryWithBackoffDetailed<T>(\r\n  operation: () => Promise<T>,\r\n  options: RetryOptions<T> = {}\r\n): Promise<RetryResult<T>> {\r\n  const startTime = Date.now();\r\n  let attempts = 0;\r\n  \r\n  try {\r\n    const result = await retryWithBackoff(\r\n      async () => {\r\n        attempts++;\r\n        return await operation();\r\n      },\r\n      options\r\n    );\r\n    \r\n    return {\r\n      result,\r\n      attempts,\r\n      totalTimeMs: Date.now() - startTime,\r\n      success: true\r\n    };\r\n  } catch (error) {\r\n    throw error;\r\n  }\r\n}\r\n\r\n/**\r\n * Create an AbortController with timeout\r\n */\r\nexport function createAbortControllerWithTimeout(timeoutMs: number): AbortController {\r\n  const controller = new AbortController();\r\n  \r\n  setTimeout(() => {\r\n    controller.abort();\r\n  }, timeoutMs);\r\n  \r\n  return controller;\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\David\\PycharmProjects\\AI Sales Platform\\src\\lib\\workflows\\actions\\conditional-action.ts","messages":[{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":100,"column":7,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":100,"endColumn":84},{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":105,"column":7,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":105,"endColumn":81},{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":162,"column":7,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":162,"endColumn":109},{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":165,"column":7,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":165,"endColumn":112}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Conditional Action Executor\r\n * Executes conditional logic in workflows\r\n */\r\n\r\nimport type { ConditionalBranchAction, WorkflowCondition, WorkflowAction } from '@/types/workflow';\r\n\r\n/**\r\n * Execute conditional action\r\n */\r\nexport async function executeConditionalAction(\r\n  action: ConditionalBranchAction,\r\n  triggerData: any,\r\n  workflow: any,\r\n  organizationId: string\r\n): Promise<any> {\r\n  // Evaluate all branches\r\n  let matchedBranch: ConditionalBranchAction['branches'][0] | null = null;\r\n  \r\n  for (const branch of action.branches) {\r\n    const conditionsMet = await evaluateConditions(branch.conditions, triggerData, branch.conditionOperator);\r\n    if (conditionsMet) {\r\n      matchedBranch = branch;\r\n      break;\r\n    }\r\n  }\r\n  \r\n  // Execute matched branch or default branch\r\n  const actionsToExecute = matchedBranch ? matchedBranch.actions : (action.defaultBranch || []);\r\n  const conditionMet = matchedBranch !== null;\r\n  \r\n  if (!actionsToExecute || actionsToExecute.length === 0) {\r\n    return {\r\n      conditionMet,\r\n      executed: false,\r\n      message: `No actions defined for ${conditionMet ? 'matched' : 'default'} branch`,\r\n    };\r\n  }\r\n  \r\n  // Execute actions in sequence\r\n  const results = [];\r\n  \r\n  for (const subAction of actionsToExecute) {\r\n    try {\r\n      const result = await executeAction(subAction, triggerData, workflow, organizationId);\r\n      results.push({\r\n        actionId: subAction.id,\r\n        success: true,\r\n        result,\r\n      });\r\n    } catch (error: any) {\r\n      results.push({\r\n        actionId: subAction.id,\r\n        success: false,\r\n        error: error.message,\r\n      });\r\n      // Stop on first error (can be made configurable)\r\n      break;\r\n    }\r\n  }\r\n  \r\n  return {\r\n    conditionMet: matchedBranch !== null,\r\n    executed: true,\r\n    results,\r\n  };\r\n}\r\n\r\n/**\r\n * Evaluate conditions\r\n */\r\nasync function evaluateConditions(\r\n  conditions: WorkflowCondition[],\r\n  triggerData: any,\r\n  operator: 'and' | 'or'\r\n): Promise<boolean> {\r\n  const results = conditions.map(condition => evaluateCondition(condition, triggerData));\r\n  \r\n  if (operator === 'and') {\r\n    return results.every(r => r);\r\n  } else {\r\n    return results.some(r => r);\r\n  }\r\n}\r\n\r\n/**\r\n * Evaluate single condition\r\n */\r\nfunction evaluateCondition(condition: WorkflowCondition, triggerData: any): boolean {\r\n  // Get value based on source\r\n  let fieldValue: any;\r\n  \r\n  switch (condition.source) {\r\n    case 'trigger_data':\r\n      fieldValue = getNestedValue(triggerData, condition.field);\r\n      break;\r\n    case 'entity':\r\n      // Query entity from trigger data context\r\n      // The entity data should be populated in triggerData.entity or triggerData.entities\r\n      const entityData = triggerData?.entity || triggerData?.record || triggerData;\r\n      fieldValue = getNestedValue(entityData, condition.field);\r\n      break;\r\n    case 'variable':\r\n      // Get from workflow variables stored in triggerData._variables\r\n      const variables = triggerData?._variables || triggerData?.variables || {};\r\n      fieldValue = getNestedValue(variables, condition.field);\r\n      break;\r\n    case 'date':\r\n      // Handle date comparisons\r\n      if (condition.field === 'now') {\r\n        fieldValue = new Date();\r\n      } else if (condition.field === 'today') {\r\n        const today = new Date();\r\n        today.setHours(0, 0, 0, 0);\r\n        fieldValue = today;\r\n      } else {\r\n        fieldValue = new Date(getNestedValue(triggerData, condition.field));\r\n      }\r\n      break;\r\n    default:\r\n      fieldValue = null;\r\n  }\r\n  \r\n  // Compare based on operator\r\n  switch (condition.operator) {\r\n    case 'equals':\r\n      // Handle date comparison\r\n      if (fieldValue instanceof Date && condition.value) {\r\n        const compareDate = new Date(condition.value as string);\r\n        return fieldValue.getTime() === compareDate.getTime();\r\n      }\r\n      return fieldValue === condition.value;\r\n    case 'not_equals':\r\n      return fieldValue !== condition.value;\r\n    case 'contains':\r\n      return String(fieldValue || '').toLowerCase().includes(String(condition.value || '').toLowerCase());\r\n    case 'not_contains':\r\n      return !String(fieldValue || '').toLowerCase().includes(String(condition.value || '').toLowerCase());\r\n    case 'greater_than':\r\n      if (fieldValue instanceof Date && condition.value) {\r\n        return fieldValue.getTime() > new Date(condition.value as string).getTime();\r\n      }\r\n      return Number(fieldValue) > Number(condition.value);\r\n    case 'less_than':\r\n      if (fieldValue instanceof Date && condition.value) {\r\n        return fieldValue.getTime() < new Date(condition.value as string).getTime();\r\n      }\r\n      return Number(fieldValue) < Number(condition.value);\r\n    case 'greater_than_or_equal':\r\n      return Number(fieldValue) >= Number(condition.value);\r\n    case 'less_than_or_equal':\r\n      return Number(fieldValue) <= Number(condition.value);\r\n    case 'exists':\r\n      return fieldValue !== undefined && fieldValue !== null && fieldValue !== '';\r\n    case 'not_exists':\r\n      return fieldValue === undefined || fieldValue === null || fieldValue === '';\r\n    case 'starts_with':\r\n      return String(fieldValue || '').toLowerCase().startsWith(String(condition.value || '').toLowerCase());\r\n    case 'ends_with':\r\n      return String(fieldValue || '').toLowerCase().endsWith(String(condition.value || '').toLowerCase());\r\n    case 'in':\r\n      const inArray = Array.isArray(condition.value) ? condition.value : String(condition.value).split(',');\r\n      return inArray.includes(fieldValue);\r\n    case 'not_in':\r\n      const notInArray = Array.isArray(condition.value) ? condition.value : String(condition.value).split(',');\r\n      return !notInArray.includes(fieldValue);\r\n    case 'is_empty':\r\n      return !fieldValue || (Array.isArray(fieldValue) && fieldValue.length === 0);\r\n    case 'is_not_empty':\r\n      return fieldValue && (!Array.isArray(fieldValue) || fieldValue.length > 0);\r\n    default:\r\n      return false;\r\n  }\r\n}\r\n\r\n/**\r\n * Execute a single action (helper)\r\n */\r\nasync function executeAction(\r\n  action: WorkflowAction,\r\n  triggerData: any,\r\n  workflow: any,\r\n  organizationId: string\r\n): Promise<any> {\r\n  // Import action executors\r\n  const { executeEmailAction } = await import('./email-action');\r\n  const { executeSMSAction } = await import('./sms-action');\r\n  const { executeEntityAction } = await import('./entity-action');\r\n  const { executeHTTPAction } = await import('./http-action');\r\n  const { executeDelayAction } = await import('./delay-action');\r\n  \r\n  switch (action.type) {\r\n    case 'send_email':\r\n      return executeEmailAction(action, triggerData, organizationId);\r\n    case 'send_sms':\r\n      return executeSMSAction(action, triggerData, organizationId);\r\n    case 'create_entity':\r\n    case 'update_entity':\r\n    case 'delete_entity':\r\n      return executeEntityAction(action, triggerData, organizationId);\r\n    case 'http_request':\r\n      return executeHTTPAction(action, triggerData);\r\n    case 'delay':\r\n      return executeDelayAction(action, triggerData);\r\n    default:\r\n      throw new Error(`Unknown action type: ${action.type}`);\r\n  }\r\n}\r\n\r\n/**\r\n * Get nested value from object using dot notation\r\n */\r\nfunction getNestedValue(obj: any, path: string): any {\r\n  return path.split('.').reduce((current, key) => current?.[key], obj);\r\n}\r\n\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\David\\PycharmProjects\\AI Sales Platform\\src\\lib\\workflows\\actions\\entity-action.ts","messages":[{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":65,"column":9,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":65,"endColumn":83}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Entity Action Executor\r\n * Executes entity CRUD actions in workflows\r\n */\r\n\r\nimport { FirestoreService, COLLECTIONS } from '@/lib/db/firestore-service';\r\nimport type { CreateEntityAction, UpdateEntityAction, DeleteEntityAction } from '@/types/workflow';\r\nimport type { Schema } from '@/types/schema';\r\nimport { logger } from '@/lib/logger/logger';\r\n\r\n/**\r\n * Execute create entity action\r\n */\r\nexport async function executeCreateEntityAction(\r\n  action: CreateEntityAction,\r\n  triggerData: any,\r\n  organizationId: string,\r\n  workspaceId: string\r\n): Promise<any> {\r\n  // Get schema for field resolution\r\n  const { FirestoreService: FS, COLLECTIONS: COL } = await import('@/lib/db/firestore-service');\r\n  const schemaData = await FS.get(\r\n    `${COL.ORGANIZATIONS}/${organizationId}/${COL.WORKSPACES}/${workspaceId}/${COL.SCHEMAS}`,\r\n    action.schemaId\r\n  );\r\n  \r\n  if (!schemaData) {\r\n    throw new Error(`Schema ${action.schemaId} not found`);\r\n  }\r\n  \r\n  const schema = schemaData as Schema;\r\n  \r\n  // Build entity data from field mappings with dynamic field resolution\r\n  const entityData: Record<string, any> = {};\r\n  \r\n  for (const mapping of action.fieldMappings) {\r\n    let value: any;\r\n    \r\n    // Resolve target field using field resolver\r\n    const { FieldResolver } = await import('@/lib/schema/field-resolver');\r\n    const resolvedTarget = await FieldResolver.resolveFieldWithCommonAliases(\r\n      schema,\r\n      mapping.targetField\r\n    );\r\n    \r\n    if (!resolvedTarget) {\r\n      logger.warn('[Entity Action] Target field not found in schema', {\r\n        file: 'entity-action.ts',\r\n        targetField: mapping.targetField,\r\n        schemaId: action.schemaId,\r\n      });\r\n      continue; // Skip this mapping\r\n    }\r\n    \r\n    switch (mapping.source) {\r\n      case 'static':\r\n        value = mapping.staticValue;\r\n        break;\r\n      case 'trigger':\r\n        // Use field resolver to get value with flexible matching\r\n        value = FieldResolver.getFieldValue(triggerData, mapping.sourceField || '');\r\n        break;\r\n      case 'variable':\r\n        // Get from workflow variables stored in triggerData._variables\r\n        const variables = triggerData?._variables || triggerData?.variables || {};\r\n        value = FieldResolver.getFieldValue(variables, mapping.sourceField || '');\r\n        // Fallback to trigger data if not found in variables\r\n        if (value === undefined) {\r\n          value = FieldResolver.getFieldValue(triggerData, mapping.sourceField || '');\r\n        }\r\n        break;\r\n      case 'ai':\r\n        // Generate using AI\r\n        value = await generateWithAI({\r\n          organizationId,\r\n          field: resolvedTarget.fieldKey,\r\n          prompt: mapping.aiPrompt || `Generate a value for field \"${resolvedTarget.fieldLabel}\"`,\r\n          context: triggerData,\r\n        });\r\n        break;\r\n      default:\r\n        value = null;\r\n    }\r\n    \r\n    // Apply transform if specified\r\n    if (mapping.transform && value !== null && value !== undefined) {\r\n      value = applyTransform(value, mapping.transform);\r\n    }\r\n    \r\n    // Use resolved field key instead of original reference\r\n    entityData[resolvedTarget.fieldKey] = value;\r\n  }\r\n  \r\n  const entityName = (schema as any).name || action.schemaId;\r\n  const entityPath = `${COL.ORGANIZATIONS}/${organizationId}/${COL.WORKSPACES}/${workspaceId}/entities/${entityName}`;\r\n  \r\n  const recordId = `rec_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\r\n  await FS.set(entityPath, recordId, {\r\n    ...entityData,\r\n    createdAt: new Date().toISOString(),\r\n    updatedAt: new Date().toISOString(),\r\n  }, false);\r\n  \r\n  return { recordId, success: true };\r\n}\r\n\r\n/**\r\n * Execute update entity action\r\n */\r\nexport async function executeUpdateEntityAction(\r\n  action: UpdateEntityAction,\r\n  triggerData: any,\r\n  organizationId: string,\r\n  workspaceId: string\r\n): Promise<any> {\r\n  // Get schema\r\n  const { FirestoreService: FS, COLLECTIONS: COL } = await import('@/lib/db/firestore-service');\r\n  const schemaData = await FS.get(\r\n    `${COL.ORGANIZATIONS}/${organizationId}/${COL.WORKSPACES}/${workspaceId}/${COL.SCHEMAS}`,\r\n    action.schemaId\r\n  );\r\n  \r\n  if (!schemaData) {\r\n    throw new Error(`Schema ${action.schemaId} not found`);\r\n  }\r\n  \r\n  const schema = schemaData as Schema;\r\n  const entityName = schema.name || action.schemaId;\r\n  const entityPath = `${COL.ORGANIZATIONS}/${organizationId}/${COL.WORKSPACES}/${workspaceId}/entities/${entityName}`;\r\n  \r\n  // Determine which record(s) to update\r\n  let recordIds: string[] = [];\r\n  \r\n  if (action.targetRecord === 'trigger') {\r\n    const triggerRecordId = triggerData?.recordId || triggerData?.id;\r\n    if (!triggerRecordId) {\r\n      throw new Error('No record ID in trigger data');\r\n    }\r\n    recordIds = [triggerRecordId];\r\n  } else if (action.targetRecord === 'specific' && action.entityId) {\r\n    recordIds = [action.entityId];\r\n  } else if (action.targetRecord === 'query' && action.query) {\r\n    // Query entities matching the criteria\r\n    const queryResults = await queryEntities({\r\n      entityPath,\r\n      query: action.query,\r\n      triggerData,\r\n    });\r\n    recordIds = queryResults.map((r: any) => r.id);\r\n    if (recordIds.length === 0) {\r\n      throw new Error('No records found matching query');\r\n    }\r\n  }\r\n  \r\n  // Build update data from field mappings with dynamic field resolution\r\n  const updateData: Record<string, any> = {};\r\n  const { FieldResolver } = await import('@/lib/schema/field-resolver');\r\n  \r\n  for (const mapping of action.fieldMappings) {\r\n    let value: any;\r\n    \r\n    // Resolve target field\r\n    const resolvedTarget = await FieldResolver.resolveFieldWithCommonAliases(\r\n      schema,\r\n      mapping.targetField\r\n    );\r\n    \r\n    if (!resolvedTarget) {\r\n      logger.warn('[Entity Action] Target field not found in schema for update', {\r\n        file: 'entity-action.ts',\r\n        targetField: mapping.targetField,\r\n        schemaId: action.schemaId,\r\n      });\r\n      continue;\r\n    }\r\n    \r\n    switch (mapping.source) {\r\n      case 'static':\r\n        value = mapping.staticValue;\r\n        break;\r\n      case 'trigger':\r\n        value = FieldResolver.getFieldValue(triggerData, mapping.sourceField || '');\r\n        break;\r\n      default:\r\n        value = null;\r\n    }\r\n    \r\n    if (mapping.transform && value !== null && value !== undefined) {\r\n      value = applyTransform(value, mapping.transform);\r\n    }\r\n    \r\n    updateData[resolvedTarget.fieldKey] = value;\r\n  }\r\n  \r\n  // Update records\r\n  for (const recordId of recordIds) {\r\n    const existing = await FS.get(entityPath, recordId);\r\n    if (!existing) {\r\n      throw new Error(`Record ${recordId} not found`);\r\n    }\r\n    \r\n    await FS.set(entityPath, recordId, {\r\n      ...existing,\r\n      ...updateData,\r\n      updatedAt: new Date().toISOString(),\r\n    }, false);\r\n  }\r\n  \r\n  return { recordIds, success: true };\r\n}\r\n\r\n/**\r\n * Execute delete entity action\r\n */\r\nexport async function executeDeleteEntityAction(\r\n  action: DeleteEntityAction,\r\n  triggerData: any,\r\n  organizationId: string,\r\n  workspaceId: string\r\n): Promise<any> {\r\n  // Get schema\r\n  const { FirestoreService: FS, COLLECTIONS: COL } = await import('@/lib/db/firestore-service');\r\n  const schemaData = await FS.get(\r\n    `${COL.ORGANIZATIONS}/${organizationId}/${COL.WORKSPACES}/${workspaceId}/${COL.SCHEMAS}`,\r\n    action.schemaId\r\n  );\r\n  \r\n  if (!schemaData) {\r\n    throw new Error(`Schema ${action.schemaId} not found`);\r\n  }\r\n  \r\n  const schema = schemaData as Schema;\r\n  const entityName = schema.name || action.schemaId;\r\n  const entityPath = `${COL.ORGANIZATIONS}/${organizationId}/${COL.WORKSPACES}/${workspaceId}/entities/${entityName}`;\r\n  \r\n  // Determine which record(s) to delete\r\n  let recordIds: string[] = [];\r\n  \r\n  if (action.targetRecord === 'trigger') {\r\n    const triggerRecordId = triggerData?.recordId || triggerData?.id;\r\n    if (!triggerRecordId) {\r\n      throw new Error('No record ID in trigger data');\r\n    }\r\n    recordIds = [triggerRecordId];\r\n  } else if (action.targetRecord === 'specific' && action.entityId) {\r\n    recordIds = [action.entityId];\r\n  } else if (action.targetRecord === 'query' && action.query) {\r\n    // Query entities matching the criteria\r\n    const queryResults = await queryEntities({\r\n      entityPath,\r\n      query: action.query,\r\n      triggerData,\r\n    });\r\n    recordIds = queryResults.map((r: any) => r.id);\r\n    if (recordIds.length === 0) {\r\n      logger.info('[Entity Action] No records found matching query for delete', { file: 'entity-action.ts' });\r\n      return { recordIds: [], success: true, message: 'No records matched query' };\r\n    }\r\n  }\r\n  \r\n  // Delete records\r\n  for (const recordId of recordIds) {\r\n    if (action.softDelete) {\r\n      // Soft delete: mark as deleted\r\n      const existing = await FS.get(entityPath, recordId);\r\n      if (existing) {\r\n        await FS.set(entityPath, recordId, {\r\n          ...existing,\r\n          deleted: true,\r\n          deletedAt: new Date().toISOString(),\r\n          updatedAt: new Date().toISOString(),\r\n        }, false);\r\n      }\r\n    } else {\r\n      // Hard delete\r\n      await FS.delete(entityPath, recordId);\r\n    }\r\n  }\r\n  \r\n  return { recordIds, success: true };\r\n}\r\n\r\n/**\r\n * Execute entity action (router)\r\n */\r\nexport async function executeEntityAction(\r\n  action: CreateEntityAction | UpdateEntityAction | DeleteEntityAction,\r\n  triggerData: any,\r\n  organizationId: string\r\n): Promise<any> {\r\n  const workspaceId = triggerData?.workspaceId || (action as any).workspaceId;\r\n  if (!workspaceId) {\r\n    throw new Error('Workspace ID required for entity actions');\r\n  }\r\n  \r\n  if (action.type === 'create_entity') {\r\n    return executeCreateEntityAction(action, triggerData, organizationId, workspaceId);\r\n  } else if (action.type === 'update_entity') {\r\n    return executeUpdateEntityAction(action, triggerData, organizationId, workspaceId);\r\n  } else if (action.type === 'delete_entity') {\r\n    return executeDeleteEntityAction(action, triggerData, organizationId, workspaceId);\r\n  } else {\r\n    const actionType = (action as any).type;\r\n    throw new Error(`Unknown entity action type: ${actionType}`);\r\n  }\r\n}\r\n\r\n/**\r\n * Apply field transform\r\n */\r\nfunction applyTransform(value: any, transform: any): any {\r\n  switch (transform.type) {\r\n    case 'uppercase':\r\n      return String(value).toUpperCase();\r\n    case 'lowercase':\r\n      return String(value).toLowerCase();\r\n    case 'trim':\r\n      return String(value).trim();\r\n    default:\r\n      return value;\r\n  }\r\n}\r\n\r\n/**\r\n * Resolve variables in config\r\n */\r\nfunction resolveVariables(config: any, triggerData: any): any {\r\n  if (typeof config === 'string') {\r\n    return config.replace(/\\{\\{([^}]+)\\}\\}/g, (match, path) => {\r\n      const value = getNestedValue(triggerData, path.trim());\r\n      return value !== undefined ? String(value) : match;\r\n    });\r\n  } else if (Array.isArray(config)) {\r\n    return config.map(item => resolveVariables(item, triggerData));\r\n  } else if (config && typeof config === 'object') {\r\n    const resolved: any = {};\r\n    for (const key in config) {\r\n      resolved[key] = resolveVariables(config[key], triggerData);\r\n    }\r\n    return resolved;\r\n  }\r\n  return config;\r\n}\r\n\r\n/**\r\n * Get nested value from object using dot notation\r\n */\r\nfunction getNestedValue(obj: any, path: string): any {\r\n  return path.split('.').reduce((current, key) => current?.[key], obj);\r\n}\r\n\r\n/**\r\n * Generate value using AI\r\n */\r\nasync function generateWithAI(params: {\r\n  organizationId: string;\r\n  field: string;\r\n  prompt: string;\r\n  context: any;\r\n}): Promise<string> {\r\n  const { organizationId, field, prompt, context } = params;\r\n  \r\n  try {\r\n    const { sendUnifiedChatMessage } = await import('@/lib/ai/unified-ai-service');\r\n    \r\n    // Build context-aware prompt\r\n    const fullPrompt = `You are helping generate data for a workflow automation.\r\n\r\nField to generate: ${field}\r\nInstructions: ${prompt}\r\n\r\nContext data:\r\n${JSON.stringify(context, null, 2).slice(0, 2000)}\r\n\r\nGenerate ONLY the value for this field. Do not include any explanation or formatting - just the raw value.`;\r\n\r\n    const response = await sendUnifiedChatMessage({\r\n      model: 'gpt-4-turbo',\r\n      messages: [{ role: 'user', content: fullPrompt }],\r\n      temperature: 0.7,\r\n      maxTokens: 500,\r\n    });\r\n    \r\n    return response.text.trim();\r\n  } catch (error) {\r\n    logger.error('[Entity Action] AI generation failed:', error, { file: 'entity-action.ts' });\r\n    return `[AI Error: ${error}]`;\r\n  }\r\n}\r\n\r\n/**\r\n * Query entities based on criteria\r\n */\r\nasync function queryEntities(params: {\r\n  entityPath: string;\r\n  query: any;\r\n  triggerData: any;\r\n}): Promise<any[]> {\r\n  const { entityPath, query, triggerData } = params;\r\n  const { FirestoreService: FS } = await import('@/lib/db/firestore-service');\r\n  \r\n  // Build Firestore query from criteria\r\n  const filters: any[] = [];\r\n  \r\n  if (query.filters && Array.isArray(query.filters)) {\r\n    for (const filter of query.filters) {\r\n      let value = filter.value;\r\n      \r\n      // Resolve dynamic values\r\n      if (typeof value === 'string' && value.startsWith('{{') && value.endsWith('}}')) {\r\n        const path = value.slice(2, -2).trim();\r\n        value = getNestedValue(triggerData, path);\r\n      }\r\n      \r\n      filters.push({\r\n        field: filter.field,\r\n        operator: mapOperator(filter.operator),\r\n        value,\r\n      });\r\n    }\r\n  }\r\n  \r\n  // Get matching records\r\n  const results = await FS.getAll(entityPath, filters);\r\n  \r\n  // Apply limit if specified\r\n  if (query.limit && typeof query.limit === 'number') {\r\n    return results.slice(0, query.limit);\r\n  }\r\n  \r\n  return results;\r\n}\r\n\r\n/**\r\n * Map query operator to Firestore operator\r\n */\r\nfunction mapOperator(op: string): string {\r\n  const operatorMap: Record<string, string> = {\r\n    'equals': '==',\r\n    'not_equals': '!=',\r\n    'greater_than': '>',\r\n    'less_than': '<',\r\n    'greater_than_or_equals': '>=',\r\n    'less_than_or_equals': '<=',\r\n    'contains': 'array-contains',\r\n    'in': 'in',\r\n    'not_in': 'not-in',\r\n  };\r\n  return operatorMap[op] || '==';\r\n}\r\n\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\David\\PycharmProjects\\AI Sales Platform\\src\\lib\\workflows\\triggers\\schedule-trigger.ts","messages":[{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":10,"column":20,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":10,"endColumn":42}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Schedule Trigger Handler\r\n * Handles scheduled workflow execution (cron jobs)\r\n */\r\n\r\nimport { FirestoreService, COLLECTIONS } from '@/lib/db/firestore-service';\r\nimport type { Workflow, ScheduleTrigger } from '@/types/workflow';\r\nimport { executeWorkflow } from '../workflow-executor';\r\nimport { logger } from '@/lib/logger/logger';\r\nconst cronParser = require('cron-parser');\r\n\r\n/**\r\n * Register schedule trigger\r\n * In production, this would set up Cloud Scheduler\r\n */\r\nexport async function registerScheduleTrigger(\r\n  workflow: Workflow,\r\n  organizationId: string,\r\n  workspaceId: string\r\n): Promise<void> {\r\n  const trigger = workflow.trigger as ScheduleTrigger;\r\n  \r\n  if (!trigger || trigger.type !== 'schedule') {\r\n    return;\r\n  }\r\n  \r\n  // Store schedule configuration\r\n  await FirestoreService.set(\r\n    `${COLLECTIONS.ORGANIZATIONS}/${organizationId}/${COLLECTIONS.WORKSPACES}/${workspaceId}/scheduleTriggers`,\r\n    workflow.id,\r\n    {\r\n      workflowId: workflow.id,\r\n      schedule: trigger.schedule,\r\n      organizationId,\r\n      workspaceId,\r\n      registeredAt: new Date().toISOString(),\r\n      nextRun: calculateNextRun(trigger.schedule),\r\n    },\r\n    false\r\n  );\r\n  \r\n  logger.info('Schedule Trigger Registered schedule for workflow workflow.id}', { file: 'schedule-trigger.ts' });\r\n}\r\n\r\n/**\r\n * Calculate next run time from schedule\r\n */\r\nfunction calculateNextRun(schedule: ScheduleTrigger['schedule']): string {\r\n  const now = new Date();\r\n  \r\n  if (schedule.type === 'interval') {\r\n    const interval = schedule.interval!;\r\n    let milliseconds = interval.value;\r\n    \r\n    switch (interval.unit) {\r\n      case 'minutes':\r\n        milliseconds *= 60 * 1000;\r\n        break;\r\n      case 'hours':\r\n        milliseconds *= 60 * 60 * 1000;\r\n        break;\r\n      case 'days':\r\n        milliseconds *= 24 * 60 * 60 * 1000;\r\n        break;\r\n      case 'weeks':\r\n        milliseconds *= 7 * 24 * 60 * 60 * 1000;\r\n        break;\r\n      case 'months':\r\n        milliseconds *= 30 * 24 * 60 * 60 * 1000; // Approximate\r\n        break;\r\n    }\r\n    \r\n    return new Date(now.getTime() + milliseconds).toISOString();\r\n  } else if (schedule.type === 'cron') {\r\n    try {\r\n      const cronExpression = schedule.cron!;\r\n      \r\n      // Validate and parse cron expression\r\n      const interval = cronParser.parseExpression(cronExpression, {\r\n        currentDate: now,\r\n        tz: 'UTC' // Or get from organization settings\r\n      });\r\n      \r\n      // Get next occurrence\r\n      const next = interval.next().toDate();\r\n      return next.toISOString();\r\n    } catch (error) {\r\n      logger.error('[Schedule] Invalid cron expression', error, {\r\n        cron: schedule.cron,\r\n        file: 'schedule-trigger.ts'\r\n      });\r\n      \r\n      // Fallback to 1 day from now if invalid\r\n      return new Date(now.getTime() + 24 * 60 * 60 * 1000).toISOString();\r\n    }\r\n  }\r\n  \r\n  return now.toISOString();\r\n}\r\n\r\n/**\r\n * Execute scheduled workflows\r\n * This would be called by Cloud Scheduler or a cron job\r\n */\r\nexport async function executeScheduledWorkflows(): Promise<void> {\r\n  const now = new Date().toISOString();\r\n  \r\n  // Find all schedule triggers that are due\r\n  const { where, orderBy, limit } = await import('firebase/firestore');\r\n  \r\n  // Get all organizations\r\n  const orgs = await FirestoreService.getAll(COLLECTIONS.ORGANIZATIONS, []);\r\n  \r\n  for (const org of orgs) {\r\n    const workspaces = await FirestoreService.getAll(\r\n      `${COLLECTIONS.ORGANIZATIONS}/${org.id}/${COLLECTIONS.WORKSPACES}`,\r\n      []\r\n    );\r\n    \r\n    for (const workspace of workspaces) {\r\n      const triggers = await FirestoreService.getAll(\r\n        `${COLLECTIONS.ORGANIZATIONS}/${org.id}/${COLLECTIONS.WORKSPACES}/${workspace.id}/scheduleTriggers`,\r\n        [\r\n          where('nextRun', '<=', now),\r\n          orderBy('nextRun', 'asc'),\r\n          limit(100), // Process in batches\r\n        ]\r\n      );\r\n      \r\n      for (const trigger of triggers) {\r\n        try {\r\n          // Load workflow\r\n          const workflow = await FirestoreService.get(\r\n            `${COLLECTIONS.ORGANIZATIONS}/${org.id}/${COLLECTIONS.WORKSPACES}/${workspace.id}/${COLLECTIONS.WORKFLOWS}`,\r\n            trigger.workflowId\r\n          );\r\n          \r\n          if (!workflow || (workflow as any).status !== 'active') {\r\n            continue; // Skip inactive workflows\r\n          }\r\n          \r\n          // Execute workflow\r\n          const triggerData = {\r\n            organizationId: org.id,\r\n            workspaceId: workspace.id,\r\n            scheduledAt: now,\r\n            scheduleType: (trigger as any).schedule.type,\r\n          };\r\n          \r\n          await executeWorkflow(workflow as Workflow, triggerData);\r\n          \r\n          // Update next run time\r\n          const scheduleTrigger = workflow.trigger as ScheduleTrigger;\r\n          const nextRun = calculateNextRun(scheduleTrigger.schedule);\r\n          \r\n          await FirestoreService.set(\r\n            `${COLLECTIONS.ORGANIZATIONS}/${org.id}/${COLLECTIONS.WORKSPACES}/${workspace.id}/scheduleTriggers`,\r\n            trigger.workflowId,\r\n            {\r\n              ...trigger,\r\n              nextRun,\r\n              lastRun: now,\r\n            },\r\n            false\r\n          );\r\n        } catch (error) {\r\n          logger.error('[Schedule Trigger] Error executing workflow ${trigger.workflowId}:', error, { file: 'schedule-trigger.ts' });\r\n          // Continue with other workflows\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Unregister schedule trigger\r\n */\r\nexport async function unregisterScheduleTrigger(\r\n  workflowId: string,\r\n  organizationId: string,\r\n  workspaceId: string\r\n): Promise<void> {\r\n  await FirestoreService.delete(\r\n    `${COLLECTIONS.ORGANIZATIONS}/${organizationId}/${COLLECTIONS.WORKSPACES}/${workspaceId}/scheduleTriggers`,\r\n    workflowId\r\n  );\r\n  \r\n  logger.info('Schedule Trigger Unregistered schedule for workflow workflowId}', { file: 'schedule-trigger.ts' });\r\n}\r\n\r\n/**\r\n * Validate cron expression\r\n */\r\nexport function validateCronExpression(cron: string): { valid: boolean; error?: string } {\r\n  try {\r\n    cronParser.parseExpression(cron);\r\n    return { valid: true };\r\n  } catch (error) {\r\n    return { \r\n      valid: false, \r\n      error: error instanceof Error ? error.message : 'Invalid cron expression'\r\n    };\r\n  }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n","usedDeprecatedRules":[]}]
